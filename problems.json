{"1": {"__typename": "QuestionLightNode", "acRate": 0.5356000277349409, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "1", "isFavor": false, "solutionNum": 24431, "title": "Two Sum", "titleCn": "两数之和", "titleSlug": "two-sum", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 456, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个整数数组 <code>nums</code>&nbsp;和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值 </strong><em><code>target</code></em>&nbsp; 的那&nbsp;<strong>两个</strong>&nbsp;整数，并返回它们的数组下标。</p>\n\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>\n\n<p>你可以按任意顺序返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,7,11,15], target = 9\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,4], target = 6\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3], target = 6\n<strong>输出：</strong>[0,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>只会存在一个有效答案</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n<sup>2</sup>)</code> 的算法吗？</p>\n", "en": "<p>Given an array of integers <code>nums</code>&nbsp;and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>\n\n<p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p>\n\n<p>You can return the answer in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,7,11,15], target = 9\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,4], target = 6\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,3], target = 6\n<strong>Output:</strong> [0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>Only one valid answer exists.</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow-up:&nbsp;</strong>Can you come up with an algorithm that is less than <code>O(n<sup>2</sup>)</code><font face=\"monospace\">&nbsp;</font>time complexity?"}}, "2": {"__typename": "QuestionLightNode", "acRate": 0.4351589825321835, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "2", "isFavor": false, "solutionNum": 13577, "title": "Add Two Numbers", "titleCn": "两数相加", "titleSlug": "add-two-numbers", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 237, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>\n\n<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>\n\n<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg\" style=\"width: 483px; height: 342px;\" />\n<pre>\n<strong>输入：</strong>l1 = [2,4,3], l2 = [5,6,4]\n<strong>输出：</strong>[7,0,8]\n<strong>解释：</strong>342 + 465 = 807.\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [0], l2 = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n<strong>输出：</strong>[8,9,9,9,0,0,0,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>\n\t<li><code>0 <= Node.val <= 9</code></li>\n\t<li>题目数据保证列表表示的数字不含前导零</li>\n</ul>\n", "en": "<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum&nbsp;as a linked list.</p>\n\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg\" style=\"width: 483px; height: 342px;\" />\n<pre>\n<strong>Input:</strong> l1 = [2,4,3], l2 = [5,6,4]\n<strong>Output:</strong> [7,0,8]\n<strong>Explanation:</strong> 342 + 465 = 807.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [0], l2 = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n<strong>Output:</strong> [8,9,9,9,0,0,0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n\t<li>It is guaranteed that the list represents a number that does not have leading zeros.</li>\n</ul>\n"}}, "3": {"__typename": "QuestionLightNode", "acRate": 0.39696505928388265, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "3", "isFavor": false, "solutionNum": 15675, "title": "Longest Substring Without Repeating Characters", "titleCn": "无重复字符的最长子串", "titleSlug": "longest-substring-without-repeating-characters", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 325, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的&nbsp;<strong>最长<span data-keyword=\"substring\">子串</span></strong><strong>&nbsp;</strong>的长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"abcabcbb\"\n<strong>输出: </strong>3 \n<strong>解释:</strong> 因为无重复字符的最长子串是 <code>\"abc\"</code>，所以其长度为 3。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"bbbbb\"\n<strong>输出: </strong>1\n<strong>解释: </strong>因为无重复字符的最长子串是 <code>\"b\"</code>，所以其长度为 1。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"pwwkew\"\n<strong>输出: </strong>3\n<strong>解释: </strong>因为无重复字符的最长子串是&nbsp;<code>\"wke\"</code>，所以其长度为 3。\n&nbsp;    请注意，你的答案必须是 <strong>子串 </strong>的长度，<code>\"pwke\"</code>&nbsp;是一个<em>子序列，</em>不是子串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;由英文字母、数字、符号和空格组成</li>\n</ul>\n", "en": "<p>Given a string <code>s</code>, find the length of the <strong>longest</strong> <span data-keyword=\"substring-nonempty\"><strong>substring</strong></span> without repeating characters.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcabcbb&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The answer is &quot;abc&quot;, with the length of 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bbbbb&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The answer is &quot;b&quot;, with the length of 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pwwkew&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The answer is &quot;wke&quot;, with the length of 3.\nNotice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of English letters, digits, symbols and spaces.</li>\n</ul>\n"}}, "4": {"__typename": "QuestionLightNode", "acRate": 0.421419586785148, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "4", "isFavor": false, "solutionNum": 7745, "title": "Median of Two Sorted Arrays", "titleCn": "寻找两个正序数组的中位数", "titleSlug": "median-of-two-sorted-arrays", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 197, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>\n\n<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,3], nums2 = [2]\n<strong>输出：</strong>2.00000\n<strong>解释：</strong>合并数组 = [1,2,3] ，中位数 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2], nums2 = [3,4]\n<strong>输出：</strong>2.50000\n<strong>解释：</strong>合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m &lt;= 1000</code></li>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n", "en": "<p>Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return <strong>the median</strong> of the two sorted arrays.</p>\n\n<p>The overall run time complexity should be <code>O(log (m+n))</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,3], nums2 = [2]\n<strong>Output:</strong> 2.00000\n<strong>Explanation:</strong> merged array = [1,2,3] and median is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2], nums2 = [3,4]\n<strong>Output:</strong> 2.50000\n<strong>Explanation:</strong> merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m &lt;= 1000</code></li>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n"}}, "5": {"__typename": "QuestionLightNode", "acRate": 0.38239032953630486, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "5", "isFavor": false, "solutionNum": 8606, "title": "Longest Palindromic Substring", "titleCn": "最长回文子串", "titleSlug": "longest-palindromic-substring", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 253, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文<span data-keyword=\"substring\">子串</span>。</p>\n\n<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"babad\"\n<strong>输出：</strong>\"bab\"\n<strong>解释：</strong>\"aba\" 同样是符合题意的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cbbd\"\n<strong>输出：</strong>\"bb\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 仅由数字和英文字母组成</li>\n</ul>\n", "en": "<p>Given a string <code>s</code>, return <em>the longest</em> <span data-keyword=\"palindromic-string\"><em>palindromic</em></span> <span data-keyword=\"substring-nonempty\"><em>substring</em></span> in <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;babad&quot;\n<strong>Output:</strong> &quot;bab&quot;\n<strong>Explanation:</strong> &quot;aba&quot; is also a valid answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cbbd&quot;\n<strong>Output:</strong> &quot;bb&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consist of only digits and English letters.</li>\n</ul>\n"}}, "6": {"__typename": "QuestionLightNode", "acRate": 0.5274030955516518, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "6", "isFavor": false, "solutionNum": 5235, "title": "Zigzag Conversion", "titleCn": "Z 字形变换", "titleSlug": "zigzag-conversion", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 90, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/9796c950529d841a0ba57e688dc64e04426c251315994b1fdeb8247d60c34930-unnamed.jpg", "slug": "paypal", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p>\n\n<p>比如输入字符串为 <code>\"PAYPALISHIRING\"</code> 行数为 <code>3</code> 时，排列如下：</p>\n\n<pre>\nP   A   H   N\nA P L S I I G\nY   I   R</pre>\n\n<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>\"PAHNAPLSIIGYIR\"</code>。</p>\n\n<p>请你实现这个将字符串进行指定行数变换的函数：</p>\n\n<pre>\nstring convert(string s, int numRows);</pre>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"PAYPALISHIRING\", numRows = 3\n<strong>输出：</strong>\"PAHNAPLSIIGYIR\"\n</pre>\n<strong>示例 2：</strong>\n\n<pre>\n<strong>输入：</strong>s = \"PAYPALISHIRING\", numRows = 4\n<strong>输出：</strong>\"PINALSIGYAHRPI\"\n<strong>解释：</strong>\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"A\", numRows = 1\n<strong>输出：</strong>\"A\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s</code> 由英文字母（小写和大写）、<code>','</code> 和 <code>'.'</code> 组成</li>\n\t<li><code>1 <= numRows <= 1000</code></li>\n</ul>\n", "en": "<p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>\n\n<pre>\nP   A   H   N\nA P L S I I G\nY   I   R\n</pre>\n\n<p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p>\n\n<p>Write the code that will take a string and make this conversion given a number of rows:</p>\n\n<pre>\nstring convert(string s, int numRows);\n</pre>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;PAYPALISHIRING&quot;, numRows = 3\n<strong>Output:</strong> &quot;PAHNAPLSIIGYIR&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;PAYPALISHIRING&quot;, numRows = 4\n<strong>Output:</strong> &quot;PINALSIGYAHRPI&quot;\n<strong>Explanation:</strong>\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;A&quot;, numRows = 1\n<strong>Output:</strong> &quot;A&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consists of English letters (lower-case and upper-case), <code>&#39;,&#39;</code> and <code>&#39;.&#39;</code>.</li>\n\t<li><code>1 &lt;= numRows &lt;= 1000</code></li>\n</ul>\n"}}, "7": {"__typename": "QuestionLightNode", "acRate": 0.3547110609666713, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "7", "isFavor": false, "solutionNum": 7690, "title": "Reverse Integer", "titleCn": "整数反转", "titleSlug": "reverse-integer", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 168, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>\n\n<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−2<sup>31</sup>,  2<sup>31 </sup>− 1]</code> ，就返回 0。</p>\n<strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 123\n<strong>输出：</strong>321\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = -123\n<strong>输出：</strong>-321\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 120\n<strong>输出：</strong>21\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 0\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> <= x <= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given a signed 32-bit integer <code>x</code>, return <code>x</code><em> with its digits reversed</em>. If reversing <code>x</code> causes the value to go outside the signed 32-bit integer range <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>, then return <code>0</code>.</p>\n\n<p><strong>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</strong></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 123\n<strong>Output:</strong> 321\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = -123\n<strong>Output:</strong> -321\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 120\n<strong>Output:</strong> 21\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= x &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "8": {"__typename": "QuestionLightNode", "acRate": 0.21184041737909892, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "8", "isFavor": false, "solutionNum": 4636, "title": "String to Integer (atoi)", "titleCn": "字符串转换整数 (atoi)", "titleSlug": "string-to-integer-atoi", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 124, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>请你来实现一个&nbsp;<code>myAtoi(string s)</code>&nbsp;函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p>\n\n<p>函数&nbsp;<code>myAtoi(string s)</code> 的算法如下：</p>\n\n<ol>\n\t<li>读入字符串并丢弃无用的前导空格</li>\n\t<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>\n\t<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>\n\t<li>将前面步骤读入的这些数字转换为整数（即，\"123\" -&gt; 123， \"0032\" -&gt; 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li>\n\t<li>如果整数数超过 32 位有符号整数范围 <code>[−2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>− 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−2<sup>31</sup></code> 的整数应该被固定为 <code>−2<sup>31</sup></code> ，大于 <code>2<sup>31&nbsp;</sup>− 1</code> 的整数应该被固定为 <code>2<sup>31&nbsp;</sup>− 1</code> 。</li>\n\t<li>返回整数作为最终结果。</li>\n</ol>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>本题中的空白字符只包括空格字符 <code>' '</code> 。</li>\n\t<li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"42\"\n<strong>输出：</strong>42\n<strong>解释：</strong>加粗的字符串为已经读入的字符，插入符号是当前读取的字符。\n第 1 步：\"42\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"42\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"<u>42</u>\"（读入 \"42\"）\n           ^\n解析得到整数 42 。\n由于 \"42\" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 42 。</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"   -42\"\n<strong>输出：</strong>-42\n<strong>解释：</strong>\n第 1 步：\"<u><strong>   </strong></u>-42\"（读入前导空格，但忽视掉）\n            ^\n第 2 步：\"   <u><strong>-</strong></u>42\"（读入 '-' 字符，所以结果应该是负数）\n             ^\n第 3 步：\"   <u><strong>-42</strong></u>\"（读入 \"42\"）\n               ^\n解析得到整数 -42 。\n由于 \"-42\" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 -42 。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"4193 with words\"\n<strong>输出：</strong>4193\n<strong>解释：</strong>\n第 1 步：\"4193 with words\"（当前没有读入字符，因为没有前导空格）\n         ^\n第 2 步：\"4193 with words\"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）\n         ^\n第 3 步：\"<u>4193</u> with words\"（读入 \"4193\"；由于下一个字符不是一个数字，所以读入停止）\n             ^\n解析得到整数 4193 。\n由于 \"4193\" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 4193 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>' '</code>、<code>'+'</code>、<code>'-'</code> 和 <code>'.'</code> 组成</li>\n</ul>\n", "en": "<p>Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer (similar to C/C++&#39;s <code>atoi</code> function).</p>\n\n<p>The algorithm for <code>myAtoi(string s)</code> is as follows:</p>\n\n<ol>\n\t<li>Read in and ignore any leading whitespace.</li>\n\t<li>Check if the next character (if not already at the end of the string) is <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code>. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.</li>\n\t<li>Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.</li>\n\t<li>Convert these digits into an integer (i.e. <code>&quot;123&quot; -&gt; 123</code>, <code>&quot;0032&quot; -&gt; 32</code>). If no digits were read, then the integer is <code>0</code>. Change the sign as necessary (from step 2).</li>\n\t<li>If the integer is out of the 32-bit signed integer range <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>, then clamp the integer so that it remains in the range. Specifically, integers less than <code>-2<sup>31</sup></code> should be clamped to <code>-2<sup>31</sup></code>, and integers greater than <code>2<sup>31</sup> - 1</code> should be clamped to <code>2<sup>31</sup> - 1</code>.</li>\n\t<li>Return the integer as the final result.</li>\n</ol>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>Only the space character <code>&#39; &#39;</code> is considered a whitespace character.</li>\n\t<li><strong>Do not ignore</strong> any characters other than the leading whitespace or the rest of the string after the digits.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;42&quot;\n<strong>Output:</strong> 42\n<strong>Explanation:</strong> The underlined characters are what is read in, the caret is the current reader position.\nStep 1: &quot;42&quot; (no characters read because there is no leading whitespace)\n         ^\nStep 2: &quot;42&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)\n         ^\nStep 3: &quot;<u>42</u>&quot; (&quot;42&quot; is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is 42.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;   -42&quot;\n<strong>Output:</strong> -42\n<strong>Explanation:</strong>\nStep 1: &quot;<u>   </u>-42&quot; (leading whitespace is read and ignored)\n            ^\nStep 2: &quot;   <u>-</u>42&quot; (&#39;-&#39; is read, so the result should be negative)\n             ^\nStep 3: &quot;   -<u>42</u>&quot; (&quot;42&quot; is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is -42.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;4193 with words&quot;\n<strong>Output:</strong> 4193\n<strong>Explanation:</strong>\nStep 1: &quot;4193 with words&quot; (no characters read because there is no leading whitespace)\n         ^\nStep 2: &quot;4193 with words&quot; (no characters read because there is neither a &#39;-&#39; nor &#39;+&#39;)\n         ^\nStep 3: &quot;<u>4193</u> with words&quot; (&quot;4193&quot; is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is 4193.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 200</code></li>\n\t<li><code>s</code> consists of English letters (lower-case and upper-case), digits (<code>0-9</code>), <code>&#39; &#39;</code>, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;.&#39;</code>.</li>\n</ul>\n"}}, "9": {"__typename": "QuestionLightNode", "acRate": 0.5597739323942595, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "9", "isFavor": false, "solutionNum": 9369, "title": "Palindrome Number", "titleCn": "回文数", "titleSlug": "palindrome-number", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 138, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p><span data-keyword=\"palindrome-integer\">回文数</span>是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>\n\n<ul>\n\t<li>例如，<code>121</code> 是回文，而 <code>123</code> 不是。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 121\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = -121\n<strong>输出：</strong>false\n<strong>解释：</strong>从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 10\n<strong>输出：</strong>false\n<strong>解释：</strong>从右向左读, 为 01 。因此它不是一个回文数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= x &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能不将整数转为字符串来解决这个问题吗？</p>\n", "en": "<p>Given an integer <code>x</code>, return <code>true</code><em> if </em><code>x</code><em> is a </em><span data-keyword=\"palindrome-integer\"><em><strong>palindrome</strong></em></span><em>, and </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 121\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 121 reads as 121 from left to right and from right to left.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = -121\n<strong>Output:</strong> false\n<strong>Explanation:</strong> From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 10\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Reads 01 from right to left. Therefore it is not a palindrome.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= x &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without converting the integer to a string?"}}, "10": {"__typename": "QuestionLightNode", "acRate": 0.3069752093998155, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "10", "isFavor": false, "solutionNum": 2393, "title": "Regular Expression Matching", "titleCn": "正则表达式匹配", "titleSlug": "regular-expression-matching", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 114, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串&nbsp;<code>s</code>&nbsp;和一个字符规律&nbsp;<code>p</code>，请你来实现一个支持 <code>'.'</code>&nbsp;和&nbsp;<code>'*'</code>&nbsp;的正则表达式匹配。</p>\n\n<ul>\n\t<li><code>'.'</code> 匹配任意单个字符</li>\n\t<li><code>'*'</code> 匹配零个或多个前面的那一个元素</li>\n</ul>\n\n<p>所谓匹配，是要涵盖&nbsp;<strong>整个&nbsp;</strong>字符串&nbsp;<code>s</code>的，而不是部分字符串。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aa\", p = \"a\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\"a\" 无法匹配 \"aa\" 整个字符串。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aa\", p = \"a*\"\n<strong>输出：</strong>true\n<strong>解释：</strong>因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab\", p = \".*\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length&nbsp;&lt;= 20</code></li>\n\t<li><code>1 &lt;= p.length&nbsp;&lt;= 20</code></li>\n\t<li><code>s</code>&nbsp;只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母。</li>\n\t<li><code>p</code>&nbsp;只包含从&nbsp;<code>a-z</code>&nbsp;的小写字母，以及字符&nbsp;<code>.</code>&nbsp;和&nbsp;<code>*</code>。</li>\n\t<li>保证每次出现字符&nbsp;<code>*</code> 时，前面都匹配到有效的字符</li>\n</ul>\n", "en": "<p>Given an input string <code>s</code>&nbsp;and a pattern <code>p</code>, implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code> where:</p>\n\n<ul>\n\t<li><code>&#39;.&#39;</code> Matches any single character.​​​​</li>\n\t<li><code>&#39;*&#39;</code> Matches zero or more of the preceding element.</li>\n</ul>\n\n<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;a&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;a&quot; does not match the entire string &quot;aa&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;a*&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ab&quot;, p = &quot;.*&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length&nbsp;&lt;= 20</code></li>\n\t<li><code>1 &lt;= p.length&nbsp;&lt;= 20</code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n\t<li><code>p</code> contains only lowercase English letters, <code>&#39;.&#39;</code>, and&nbsp;<code>&#39;*&#39;</code>.</li>\n\t<li>It is guaranteed for each appearance of the character <code>&#39;*&#39;</code>, there will be a previous valid character to match.</li>\n</ul>\n"}}, "11": {"__typename": "QuestionLightNode", "acRate": 0.6008973980323852, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "11", "isFavor": false, "solutionNum": 6550, "title": "Container With Most Water", "titleCn": "盛最多水的容器", "titleSlug": "container-with-most-water", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 196, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个长度为 <code>n</code> 的整数数组&nbsp;<code>height</code>&nbsp;。有&nbsp;<code>n</code>&nbsp;条垂线，第 <code>i</code> 条线的两个端点是&nbsp;<code>(i, 0)</code>&nbsp;和&nbsp;<code>(i, height[i])</code>&nbsp;。</p>\n\n<p>找出其中的两条线，使得它们与&nbsp;<code>x</code>&nbsp;轴共同构成的容器可以容纳最多的水。</p>\n\n<p>返回容器可以储存的最大水量。</p>\n\n<p><strong>说明：</strong>你不能倾斜容器。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>[1,8,6,2,5,4,8,3,7]\n<strong>输出：</strong>49 \n<strong>解释：</strong>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为&nbsp;49。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>height = [1,1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= height[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>i<sup>th</sup></code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p>\n\n<p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p>\n\n<p>Return <em>the maximum amount of water a container can store</em>.</p>\n\n<p><strong>Notice</strong> that you may not slant the container.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg\" style=\"width: 600px; height: 287px;\" />\n<pre>\n<strong>Input:</strong> height = [1,8,6,2,5,4,8,3,7]\n<strong>Output:</strong> 49\n<strong>Explanation:</strong> The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> height = [1,1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= height[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "12": {"__typename": "QuestionLightNode", "acRate": 0.6696316230201617, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "12", "isFavor": false, "solutionNum": 3481, "title": "Integer to Roman", "titleCn": "整数转罗马数字", "titleSlug": "integer-to-roman", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 93, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>\n\n<pre>\n<strong>字符</strong>          <strong>数值</strong>\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</pre>\n\n<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>\n\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>\n\n<ul>\n\t<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>\n\t<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>\n\t<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>\n</ul>\n\n<p>给你一个整数，将其转为罗马数字。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> num = 3\n<strong>输出:</strong> \"III\"</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> num = 4\n<strong>输出:</strong> \"IV\"</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> num = 9\n<strong>输出:</strong> \"IX\"</pre>\n\n<p><strong>示例 4:</strong></p>\n\n<pre>\n<strong>输入:</strong> num = 58\n<strong>输出:</strong> \"LVIII\"\n<strong>解释:</strong> L = 50, V = 5, III = 3.\n</pre>\n\n<p><strong>示例 5:</strong></p>\n\n<pre>\n<strong>输入:</strong> num = 1994\n<strong>输出:</strong> \"MCMXCIV\"\n<strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= num <= 3999</code></li>\n</ul>\n", "en": "<p>Roman numerals are represented by seven different symbols:&nbsp;<code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\n\n<pre>\n<strong>Symbol</strong>       <strong>Value</strong>\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</pre>\n\n<p>For example,&nbsp;<code>2</code> is written as <code>II</code>&nbsp;in Roman numeral, just two one&#39;s added together. <code>12</code> is written as&nbsp;<code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.</p>\n\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>\n\n<ul>\n\t<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9.&nbsp;</li>\n\t<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.&nbsp;</li>\n\t<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>\n</ul>\n\n<p>Given an integer, convert it to a roman numeral.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 3\n<strong>Output:</strong> &quot;III&quot;\n<strong>Explanation:</strong> 3 is represented as 3 ones.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 58\n<strong>Output:</strong> &quot;LVIII&quot;\n<strong>Explanation:</strong> L = 50, V = 5, III = 3.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 1994\n<strong>Output:</strong> &quot;MCMXCIV&quot;\n<strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 3999</code></li>\n</ul>\n"}}, "13": {"__typename": "QuestionLightNode", "acRate": 0.6275496458084759, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "13", "isFavor": false, "solutionNum": 7703, "title": "Roman to Integer", "titleCn": "罗马数字转整数", "titleSlug": "roman-to-integer", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 117, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>罗马数字包含以下七种字符:&nbsp;<code>I</code>，&nbsp;<code>V</code>，&nbsp;<code>X</code>，&nbsp;<code>L</code>，<code>C</code>，<code>D</code>&nbsp;和&nbsp;<code>M</code>。</p>\n\n<pre>\n<strong>字符</strong>          <strong>数值</strong>\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</pre>\n\n<p>例如， 罗马数字 <code>2</code> 写做&nbsp;<code>II</code>&nbsp;，即为两个并列的 1 。<code>12</code> 写做&nbsp;<code>XII</code>&nbsp;，即为&nbsp;<code>X</code>&nbsp;+&nbsp;<code>II</code>&nbsp;。 <code>27</code> 写做&nbsp;&nbsp;<code>XXVII</code>, 即为&nbsp;<code>XX</code>&nbsp;+&nbsp;<code>V</code>&nbsp;+&nbsp;<code>II</code>&nbsp;。</p>\n\n<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做&nbsp;<code>IIII</code>，而是&nbsp;<code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为&nbsp;<code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>\n\n<ul>\n\t<li><code>I</code>&nbsp;可以放在&nbsp;<code>V</code>&nbsp;(5) 和&nbsp;<code>X</code>&nbsp;(10) 的左边，来表示 4 和 9。</li>\n\t<li><code>X</code>&nbsp;可以放在&nbsp;<code>L</code>&nbsp;(50) 和&nbsp;<code>C</code>&nbsp;(100) 的左边，来表示 40 和&nbsp;90。&nbsp;</li>\n\t<li><code>C</code>&nbsp;可以放在&nbsp;<code>D</code>&nbsp;(500) 和&nbsp;<code>M</code>&nbsp;(1000) 的左边，来表示&nbsp;400 和&nbsp;900。</li>\n</ul>\n\n<p>给定一个罗马数字，将其转换成整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;s = \"III\"\n<strong>输出:</strong> 3</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;s = \"IV\"\n<strong>输出:</strong> 4</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;s = \"IX\"\n<strong>输出:</strong> 9</pre>\n\n<p><strong>示例&nbsp;4:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;s = \"LVIII\"\n<strong>输出:</strong> 58\n<strong>解释:</strong> L = 50, V= 5, III = 3.\n</pre>\n\n<p><strong>示例&nbsp;5:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;s = \"MCMXCIV\"\n<strong>输出:</strong> 1994\n<strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 15</code></li>\n\t<li><code>s</code> 仅含字符 <code>('I', 'V', 'X', 'L', 'C', 'D', 'M')</code></li>\n\t<li>题目数据保证 <code>s</code> 是一个有效的罗马数字，且表示整数在范围 <code>[1, 3999]</code> 内</li>\n\t<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>\n\t<li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>\n\t<li>关于罗马数字的详尽书写规则，可以参考 <a href=\"https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97#knowledge_article\">罗马数字 - Mathematics </a>。</li>\n</ul>\n", "en": "<p>Roman numerals are represented by seven different symbols:&nbsp;<code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code> and <code>M</code>.</p>\n\n<pre>\n<strong>Symbol</strong>       <strong>Value</strong>\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000</pre>\n\n<p>For example,&nbsp;<code>2</code> is written as <code>II</code>&nbsp;in Roman numeral, just two ones added together. <code>12</code> is written as&nbsp;<code>XII</code>, which is simply <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which is <code>XX + V + II</code>.</p>\n\n<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not <code>IIII</code>. Instead, the number four is written as <code>IV</code>. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as <code>IX</code>. There are six instances where subtraction is used:</p>\n\n<ul>\n\t<li><code>I</code> can be placed before <code>V</code> (5) and <code>X</code> (10) to make 4 and 9.&nbsp;</li>\n\t<li><code>X</code> can be placed before <code>L</code> (50) and <code>C</code> (100) to make 40 and 90.&nbsp;</li>\n\t<li><code>C</code> can be placed before <code>D</code> (500) and <code>M</code> (1000) to make 400 and 900.</li>\n</ul>\n\n<p>Given a roman numeral, convert it to an integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;III&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> III = 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;LVIII&quot;\n<strong>Output:</strong> 58\n<strong>Explanation:</strong> L = 50, V= 5, III = 3.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;MCMXCIV&quot;\n<strong>Output:</strong> 1994\n<strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 15</code></li>\n\t<li><code>s</code> contains only&nbsp;the characters <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code>.</li>\n\t<li>It is <strong>guaranteed</strong>&nbsp;that <code>s</code> is a valid roman numeral in the range <code>[1, 3999]</code>.</li>\n</ul>\n"}}, "14": {"__typename": "QuestionLightNode", "acRate": 0.4393661586866223, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "14", "isFavor": false, "solutionNum": 7665, "title": "Longest Common Prefix", "titleCn": "最长公共前缀", "titleSlug": "longest-common-prefix", "topicTags": [{"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 144, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>\n\n<p>如果不存在公共前缀，返回空字符串&nbsp;<code>\"\"</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"flower\",\"flow\",\"flight\"]\n<strong>输出：</strong>\"fl\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"dog\",\"racecar\",\"car\"]\n<strong>输出：</strong>\"\"\n<strong>解释：</strong>输入不存在公共前缀。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 200</code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>\n\t<li><code>strs[i]</code> 仅由小写英文字母组成</li>\n</ul>\n", "en": "<p>Write a function to find the longest common prefix string amongst an array of strings.</p>\n\n<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\n<strong>Output:</strong> &quot;fl&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> There is no common prefix among the input strings.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 200</code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>\n\t<li><code>strs[i]</code> consists of only lowercase English letters.</li>\n</ul>\n"}}, "15": {"__typename": "QuestionLightNode", "acRate": 0.378571016625846, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "15", "isFavor": false, "solutionNum": 7097, "title": "3Sum", "titleCn": "三数之和", "titleSlug": "3sum", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 224, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>\n\n<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>\n\n<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,0,1,2,-1,-4]\n<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]\n<strong>解释：</strong>\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,1]\n<strong>输出：</strong>[]\n<strong>解释：</strong>唯一可能的三元组和不为 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,0]\n<strong>输出：</strong>[[0,0,0]]\n<strong>解释：</strong>唯一可能的三元组和为 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 3000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>\n\n<p>Notice that the solution set must not contain duplicate triplets.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0,1,2,-1,-4]\n<strong>Output:</strong> [[-1,-1,2],[-1,0,1]]\n<strong>Explanation:</strong> \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,1]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> The only possible triplet does not sum up to 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,0]\n<strong>Output:</strong> [[0,0,0]]\n<strong>Explanation:</strong> The only possible triplet sums up to 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 3000</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "16": {"__typename": "QuestionLightNode", "acRate": 0.4478155369204743, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "16", "isFavor": false, "solutionNum": 2844, "title": "3Sum Closest", "titleCn": "最接近的三数之和", "titleSlug": "3sum-closest", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 88, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个长度为 <code>n</code> 的整数数组&nbsp;<code>nums</code><em>&nbsp;</em>和 一个目标值&nbsp;<code>target</code>。请你从 <code>nums</code><em> </em>中选出三个整数，使它们的和与&nbsp;<code>target</code>&nbsp;最接近。</p>\n\n<p>返回这三个数的和。</p>\n\n<p>假定每组输入只存在恰好一个解。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,2,1,-4], target = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,0], target = 1\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>.</p>\n\n<p>Return <em>the sum of the three integers</em>.</p>\n\n<p>You may assume that each input would have exactly one solution.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,2,1,-4], target = 1\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,0], target = 1\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "17": {"__typename": "QuestionLightNode", "acRate": 0.5944371356164573, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "17", "isFavor": false, "solutionNum": 6288, "title": "Letter Combinations of a Phone Number", "titleCn": "电话号码的字母组合", "titleSlug": "letter-combinations-of-a-phone-number", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 115, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个仅包含数字&nbsp;<code>2-9</code>&nbsp;的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>\n\n<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png\" style=\"width: 200px;\" /></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = \"23\"\n<strong>输出：</strong>[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = \"\"\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = \"2\"\n<strong>输出：</strong>[\"a\",\"b\",\"c\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= digits.length &lt;= 4</code></li>\n\t<li><code>digits[i]</code> 是范围 <code>['2', '9']</code> 的一个数字。</li>\n</ul>\n", "en": "<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p>\n\n<p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png\" style=\"width: 300px; height: 243px;\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = &quot;23&quot;\n<strong>Output:</strong> [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = &quot;&quot;\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = &quot;2&quot;\n<strong>Output:</strong> [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= digits.length &lt;= 4</code></li>\n\t<li><code>digits[i]</code> is a digit in the range <code>[&#39;2&#39;, &#39;9&#39;]</code>.</li>\n</ul>\n"}}, "18": {"__typename": "QuestionLightNode", "acRate": 0.36608467898520464, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "18", "isFavor": false, "solutionNum": 3351, "title": "4Sum", "titleCn": "四数之和", "titleSlug": "4sum", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 74, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个由 <code>n</code> 个整数组成的数组&nbsp;<code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组&nbsp;<code>[nums[a], nums[b], nums[c], nums[d]]</code>&nbsp;（若两个四元组元素一一对应，则认为两个四元组重复）：</p>\n\n<ul>\n\t<li><code>0 &lt;= a, b, c, d&nbsp;&lt; n</code></li>\n\t<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>\n\t<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>\n</ul>\n\n<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,0,-1,0,-2,2], target = 0\n<strong>输出：</strong>[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2,2,2], target = 8\n<strong>输出：</strong>[[2,2,2,2]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= a, b, c, d&nbsp;&lt; n</code></li>\n\t<li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li>\n\t<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>\n</ul>\n\n<p>You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,-1,0,-2,2], target = 0\n<strong>Output:</strong> [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,2,2,2], target = 8\n<strong>Output:</strong> [[2,2,2,2]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "19": {"__typename": "QuestionLightNode", "acRate": 0.4782560125556537, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "19", "isFavor": false, "solutionNum": 9061, "title": "Remove Nth Node From End of List", "titleCn": "删除链表的倒数第 N 个结点", "titleSlug": "remove-nth-node-from-end-of-list", "topicTags": [{"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 133, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个链表，删除链表的倒数第&nbsp;<code>n</code><em>&nbsp;</em>个结点，并且返回链表的头结点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], n = 2\n<strong>输出：</strong>[1,2,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1], n = 1\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], n = 1\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中结点的数目为 <code>sz</code></li>\n\t<li><code>1 &lt;= sz &lt;= 30</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>\n", "en": "<p>Given the <code>head</code> of a linked list, remove the <code>n<sup>th</sup></code> node from the end of the list and return its head.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], n = 2\n<strong>Output:</strong> [1,2,3,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1], n = 1\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,2], n = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is <code>sz</code>.</li>\n\t<li><code>1 &lt;= sz &lt;= 30</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you do this in one pass?</p>\n"}}, "20": {"__typename": "QuestionLightNode", "acRate": 0.43930839036925357, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "20", "isFavor": false, "solutionNum": 10928, "title": "Valid Parentheses", "titleCn": "有效的括号", "titleSlug": "valid-parentheses", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 257, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code>&nbsp;的字符串 <code>s</code> ，判断字符串是否有效。</p>\n\n<p>有效字符串需满足：</p>\n\n<ol>\n\t<li>左括号必须用相同类型的右括号闭合。</li>\n\t<li>左括号必须以正确的顺序闭合。</li>\n\t<li>每个右括号都有一个对应的相同类型的左括号。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"()\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"()[]{}\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(]\"\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 仅由括号 <code>'()[]{}'</code> 组成</li>\n</ul>\n", "en": "<p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>\n\n<p>An input string is valid if:</p>\n\n<ol>\n\t<li>Open brackets must be closed by the same type of brackets.</li>\n\t<li>Open brackets must be closed in the correct order.</li>\n\t<li>Every close bracket has a corresponding open bracket of the same type.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;()&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;()[]{}&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(]&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of parentheses only <code>&#39;()[]{}&#39;</code>.</li>\n</ul>\n"}}, "21": {"__typename": "QuestionLightNode", "acRate": 0.6644506203041401, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "21", "isFavor": false, "solutionNum": 8206, "title": "Merge Two Sorted Lists", "titleCn": "合并两个有序链表", "titleSlug": "merge-two-sorted-lists", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 219, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg\" style=\"width: 662px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>l1 = [1,2,4], l2 = [1,3,4]\n<strong>输出：</strong>[1,1,2,3,4,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [], l2 = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [], l2 = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>\n\t<li><code>-100 <= Node.val <= 100</code></li>\n\t<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>\n</ul>\n", "en": "<p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p>\n\n<p>Merge the two lists into one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p>\n\n<p>Return <em>the head of the merged linked list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg\" style=\"width: 662px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> list1 = [1,2,4], list2 = [1,3,4]\n<strong>Output:</strong> [1,1,2,3,4,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> list1 = [], list2 = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> list1 = [], list2 = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li>Both <code>list1</code> and <code>list2</code> are sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n"}}, "22": {"__typename": "QuestionLightNode", "acRate": 0.7766238445680742, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "22", "isFavor": false, "solutionNum": 5304, "title": "Generate Parentheses", "titleCn": "括号生成", "titleSlug": "generate-parentheses", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 139, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>数字 <code>n</code>&nbsp;代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的 </strong>括号组合。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>[\"()\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n", "en": "<p>Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 3\n<strong>Output:</strong> [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 1\n<strong>Output:</strong> [\"()\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n"}}, "23": {"__typename": "QuestionLightNode", "acRate": 0.593878048323305, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "23", "isFavor": false, "solutionNum": 4896, "title": "Merge k Sorted Lists", "titleCn": "合并 K 个升序链表", "titleSlug": "merge-k-sorted-lists", "topicTags": [{"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}, {"id": "xp2r1vv", "name": "Merge Sort", "slug": "merge-sort", "nameTranslated": "归并排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 161, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个链表数组，每个链表都已经按升序排列。</p>\n\n<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>lists = [[1,4,5],[1,3,4],[2,6]]\n<strong>输出：</strong>[1,1,2,3,4,4,5,6]\n<strong>解释：</strong>链表数组如下：\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\n将它们合并到一个有序链表中得到。\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>lists = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>lists = [[]]\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>k == lists.length</code></li>\n\t<li><code>0 &lt;= k &lt;= 10^4</code></li>\n\t<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n\t<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>\n\t<li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li>\n\t<li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li>\n</ul>\n", "en": "<p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p>\n\n<p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = [[1,4,5],[1,3,4],[2,6]]\n<strong>Output:</strong> [1,1,2,3,4,4,5,6]\n<strong>Explanation:</strong> The linked-lists are:\n[\n  1-&gt;4-&gt;5,\n  1-&gt;3-&gt;4,\n  2-&gt;6\n]\nmerging them into one sorted list:\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> lists = [[]]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>k == lists.length</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= lists[i][j] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>lists[i]</code> is sorted in <strong>ascending order</strong>.</li>\n\t<li>The sum of <code>lists[i].length</code> will not exceed <code>10<sup>4</sup></code>.</li>\n</ul>\n"}}, "24": {"__typename": "QuestionLightNode", "acRate": 0.7214421786680201, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "24", "isFavor": false, "solutionNum": 5436, "title": "Swap Nodes in Pairs", "titleCn": "两两交换链表中的节点", "titleSlug": "swap-nodes-in-pairs", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 89, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg\" style=\"width: 422px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4]\n<strong>输出：</strong>[2,1,4,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n", "en": "<p>Given a&nbsp;linked list, swap every two adjacent nodes and return its head. You must solve the problem without&nbsp;modifying the values in the list&#39;s nodes (i.e., only nodes themselves may be changed.)</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg\" style=\"width: 422px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4]\n<strong>Output:</strong> [2,1,4,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the&nbsp;list&nbsp;is in the range <code>[0, 100]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n"}}, "25": {"__typename": "QuestionLightNode", "acRate": 0.6786975093584374, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "25", "isFavor": false, "solutionNum": 4591, "title": "Reverse Nodes in k-Group", "titleCn": "K 个一组翻转链表", "titleSlug": "reverse-nodes-in-k-group", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 99, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你链表的头节点 <code>head</code> ，每&nbsp;<code>k</code><em>&nbsp;</em>个节点一组进行翻转，请你返回修改后的链表。</p>\n\n<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是&nbsp;<code>k</code><em>&nbsp;</em>的整数倍，那么请将最后剩余的节点保持原有顺序。</p>\n\n<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 2\n<strong>输出：</strong>[2,1,4,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg\" style=\"width: 542px; height: 222px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 3\n<strong>输出：</strong>[3,2,1,4,5]\n</pre>\n\n<p>&nbsp;</p>\n<strong>提示：</strong>\n\n<ul>\n\t<li>链表中的节点数目为 <code>n</code></li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计一个只用 <code>O(1)</code> 额外内存空间的算法解决此问题吗？</p>\n\n<ul>\n</ul>\n", "en": "<p>Given the <code>head</code> of a linked list, reverse the nodes of the list <code>k</code> at a time, and return <em>the modified list</em>.</p>\n\n<p><code>k</code> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <code>k</code> then left-out nodes, in the end, should remain as it is.</p>\n\n<p>You may not alter the values in the list&#39;s nodes, only nodes themselves may be changed.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], k = 2\n<strong>Output:</strong> [2,1,4,3,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], k = 3\n<strong>Output:</strong> [3,2,1,4,5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is <code>n</code>.</li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you solve the problem in <code>O(1)</code> extra memory space?</p>\n"}}, "26": {"__typename": "QuestionLightNode", "acRate": 0.5618965449048315, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "26", "isFavor": false, "solutionNum": 10102, "title": "Remove Duplicates from Sorted Array", "titleCn": "删除有序数组中的重复项", "titleSlug": "remove-duplicates-from-sorted-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 117, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你<strong><a href=\"http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"> 原地</a></strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p>\n\n<p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p>\n\n<ul>\n\t<li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code>&nbsp;的其余元素与 <code>nums</code> 的大小不重要。</li>\n\t<li>返回 <code>k</code>&nbsp;。</li>\n</ul>\n\n<p><strong>判题标准:</strong></p>\n\n<p>系统会用下面的代码来测试你的题解:</p>\n\n<pre>\nint[] nums = [...]; // 输入数组\nint[] expectedNums = [...]; // 长度正确的期望答案\n\nint k = removeDuplicates(nums); // 调用\n\nassert k == expectedNums.length;\nfor (int i = 0; i &lt; k; i++) {\n    assert nums[i] == expectedNums[i];\n}</pre>\n\n<p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2]\n<strong>输出：</strong>2, nums = [1,2,_]\n<strong>解释：</strong>函数应该返回新的长度 <strong><code>2</code></strong> ，并且原数组 <em>nums </em>的前两个元素被修改为 <strong><code>1</code></strong>, <strong><code>2 </code></strong><code>。</code>不需要考虑数组中超出新长度后面的元素。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,1,1,1,2,2,3,3,4]\n<strong>输出：</strong>5, nums = [0,1,2,3,4]\n<strong>解释：</strong>函数应该返回新的长度 <strong><code>5</code></strong> ， 并且原数组 <em>nums </em>的前五个元素被修改为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>2</code></strong>, <strong><code>3</code></strong>, <strong><code>4</code></strong> 。不需要考虑数组中超出新长度后面的元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 已按 <strong>非严格递增</strong>&nbsp;排列</li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a> such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>. Then return <em>the number of unique elements in </em><code>nums</code>.</p>\n\n<p>Consider the number of unique elements of <code>nums</code> to be <code>k</code>, to get accepted, you need to do the following things:</p>\n\n<ul>\n\t<li>Change the array <code>nums</code> such that the first <code>k</code> elements of <code>nums</code> contain the unique elements in the order they were present in <code>nums</code> initially. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.</li>\n\t<li>Return <code>k</code>.</li>\n</ul>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The judge will test your solution with the following code:</p>\n\n<pre>\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i &lt; k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n</pre>\n\n<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,2]\n<strong>Output:</strong> 2, nums = [1,2,_]\n<strong>Explanation:</strong> Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,1,1,1,2,2,3,3,4]\n<strong>Output:</strong> 5, nums = [0,1,2,3,4,_,_,_,_,_]\n<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n"}}, "27": {"__typename": "QuestionLightNode", "acRate": 0.5946988362113799, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "27", "isFavor": false, "solutionNum": 9958, "title": "Remove Element", "titleCn": "移除元素", "titleSlug": "remove-element", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 61, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个数组 <code>nums</code><em>&nbsp;</em>和一个值 <code>val</code>，你需要 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地</a></strong> 移除所有数值等于&nbsp;<code>val</code><em>&nbsp;</em>的元素，并返回移除后数组的新长度。</p>\n\n<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地 </a>修改输入数组</strong>。</p>\n\n<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>说明:</strong></p>\n\n<p>为什么返回数值是整数，但输出的答案是数组呢?</p>\n\n<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>\n\n<p>你可以想象内部操作如下:</p>\n\n<pre>\n// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中<strong> 该长度范围内</strong> 的所有元素。\nfor (int i = 0; i &lt; len; i++) {\n&nbsp; &nbsp; print(nums[i]);\n}\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,2,3], val = 3\n<strong>输出：</strong>2, nums = [2,2]\n<strong>解释：</strong>函数应该返回新的长度 <strong><code>2</code></strong>, 并且 nums<em> </em>中的前两个元素均为 <strong>2</strong>。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,2,2,3,0,4,2], val = 2\n<strong>输出：</strong>5, nums = [0,1,3,0,4]\n<strong>解释：</strong>函数应该返回新的长度 <strong><code>5</code></strong>, 并且 nums 中的前五个元素为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>3</code></strong>, <strong><code>0</code></strong>, <strong><code>4</code></strong>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 50</code></li>\n\t<li><code>0 &lt;= val &lt;= 100</code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> and an integer <code>val</code>, remove all occurrences of <code>val</code> in <code>nums</code> <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a>. The order of the elements may be changed. Then return <em>the number of elements in </em><code>nums</code><em> which are not equal to </em><code>val</code>.</p>\n\n<p>Consider the number of elements in <code>nums</code> which are not equal to <code>val</code> be <code>k</code>, to get accepted, you need to do the following things:</p>\n\n<ul>\n\t<li>Change the array <code>nums</code> such that the first <code>k</code> elements of <code>nums</code> contain the elements which are not equal to <code>val</code>. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.</li>\n\t<li>Return <code>k</code>.</li>\n</ul>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The judge will test your solution with the following code:</p>\n\n<pre>\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i &lt; actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n</pre>\n\n<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,2,3], val = 3\n<strong>Output:</strong> 2, nums = [2,2,_,_]\n<strong>Explanation:</strong> Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,2,2,3,0,4,2], val = 2\n<strong>Output:</strong> 5, nums = [0,1,4,0,3,_,_,_]\n<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 50</code></li>\n\t<li><code>0 &lt;= val &lt;= 100</code></li>\n</ul>\n"}}, "28": {"__typename": "QuestionLightNode", "acRate": 0.4357360215691758, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "28", "isFavor": false, "solutionNum": 7092, "title": "Find the Index of the First Occurrence in a String", "titleCn": "找出字符串中第一个匹配项的下标", "titleSlug": "find-the-index-of-the-first-occurrence-in-a-string", "topicTags": [{"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "ydzvgh", "name": "String Matching", "slug": "string-matching", "nameTranslated": "字符串匹配", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 106, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个字符串&nbsp;<code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果&nbsp;<code>needle</code> 不是 <code>haystack</code> 的一部分，则返回&nbsp; <code>-1</code><strong> </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>haystack = \"sadbutsad\", needle = \"sad\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\"sad\" 在下标 0 和 6 处匹配。\n第一个匹配项的下标是 0 ，所以返回 0 。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>haystack = \"leetcode\", needle = \"leeto\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>\"leeto\" 没有在 \"leetcode\" 中出现，所以返回 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= haystack.length, needle.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li>\n</ul>\n", "en": "<p>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> &quot;sad&quot; occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> &quot;leeto&quot; did not occur in &quot;leetcode&quot;, so we return -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= haystack.length, needle.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>haystack</code> and <code>needle</code> consist of only lowercase English characters.</li>\n</ul>\n"}}, "29": {"__typename": "QuestionLightNode", "acRate": 0.22292253351027402, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "29", "isFavor": false, "solutionNum": 1735, "title": "Divide Two Integers", "titleCn": "两数相除", "titleSlug": "divide-two-integers", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 64, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个整数，被除数&nbsp;<code>dividend</code>&nbsp;和除数&nbsp;<code>divisor</code>。将两数相除，要求 <strong>不使用</strong> 乘法、除法和取余运算。</p>\n\n<p>整数除法应该向零截断，也就是截去（<code>truncate</code>）其小数部分。例如，<code>8.345</code> 将被截断为 <code>8</code> ，<code>-2.7335</code> 将被截断至 <code>-2</code> 。</p>\n\n<p>返回被除数&nbsp;<code>dividend</code>&nbsp;除以除数&nbsp;<code>divisor</code>&nbsp;得到的 <strong>商</strong> 。</p>\n\n<p><strong>注意：</strong>假设我们的环境只能存储 <strong>32 位</strong> 有符号整数，其数值范围是 <code>[−2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>− 1]</code> 。本题中，如果商 <strong>严格大于</strong> <code>2<sup>31&nbsp;</sup>− 1</code> ，则返回 <code>2<sup>31&nbsp;</sup>− 1</code> ；如果商 <strong>严格小于</strong> <code>-2<sup>31</sup></code> ，则返回 <code>-2<sup>31</sup></code><sup> </sup>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> dividend = 10, divisor = 3\n<strong>输出:</strong> 3\n<strong>解释: </strong>10/3 = 3.33333.. ，向零截断后得到 3 。</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> dividend = 7, divisor = -3\n<strong>输出:</strong> -2\n<strong>解释:</strong> 7/-3 = -2.33333.. ，向零截断后得到 -2 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= dividend, divisor &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>divisor != 0</code></li>\n</ul>\n", "en": "<p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers <strong>without</strong> using multiplication, division, and mod operator.</p>\n\n<p>The integer division should truncate toward zero, which means losing its fractional part. For example, <code>8.345</code> would be truncated to <code>8</code>, and <code>-2.7335</code> would be truncated to <code>-2</code>.</p>\n\n<p>Return <em>the <strong>quotient</strong> after dividing </em><code>dividend</code><em> by </em><code>divisor</code>.</p>\n\n<p><strong>Note: </strong>Assume we are dealing with an environment that could only store integers within the <strong>32-bit</strong> signed integer range: <code>[&minus;2<sup>31</sup>, 2<sup>31</sup> &minus; 1]</code>. For this problem, if the quotient is <strong>strictly greater than</strong> <code>2<sup>31</sup> - 1</code>, then return <code>2<sup>31</sup> - 1</code>, and if the quotient is <strong>strictly less than</strong> <code>-2<sup>31</sup></code>, then return <code>-2<sup>31</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> dividend = 10, divisor = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 10/3 = 3.33333.. which is truncated to 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> dividend = 7, divisor = -3\n<strong>Output:</strong> -2\n<strong>Explanation:</strong> 7/-3 = -2.33333.. which is truncated to -2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= dividend, divisor &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>divisor != 0</code></li>\n</ul>\n"}}, "30": {"__typename": "QuestionLightNode", "acRate": 0.39008888371370903, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "30", "isFavor": false, "solutionNum": 1513, "title": "Substring with Concatenation of All Words", "titleCn": "串联所有单词的子串", "titleSlug": "substring-with-concatenation-of-all-words", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 36, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个字符串&nbsp;<code>s</code><strong>&nbsp;</strong>和一个字符串数组&nbsp;<code>words</code><strong>。</strong>&nbsp;<code>words</code>&nbsp;中所有字符串 <strong>长度相同</strong>。</p>\n\n<p>&nbsp;<code>s</code><strong>&nbsp;</strong>中的 <strong>串联子串</strong> 是指一个包含&nbsp;&nbsp;<code>words</code>&nbsp;中所有字符串以任意顺序排列连接起来的子串。</p>\n\n<ul>\n\t<li>例如，如果&nbsp;<code>words = [\"ab\",\"cd\",\"ef\"]</code>， 那么&nbsp;<code>\"abcdef\"</code>，&nbsp;<code>\"abefcd\"</code>，<code>\"cdabef\"</code>，&nbsp;<code>\"cdefab\"</code>，<code>\"efabcd\"</code>， 和&nbsp;<code>\"efcdab\"</code> 都是串联子串。&nbsp;<code>\"acdbef\"</code> 不是串联子串，因为他不是任何&nbsp;<code>words</code>&nbsp;排列的连接。</li>\n</ul>\n\n<p>返回所有串联子串在&nbsp;<code>s</code><strong>&nbsp;</strong>中的开始索引。你可以以 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n<strong>输出：</strong><code>[0,9]</code>\n<strong>解释：</strong>因为 words.length == 2 同时 words[i].length == 3，连接的子字符串的长度必须为 6。\n子串 \"barfoo\" 开始位置是 0。它是 words 中以 [\"bar\",\"foo\"] 顺序排列的连接。\n子串 \"foobar\" 开始位置是 9。它是 words 中以 [\"foo\",\"bar\"] 顺序排列的连接。\n输出顺序无关紧要。返回 [9,0] 也是可以的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n<code><strong>输出：</strong>[]</code>\n<strong>解释：</strong>因为<strong> </strong>words.length == 4 并且 words[i].length == 4，所以串联子串的长度必须为 16。\ns 中没有子串长度为 16 并且等于 words 的任何顺序排列的连接。\n所以我们返回一个空数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n<strong>输出：</strong>[6,9,12]\n<strong>解释：</strong>因为 words.length == 3 并且 words[i].length == 3，所以串联子串的长度必须为 9。\n子串 \"foobarthe\" 开始位置是 6。它是 words 中以 [\"foo\",\"bar\",\"the\"] 顺序排列的连接。\n子串 \"barthefoo\" 开始位置是 9。它是 words 中以 [\"bar\",\"the\",\"foo\"] 顺序排列的连接。\n子串 \"thefoobar\" 开始位置是 12。它是 words 中以 [\"the\",\"foo\",\"bar\"] 顺序排列的连接。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code>&nbsp;和&nbsp;<code>s</code> 由小写英文字母组成</li>\n</ul>\n", "en": "<p>You are given a string <code>s</code> and an array of strings <code>words</code>. All the strings of <code>words</code> are of <strong>the same length</strong>.</p>\n\n<p>A <strong>concatenated substring</strong> in <code>s</code> is a substring that contains all the strings of any permutation of <code>words</code> concatenated.</p>\n\n<ul>\n\t<li>For example, if <code>words = [&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>, then <code>&quot;abcdef&quot;</code>, <code>&quot;abefcd&quot;</code>, <code>&quot;cdabef&quot;</code>, <code>&quot;cdefab&quot;</code>, <code>&quot;efabcd&quot;</code>, and <code>&quot;efcdab&quot;</code> are all concatenated strings. <code>&quot;acdbef&quot;</code> is not a concatenated substring because it is not the concatenation of any permutation of <code>words</code>.</li>\n</ul>\n\n<p>Return <em>the starting indices of all the concatenated substrings in </em><code>s</code>. You can return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]\n<strong>Output:</strong> [0,9]\n<strong>Explanation:</strong> Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is &quot;barfoo&quot;. It is the concatenation of [&quot;bar&quot;,&quot;foo&quot;] which is a permutation of words.\nThe substring starting at 9 is &quot;foobar&quot;. It is the concatenation of [&quot;foo&quot;,&quot;bar&quot;] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 in s that is equal to the concatenation of any permutation of words.\nWe return an empty array.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;barfoofoobarthefoobarman&quot;, words = [&quot;bar&quot;,&quot;foo&quot;,&quot;the&quot;]\n<strong>Output:</strong> [6,9,12]\n<strong>Explanation:</strong> Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is &quot;foobarthe&quot;. It is the concatenation of [&quot;foo&quot;,&quot;bar&quot;,&quot;the&quot;] which is a permutation of words.\nThe substring starting at 9 is &quot;barthefoo&quot;. It is the concatenation of [&quot;bar&quot;,&quot;the&quot;,&quot;foo&quot;] which is a permutation of words.\nThe substring starting at 12 is &quot;thefoobar&quot;. It is the concatenation of [&quot;the&quot;,&quot;foo&quot;,&quot;bar&quot;] which is a permutation of words.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>s</code> and <code>words[i]</code> consist of lowercase English letters.</li>\n</ul>\n"}}, "31": {"__typename": "QuestionLightNode", "acRate": 0.39161577861420915, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "31", "isFavor": false, "solutionNum": 3559, "title": "Next Permutation", "titleCn": "下一个排列", "titleSlug": "next-permutation", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 102, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>整数数组的一个 <strong>排列</strong>&nbsp; 就是将其所有成员以序列或线性顺序排列。</p>\n\n<ul>\n\t<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>\n</ul>\n\n<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>\n\n<ul>\n\t<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>\n\t<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>\n\t<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>\n</ul>\n\n<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>\n\n<p>必须<strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"> 原地 </a></strong>修改，只允许使用额外常数空间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[1,3,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1]\n<strong>输出：</strong>[1,2,3]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,5]\n<strong>输出：</strong>[1,5,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n", "en": "<p>A <strong>permutation</strong> of an array of integers is an arrangement of its members into a sequence or linear order.</p>\n\n<ul>\n\t<li>For example, for <code>arr = [1,2,3]</code>, the following are all the permutations of <code>arr</code>: <code>[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]</code>.</li>\n</ul>\n\n<p>The <strong>next permutation</strong> of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the <strong>next permutation</strong> of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).</p>\n\n<ul>\n\t<li>For example, the next permutation of <code>arr = [1,2,3]</code> is <code>[1,3,2]</code>.</li>\n\t<li>Similarly, the next permutation of <code>arr = [2,3,1]</code> is <code>[3,1,2]</code>.</li>\n\t<li>While the next permutation of <code>arr = [3,2,1]</code> is <code>[1,2,3]</code> because <code>[3,2,1]</code> does not have a lexicographical larger rearrangement.</li>\n</ul>\n\n<p>Given an array of integers <code>nums</code>, <em>find the next permutation of</em> <code>nums</code>.</p>\n\n<p>The replacement must be <strong><a href=\"http://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in place</a></strong> and use only constant extra memory.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [1,3,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,1]\n<strong>Output:</strong> [1,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,5]\n<strong>Output:</strong> [1,5,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n"}}, "32": {"__typename": "QuestionLightNode", "acRate": 0.37857266250860533, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "32", "isFavor": false, "solutionNum": 2579, "title": "Longest Valid Parentheses", "titleCn": "最长有效括号", "titleSlug": "longest-valid-parentheses", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 103, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个只包含 <code>'('</code>&nbsp;和 <code>')'</code>&nbsp;的字符串，找出最长有效（格式正确且连续）括号<span data-keyword=\"substring\">子串</span>的长度。</p>\n\n<p>&nbsp;</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(()\"\n<strong>输出：</strong>2\n<strong>解释：</strong>最长有效括号子串是 \"()\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \")()())\"\n<strong>输出：</strong>4\n<strong>解释：</strong>最长有效括号子串是 \"()()\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"\"\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>'('</code> 或 <code>')'</code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, return <em>the length of the longest valid (well-formed) parentheses </em><span data-keyword=\"substring-nonempty\"><em>substring</em></span>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(()&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The longest valid parentheses substring is &quot;()&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;)()())&quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest valid parentheses substring is &quot;()()&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;&quot;\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>s[i]</code> is <code>&#39;(&#39;</code>, or <code>&#39;)&#39;</code>.</li>\n</ul>\n"}}, "33": {"__typename": "QuestionLightNode", "acRate": 0.4421439700334143, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "33", "isFavor": false, "solutionNum": 5203, "title": "Search in Rotated Sorted Array", "titleCn": "搜索旋转排序数组", "titleSlug": "search-in-rotated-sorted-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 154, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>\n\n<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为&nbsp;<code>[4,5,6,7,0,1,2]</code> 。</p>\n\n<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回&nbsp;<code>-1</code>&nbsp;。</p>\n\n<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>4,5,6,7,0,1,2]</code>, target = 0\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>4,5,6,7,0,1,2]</code>, target = 3\n<strong>输出：</strong>-1</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], target = 0\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li>\n\t<li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p>\n\n<p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p>\n\n<p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of </em><code>target</code><em> if it is in </em><code>nums</code><em>, or </em><code>-1</code><em> if it is not in </em><code>nums</code>.</p>\n\n<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 0\n<strong>Output:</strong> 4\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 3\n<strong>Output:</strong> -1\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1], target = 0\n<strong>Output:</strong> -1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>All values of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is an ascending array that is possibly rotated.</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "34": {"__typename": "QuestionLightNode", "acRate": 0.43309547626588446, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "34", "isFavor": false, "solutionNum": 8452, "title": "Find First and Last Position of Element in Sorted Array", "titleCn": "在排序数组中查找元素的第一个和最后一个位置", "titleSlug": "find-first-and-last-position-of-element-in-sorted-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 101, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>\n\n<p>如果数组中不存在目标值 <code>target</code>，返回&nbsp;<code>[-1, -1]</code>。</p>\n\n<p>你必须设计并实现时间复杂度为&nbsp;<code>O(log n)</code>&nbsp;的算法解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>5,7,7,8,8,10]</code>, target = 8\n<strong>输出：</strong>[3,4]</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<code>5,7,7,8,8,10]</code>, target = 6\n<strong>输出：</strong>[-1,-1]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [], target = 0\n<strong>输出：</strong>[-1,-1]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums</code>&nbsp;是一个非递减数组</li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= target&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.</p>\n\n<p>If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.</p>\n\n<p>You must&nbsp;write an algorithm with&nbsp;<code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 8\n<strong>Output:</strong> [3,4]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 6\n<strong>Output:</strong> [-1,-1]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [], target = 0\n<strong>Output:</strong> [-1,-1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i]&nbsp;&lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums</code> is a non-decreasing array.</li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= target&nbsp;&lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "35": {"__typename": "QuestionLightNode", "acRate": 0.4613730832212869, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "35", "isFavor": false, "solutionNum": 8575, "title": "Search Insert Position", "titleCn": "搜索插入位置", "titleSlug": "search-insert-position", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 71, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n\n<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 5\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 2\n<strong>输出:</strong> 1\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,3,5,6], target = 7\n<strong>输出:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 为&nbsp;<strong>无重复元素&nbsp;</strong>的&nbsp;<strong>升序&nbsp;</strong>排列数组</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>\n\n<p>You must&nbsp;write an algorithm with&nbsp;<code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,6], target = 5\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,6], target = 2\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,6], target = 7\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> contains <strong>distinct</strong> values sorted in <strong>ascending</strong> order.</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "36": {"__typename": "QuestionLightNode", "acRate": 0.6334497510673254, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "36", "isFavor": false, "solutionNum": 2941, "title": "Valid Sudoku", "titleCn": "有效的数独", "titleSlug": "valid-sudoku", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 91, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>请你判断一个&nbsp;<code>9 x 9</code> 的数独是否有效。只需要<strong> 根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p>\n\n<ol>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一行只能出现一次。</li>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一列只能出现一次。</li>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一个以粗实线分隔的&nbsp;<code>3x3</code>&nbsp;宫内只能出现一次。（请参考示例图）</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>一个有效的数独（部分已被填充）不一定是可解的。</li>\n\t<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>\n\t<li>空白格用&nbsp;<code>'.'</code>&nbsp;表示。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png\" style=\"height:250px; width:250px\" />\n<pre>\n<strong>输入：</strong>board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n<strong>输出：</strong>false\n<strong>解释：</strong>除了第一行的第一个数字从<strong> 5</strong> 改为 <strong>8 </strong>以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board.length == 9</code></li>\n\t<li><code>board[i].length == 9</code></li>\n\t<li><code>board[i][j]</code> 是一位数字（<code>1-9</code>）或者 <code>'.'</code></li>\n</ul>\n", "en": "<p>Determine if a&nbsp;<code>9 x 9</code> Sudoku board&nbsp;is valid.&nbsp;Only the filled cells need to be validated&nbsp;<strong>according to the following rules</strong>:</p>\n\n<ol>\n\t<li>Each row&nbsp;must contain the&nbsp;digits&nbsp;<code>1-9</code> without repetition.</li>\n\t<li>Each column must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li>\n\t<li>Each of the nine&nbsp;<code>3 x 3</code> sub-boxes of the grid must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li>\n</ol>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>\n\t<li>Only the filled cells need to be validated according to the mentioned&nbsp;rules.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\" style=\"height:250px; width:250px\" />\n<pre>\n<strong>Input:</strong> board = \n[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]\n,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]\n,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]\n,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]\n,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> board = \n[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]\n,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]\n,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]\n,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]\n,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Same as Example 1, except with the <strong>5</strong> in the top left corner being modified to <strong>8</strong>. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>board.length == 9</code></li>\n\t<li><code>board[i].length == 9</code></li>\n\t<li><code>board[i][j]</code> is a digit <code>1-9</code> or <code>&#39;.&#39;</code>.</li>\n</ul>\n"}}, "37": {"__typename": "QuestionLightNode", "acRate": 0.6772979130065447, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "37", "isFavor": false, "solutionNum": 1784, "title": "Sudoku Solver", "titleCn": "解数独", "titleSlug": "sudoku-solver", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 62, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>编写一个程序，通过填充空格来解决数独问题。</p>\n\n<p>数独的解法需<strong> 遵循如下规则</strong>：</p>\n\n<ol>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一行只能出现一次。</li>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一列只能出现一次。</li>\n\t<li>数字&nbsp;<code>1-9</code>&nbsp;在每一个以粗实线分隔的&nbsp;<code>3x3</code>&nbsp;宫内只能出现一次。（请参考示例图）</li>\n</ol>\n\n<p>数独部分空格内已填入了数字，空白格用&nbsp;<code>'.'</code>&nbsp;表示。</p>\n\n<p>&nbsp;</p>\n\n<div class=\"top-view__1vxA\">\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png\" style=\"height:250px; width:250px\" />\n<pre>\n<strong>输入：</strong>board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n<strong>输出：</strong>[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n<strong>解释：</strong>输入的数独如上图所示，唯一有效的解决方案如下所示：\n\n<img src=\" https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714_solutionsvg.png\" style=\"height:250px; width:250px\" />\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>board.length == 9</code></li>\n\t<li><code>board[i].length == 9</code></li>\n\t<li><code>board[i][j]</code> 是一位数字或者 <code>'.'</code></li>\n\t<li>题目数据 <strong>保证</strong> 输入数独仅有一个解</li>\n</ul>\n</div>\n</div>\n</div>\n", "en": "<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>\n\n<p>A sudoku solution must satisfy <strong>all of the following rules</strong>:</p>\n\n<ol>\n\t<li>Each of the digits <code>1-9</code> must occur exactly once in each row.</li>\n\t<li>Each of the digits <code>1-9</code> must occur exactly once in each column.</li>\n\t<li>Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.</li>\n</ol>\n\n<p>The <code>&#39;.&#39;</code> character indicates empty cells.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png\" style=\"height:250px; width:250px\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]\n<strong>Output:</strong> [[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]\n<strong>Explanation:</strong>&nbsp;The input board is shown above and the only valid solution is shown below:\n\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png\" style=\"height:250px; width:250px\" />\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>board.length == 9</code></li>\n\t<li><code>board[i].length == 9</code></li>\n\t<li><code>board[i][j]</code> is a digit or <code>&#39;.&#39;</code>.</li>\n\t<li>It is <strong>guaranteed</strong> that the input board has only one solution.</li>\n</ul>\n"}}, "38": {"__typename": "QuestionLightNode", "acRate": 0.607574515220714, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "38", "isFavor": false, "solutionNum": 3451, "title": "Count and Say", "titleCn": "外观数列", "titleSlug": "count-and-say", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 65, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个正整数 <code>n</code> ，输出外观数列的第 <code>n</code> 项。</p>\n\n<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p>\n\n<p>你可以将其视作是由递归公式定义的数字字符串序列：</p>\n\n<ul>\n\t<li><code>countAndSay(1) = \"1\"</code></li>\n\t<li><code>countAndSay(n)</code> 是对 <code>countAndSay(n-1)</code> 的描述，然后转换成另一个数字字符串。</li>\n</ul>\n\n<p>前五项如下：</p>\n\n<pre>\n1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n第一项是数字 1 \n描述前一项，这个数是 <code>1</code> 即 “ 一 个 1 ”，记作 <code>\"11\"\n</code>描述前一项，这个数是 <code>11</code> 即 “ 二 个 1 ” ，记作 <code>\"21\"\n</code>描述前一项，这个数是 <code>21</code> 即 “ 一 个 2 + 一 个 1 ” ，记作 \"<code>1211\"\n</code>描述前一项，这个数是 <code>1211</code> 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 \"<code>111221\"</code>\n</pre>\n\n<p>要 <strong>描述</strong> 一个数字字符串，首先要将字符串分割为 <strong>最小</strong> 数量的组，每个组都由连续的最多 <strong>相同字符</strong> 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p>\n\n<p>例如，数字字符串 <code>\"3322251\"</code> 的描述如下图：</p>\n<img alt=\"\" src=\"https://pic.leetcode-cn.com/1629874763-TGmKUh-image.png\" style=\"width: 581px; height: 172px;\" />\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>\"1\"\n<strong>解释：</strong>这是一个基本样例。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>\"1211\"\n<strong>解释：</strong>\ncountAndSay(1) = \"1\"\ncountAndSay(2) = 读 \"1\" = 一 个 1 = \"11\"\ncountAndSay(3) = 读 \"11\" = 二 个 1 = \"21\"\ncountAndSay(4) = 读 \"21\" = 一 个 2 + 一 个 1 = \"12\" + \"11\" = \"1211\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n</ul>\n", "en": "<p>The <strong>count-and-say</strong> sequence is a sequence of digit strings defined by the recursive formula:</p>\n\n<ul>\n\t<li><code>countAndSay(1) = &quot;1&quot;</code></li>\n\t<li><code>countAndSay(n)</code> is the way you would &quot;say&quot; the digit string from <code>countAndSay(n-1)</code>, which is then converted into a different digit string.</li>\n</ul>\n\n<p>To determine how you &quot;say&quot; a digit string, split it into the <strong>minimal</strong> number of substrings such that each substring contains exactly <strong>one</strong> unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.</p>\n\n<p>For example, the saying and conversion for digit string <code>&quot;3322251&quot;</code>:</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/23/countandsay.jpg\" style=\"width: 581px; height: 172px;\" />\n<p>Given a positive integer <code>n</code>, return <em>the </em><code>n<sup>th</sup></code><em> term of the <strong>count-and-say</strong> sequence</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> &quot;1&quot;\n<strong>Explanation:</strong> This is the base case.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> &quot;1211&quot;\n<strong>Explanation:</strong>\ncountAndSay(1) = &quot;1&quot;\ncountAndSay(2) = say &quot;1&quot; = one 1 = &quot;11&quot;\ncountAndSay(3) = say &quot;11&quot; = two 1&#39;s = &quot;21&quot;\ncountAndSay(4) = say &quot;21&quot; = one 2 + one 1 = &quot;12&quot; + &quot;11&quot; = &quot;1211&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 30</code></li>\n</ul>\n"}}, "39": {"__typename": "QuestionLightNode", "acRate": 0.7248045687587663, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "39", "isFavor": false, "solutionNum": 4431, "title": "Combination Sum", "titleCn": "组合总和", "titleSlug": "combination-sum", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 103, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/99a45f957529ef9ac7be507962ccee294f53b3cd87dc8163d18f16c1228e4a70-belo-cn-200x200-9518747d43e25d1834cda4cbe55464c5.png", "slug": "airbnb", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个 <strong>无重复元素</strong> 的整数数组&nbsp;<code>candidates</code> 和一个目标整数&nbsp;<code>target</code>&nbsp;，找出&nbsp;<code>candidates</code>&nbsp;中可以使数字和为目标数&nbsp;<code>target</code> 的 所有<em>&nbsp;</em><strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>\n\n<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。&nbsp;</p>\n\n<p>对于给定的输入，保证和为&nbsp;<code>target</code> 的不同组合数少于 <code>150</code> 个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>candidates = <code>[2,3,6,7], </code>target = <code>7</code>\n<strong>输出：</strong>[[2,2,3],[7]]\n<strong>解释：</strong>\n2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n7 也是一个候选， 7 = 7 。\n仅有这两种组合。</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = [2,3,5]<code>, </code>target = 8\n<strong>输出: </strong>[[2,2,2,2],[2,3,3],[3,5]]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入: </strong>candidates = <code>[2], </code>target = 1\n<strong>输出: </strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candidates.length &lt;= 30</code></li>\n\t<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>\n\t<li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li>\n\t<li><code>1 &lt;= target &lt;= 40</code></li>\n</ul>\n", "en": "<p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of </em><code>candidates</code><em> where the chosen numbers sum to </em><code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p>\n\n<p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the <span data-keyword=\"frequency-array\">frequency</span> of at least one of the chosen numbers is different.</p>\n\n<p>The test cases are generated such that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,3,6,7], target = 7\n<strong>Output:</strong> [[2,2,3],[7]]\n<strong>Explanation:</strong>\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,3,5], target = 8\n<strong>Output:</strong> [[2,2,2,2],[2,3,3],[3,5]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2], target = 1\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= candidates.length &lt;= 30</code></li>\n\t<li><code>2 &lt;= candidates[i] &lt;= 40</code></li>\n\t<li>All elements of <code>candidates</code> are <strong>distinct</strong>.</li>\n\t<li><code>1 &lt;= target &lt;= 40</code></li>\n</ul>\n"}}, "40": {"__typename": "QuestionLightNode", "acRate": 0.5946027791351508, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "40", "isFavor": false, "solutionNum": 3074, "title": "Combination Sum II", "titleCn": "组合总和 II", "titleSlug": "combination-sum-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 75, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个候选人编号的集合&nbsp;<code>candidates</code>&nbsp;和一个目标数&nbsp;<code>target</code>&nbsp;，找出&nbsp;<code>candidates</code>&nbsp;中所有可以使数字和为&nbsp;<code>target</code>&nbsp;的组合。</p>\n\n<p><code>candidates</code>&nbsp;中的每个数字在每个组合中只能使用&nbsp;<strong>一次</strong>&nbsp;。</p>\n\n<p><strong>注意：</strong>解集不能包含重复的组合。&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> candidates =&nbsp;<code>[10,1,2,7,6,1,5]</code>, target =&nbsp;<code>8</code>,\n<strong>输出:</strong>\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> candidates =&nbsp;[2,5,2,1,2], target =&nbsp;5,\n<strong>输出:</strong>\n[\n[1,2,2],\n[5]\n]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;candidates.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;candidates[i] &lt;= 50</code></li>\n\t<li><code>1 &lt;= target &lt;= 30</code></li>\n</ul>\n", "en": "<p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code>&nbsp;where the candidate numbers sum to <code>target</code>.</p>\n\n<p>Each number in <code>candidates</code>&nbsp;may only be used <strong>once</strong> in the combination.</p>\n\n<p><strong>Note:</strong>&nbsp;The solution set must not contain duplicate combinations.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [10,1,2,7,6,1,5], target = 8\n<strong>Output:</strong> \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> candidates = [2,5,2,1,2], target = 5\n<strong>Output:</strong> \n[\n[1,2,2],\n[5]\n]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;candidates.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;candidates[i] &lt;= 50</code></li>\n\t<li><code>1 &lt;= target &lt;= 30</code></li>\n</ul>\n"}}, "41": {"__typename": "QuestionLightNode", "acRate": 0.44391803111516925, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "41", "isFavor": false, "solutionNum": 2611, "title": "First Missing Positive", "titleCn": "缺失的第一个正数", "titleSlug": "first-missing-positive", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 111, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>\n请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,0]\n<strong>输出：</strong>3\n<strong>解释：</strong>范围 [1,2] 中的数字都在数组中。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,-1,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>1 在数组中，但 2 没有。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,8,9,11,12]\n<strong>输出：</strong>1\n<strong>解释：</strong>最小的正数 1 没有出现。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given an unsorted integer array <code>nums</code>. Return the <em>smallest positive integer</em> that is <em>not present</em> in <code>nums</code>.</p>\n\n<p>You must implement an algorithm that runs in <code>O(n)</code> time and uses <code>O(1)</code> auxiliary space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,0]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The numbers in the range [1,2] are all in the array.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,-1,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> 1 is in the array but 2 is missing.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [7,8,9,11,12]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The smallest positive integer 1 is missing.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "42": {"__typename": "QuestionLightNode", "acRate": 0.6341294211769453, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "42", "isFavor": false, "solutionNum": 5496, "title": "Trapping Rain Water", "titleCn": "接雨水", "titleSlug": "trapping-rain-water", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "xeyj5r5", "name": "Monotonic Stack", "slug": "monotonic-stack", "nameTranslated": "单调栈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 189, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定&nbsp;<code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png\" style=\"height: 161px; width: 412px;\" /></p>\n\n<pre>\n<strong>输入：</strong>height = [0,1,0,2,1,0,1,3,2,1,2,1]\n<strong>输出：</strong>6\n<strong>解释：</strong>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>height = [4,2,0,3,2,5]\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= height[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png\" style=\"width: 412px; height: 161px;\" />\n<pre>\n<strong>Input:</strong> height = [0,1,0,2,1,0,1,3,2,1,2,1]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> height = [4,2,0,3,2,5]\n<strong>Output:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == height.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= height[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "43": {"__typename": "QuestionLightNode", "acRate": 0.44299435471224713, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "43", "isFavor": false, "solutionNum": 2267, "title": "Multiply Strings", "titleCn": "字符串相乘", "titleSlug": "multiply-strings", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 97, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个以字符串形式表示的非负整数&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>，返回&nbsp;<code>num1</code>&nbsp;和&nbsp;<code>num2</code>&nbsp;的乘积，它们的乘积也表示为字符串形式。</p>\n\n<p><strong>注意：</strong>不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> num1 = \"2\", num2 = \"3\"\n<strong>输出:</strong> \"6\"</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> num1 = \"123\", num2 = \"456\"\n<strong>输出:</strong> \"56088\"</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1.length, num2.length &lt;= 200</code></li>\n\t<li><code>num1</code>&nbsp;和 <code>num2</code>&nbsp;只能由数字组成。</li>\n\t<li><code>num1</code>&nbsp;和 <code>num2</code>&nbsp;都不包含任何前导零，除了数字0本身。</li>\n</ul>\n", "en": "<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>\n\n<p><strong>Note:</strong>&nbsp;You must not use any built-in BigInteger library or convert the inputs to integer directly.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> num1 = \"2\", num2 = \"3\"\n<strong>Output:</strong> \"6\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> num1 = \"123\", num2 = \"456\"\n<strong>Output:</strong> \"56088\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1.length, num2.length &lt;= 200</code></li>\n\t<li><code>num1</code> and <code>num2</code> consist of digits only.</li>\n\t<li>Both <code>num1</code> and <code>num2</code>&nbsp;do not contain any leading zero, except the number <code>0</code> itself.</li>\n</ul>\n"}}, "44": {"__typename": "QuestionLightNode", "acRate": 0.3400785945344472, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "44", "isFavor": false, "solutionNum": 972, "title": "Wildcard Matching", "titleCn": "通配符匹配", "titleSlug": "wildcard-matching", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 70, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<div class=\"title__3Vvk\">给你一个输入字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，请你实现一个支持 <code>'?'</code> 和 <code>'*'</code> 匹配规则的通配符匹配：</div>\n\n<ul>\n\t<li class=\"title__3Vvk\"><code>'?'</code> 可以匹配任何单个字符。</li>\n\t<li class=\"title__3Vvk\"><code>'*'</code> 可以匹配任意字符序列（包括空字符序列）。</li>\n</ul>\n\n<div class=\"original__bRMd\">\n<div>\n<p>判定匹配成功的充要条件是：字符模式必须能够 <strong>完全匹配</strong> 输入字符串（而不是部分匹配）。</p>\n</div>\n</div>\n&nbsp;\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aa\", p = \"a\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\"a\" 无法匹配 \"aa\" 整个字符串。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aa\", p = \"*\"\n<strong>输出：</strong>true\n<strong>解释：</strong>'*' 可以匹配任意字符串。\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cb\", p = \"?a\"\n<strong>输出：</strong>false\n<strong>解释：</strong>'?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length, p.length &lt;= 2000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n\t<li><code>p</code> 仅由小写英文字母、<code>'?'</code> 或 <code>'*'</code> 组成</li>\n</ul>\n", "en": "<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>&#39;?&#39;</code> and <code>&#39;*&#39;</code> where:</p>\n\n<ul>\n\t<li><code>&#39;?&#39;</code> Matches any single character.</li>\n\t<li><code>&#39;*&#39;</code> Matches any sequence of characters (including the empty sequence).</li>\n</ul>\n\n<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;a&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;a&quot; does not match the entire string &quot;aa&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aa&quot;, p = &quot;*&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong>&nbsp;&#39;*&#39; matches any sequence.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cb&quot;, p = &quot;?a&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong>&nbsp;&#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length, p.length &lt;= 2000</code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n\t<li><code>p</code> contains only lowercase English letters, <code>&#39;?&#39;</code> or <code>&#39;*&#39;</code>.</li>\n</ul>\n"}}, "45": {"__typename": "QuestionLightNode", "acRate": 0.4446095805021964, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "45", "isFavor": false, "solutionNum": 4175, "title": "Jump Game II", "titleCn": "跳跃游戏 II", "titleSlug": "jump-game-ii", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 94, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/d2e85988beccb271af4b1a8f4767e4bdf4c085aaf5aaef093347d778e4e138d7-20.png", "slug": "huawei", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p>\n\n<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>\n\n<ul>\n\t<li><code>0 &lt;= j &lt;= nums[i]</code>&nbsp;</li>\n\t<li><code>i + j &lt; n</code></li>\n</ul>\n\n<p>返回到达&nbsp;<code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [2,3,1,1,4]\n<strong>输出:</strong> 2\n<strong>解释:</strong> 跳到最后一个位置的最小跳跃数是 <code>2</code>。\n&nbsp;    从下标为 0 跳到下标为 1 的位置，跳&nbsp;<code>1</code>&nbsp;步，然后跳&nbsp;<code>3</code>&nbsp;步到达数组的最后一个位置。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [2,3,0,1,4]\n<strong>输出:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>题目保证可以到达&nbsp;<code>nums[n-1]</code></li>\n</ul>\n", "en": "<p>You are given a <strong>0-indexed</strong> array of integers <code>nums</code> of length <code>n</code>. You are initially positioned at <code>nums[0]</code>.</p>\n\n<p>Each element <code>nums[i]</code> represents the maximum length of a forward jump from index <code>i</code>. In other words, if you are at <code>nums[i]</code>, you can jump to any <code>nums[i + j]</code> where:</p>\n\n<ul>\n\t<li><code>0 &lt;= j &lt;= nums[i]</code> and</li>\n\t<li><code>i + j &lt; n</code></li>\n</ul>\n\n<p>Return <em>the minimum number of jumps to reach </em><code>nums[n - 1]</code>. The test cases are generated such that you can reach <code>nums[n - 1]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,1,1,4]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,0,1,4]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>It&#39;s guaranteed that you can reach <code>nums[n - 1]</code>.</li>\n</ul>\n"}}, "46": {"__typename": "QuestionLightNode", "acRate": 0.7913612792737768, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "46", "isFavor": false, "solutionNum": 6416, "title": "Permutations", "titleCn": "全排列", "titleSlug": "permutations", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 187, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>[[0,1],[1,0]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 6</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n", "en": "<p>Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0,1]\n<strong>Output:</strong> [[0,1],[1,0]]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 6</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n"}}, "47": {"__typename": "QuestionLightNode", "acRate": 0.6569519886325974, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "47", "isFavor": false, "solutionNum": 3173, "title": "Permutations II", "titleCn": "全排列 II", "titleSlug": "permutations-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 71, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2]\n<strong>输出：</strong>\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 8</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n</ul>\n", "en": "<p>Given a collection of numbers, <code>nums</code>,&nbsp;that might contain duplicates, return <em>all possible unique permutations <strong>in any order</strong>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,2]\n<strong>Output:</strong>\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 8</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n</ul>\n"}}, "48": {"__typename": "QuestionLightNode", "acRate": 0.7595717892610672, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "48", "isFavor": false, "solutionNum": 5138, "title": "Rotate Image", "titleCn": "旋转图像", "titleSlug": "rotate-image", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 125, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个 <em>n&nbsp;</em>×&nbsp;<em>n</em> 的二维矩阵&nbsp;<code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>\n\n<p>你必须在<strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"> 原地</a></strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要 </strong>使用另一个矩阵来旋转图像。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg\" style=\"height: 188px; width: 500px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[[7,4,1],[8,5,2],[9,6,3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg\" style=\"height: 201px; width: 500px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n<strong>输出：</strong>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n", "en": "<p>You are given an <code>n x n</code> 2D <code>matrix</code> representing an image, rotate the image by <strong>90</strong> degrees (clockwise).</p>\n\n<p>You have to rotate the image <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg\" style=\"width: 500px; height: 188px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [[7,4,1],[8,5,2],[9,6,3]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg\" style=\"width: 500px; height: 201px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n<strong>Output:</strong> [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li>\n</ul>\n"}}, "49": {"__typename": "QuestionLightNode", "acRate": 0.679788276573705, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "49", "isFavor": false, "solutionNum": 3404, "title": "Group Anagrams", "titleCn": "字母异位词分组", "titleSlug": "group-anagrams", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 128, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>\n\n<p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = <code>[\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]</code>\n<strong>输出: </strong>[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = <code>[\"\"]</code>\n<strong>输出: </strong>[[\"\"]]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = <code>[\"a\"]</code>\n<strong>输出: </strong>[[\"a\"]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code>&nbsp;仅包含小写字母</li>\n</ul>\n", "en": "<p>Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p>\n\n<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n<strong>Output:</strong> [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> strs = [\"\"]\n<strong>Output:</strong> [[\"\"]]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> strs = [\"a\"]\n<strong>Output:</strong> [[\"a\"]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code> consists of lowercase English letters.</li>\n</ul>\n"}}, "50": {"__typename": "QuestionLightNode", "acRate": 0.3823253817262743, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "50", "isFavor": false, "solutionNum": 2375, "title": "Pow(x, n)", "titleCn": "Pow(x, n)", "titleSlug": "powx-n", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 107, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>实现&nbsp;<a href=\"https://www.cplusplus.com/reference/valarray/pow/\" target=\"_blank\">pow(<em>x</em>, <em>n</em>)</a>&nbsp;，即计算 <code>x</code> 的整数&nbsp;<code>n</code> 次幂函数（即，<code>x<sup>n</sup></code><sup><span style=\"font-size:10.8333px\"> </span></sup>）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2.00000, n = 10\n<strong>输出：</strong>1024.00000\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2.10000, n = 3\n<strong>输出：</strong>9.26100\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 2.00000, n = -2\n<strong>输出：</strong>0.25000\n<strong>解释：</strong>2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-100.0 &lt; x &lt; 100.0</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup>-1</code></li>\n\t<li><code>n</code>&nbsp;是一个整数</li>\n\t<li>要么 <code>x</code> 不为零，要么 <code>n &gt; 0</code> 。</li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sup>n</sup> &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Implement <a href=\"http://www.cplusplus.com/reference/valarray/pow/\" target=\"_blank\">pow(x, n)</a>, which calculates <code>x</code> raised to the power <code>n</code> (i.e., <code>x<sup>n</sup></code>).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 2.00000, n = 10\n<strong>Output:</strong> 1024.00000\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 2.10000, n = 3\n<strong>Output:</strong> 9.26100\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 2.00000, n = -2\n<strong>Output:</strong> 0.25000\n<strong>Explanation:</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-100.0 &lt; x &lt; 100.0</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup>-1</code></li>\n\t<li><code>n</code> is an integer.</li>\n\t<li>Either <code>x</code> is not zero or <code>n &gt; 0</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sup>n</sup> &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "51": {"__typename": "QuestionLightNode", "acRate": 0.7391739674593242, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "51", "isFavor": false, "solutionNum": 3452, "title": "N-Queens", "titleCn": "N 皇后", "titleSlug": "n-queens", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 77, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>\n\n<p><strong>n&nbsp;皇后问题</strong> 研究的是如何将 <code>n</code>&nbsp;个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n\n<p>给你一个整数 <code>n</code> ，返回所有不同的&nbsp;<strong>n<em>&nbsp;</em>皇后问题</strong> 的解决方案。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>每一种解法包含一个不同的&nbsp;<strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/queens.jpg\" style=\"width: 600px; height: 268px;\" />\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n<strong>解释：</strong>如上图所示，4 皇后问题存在两个不同的解法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>[[\"Q\"]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 9</code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p>\n\n<p>Given an integer <code>n</code>, return <em>all distinct solutions to the <strong>n-queens puzzle</strong></em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>Each solution contains a distinct board configuration of the n-queens&#39; placement, where <code>&#39;Q&#39;</code> and <code>&#39;.&#39;</code> both indicate a queen and an empty space, respectively.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/queens.jpg\" style=\"width: 600px; height: 268px;\" />\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> [[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]\n<strong>Explanation:</strong> There exist two distinct solutions to the 4-queens puzzle as shown above\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [[&quot;Q&quot;]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 9</code></li>\n</ul>\n"}}, "52": {"__typename": "QuestionLightNode", "acRate": 0.8228056245389376, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "52", "isFavor": false, "solutionNum": 1041, "title": "N-Queens II", "titleCn": "N 皇后 II", "titleSlug": "n-queens-ii", "topicTags": [{"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 28, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><strong>n&nbsp;皇后问题</strong> 研究的是如何将 <code>n</code>&nbsp;个皇后放置在 <code>n × n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n\n<p>给你一个整数 <code>n</code> ，返回 <strong>n 皇后问题</strong> 不同的解决方案的数量。</p>\n\n<p>&nbsp;</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/queens.jpg\" style=\"width: 600px; height: 268px;\" />\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>如上图所示，4 皇后问题存在两个不同的解法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 9</code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p>\n\n<p>Given an integer <code>n</code>, return <em>the number of distinct solutions to the&nbsp;<strong>n-queens puzzle</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/queens.jpg\" style=\"width: 600px; height: 268px;\" />\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are two distinct solutions to the 4-queens puzzle as shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 9</code></li>\n</ul>\n"}}, "53": {"__typename": "QuestionLightNode", "acRate": 0.5526308747958906, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "53", "isFavor": false, "solutionNum": 7813, "title": "Maximum Subarray", "titleCn": "最大子数组和", "titleSlug": "maximum-subarray", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 209, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n\n<p><strong><span data-keyword=\"subarray-nonempty\">子数组 </span></strong>是数组中的一个连续部分。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-2,1,-3,4,-1,2,1,-5,4]\n<strong>输出：</strong>6\n<strong>解释：</strong>连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,4,-1,7,8]\n<strong>输出：</strong>23\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>\n", "en": "<p>Given an integer array <code>nums</code>, find the <span data-keyword=\"subarray-nonempty\">subarray</span> with the largest sum, and return <em>its sum</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The subarray [4,-1,2,1] has the largest sum 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The subarray [1] has the largest sum 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,4,-1,7,8]\n<strong>Output:</strong> 23\n<strong>Explanation:</strong> The subarray [5,4,-1,7,8] has the largest sum 23.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution using the <strong>divide and conquer</strong> approach, which is more subtle.</p>\n"}}, "54": {"__typename": "QuestionLightNode", "acRate": 0.5066087183975694, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "54", "isFavor": false, "solutionNum": 4814, "title": "Spiral Matrix", "titleCn": "螺旋矩阵", "titleSlug": "spiral-matrix", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 153, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n<strong>输出：</strong>[1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 10</code></li>\n\t<li><code>-100 <= matrix[i][j] <= 100</code></li>\n</ul>\n", "en": "<p>Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [1,2,3,6,9,8,7,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n<strong>Output:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10</code></li>\n\t<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n</ul>\n"}}, "55": {"__typename": "QuestionLightNode", "acRate": 0.432808793235515, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "55", "isFavor": false, "solutionNum": 6030, "title": "Jump Game", "titleCn": "跳跃游戏", "titleSlug": "jump-game", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 112, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个非负整数数组&nbsp;<code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n\n<p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,1,1,4]\n<strong>输出：</strong>true\n<strong>解释：</strong>可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,1,0,4]\n<strong>输出：</strong>false\n<strong>解释：</strong>无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>You are given an integer array <code>nums</code>. You are initially positioned at the array&#39;s <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</p>\n\n<p>Return <code>true</code><em> if you can reach the last index, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,1,1,4]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Jump 1 step from index 0 to 1, then 3 steps to the last index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,1,0,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "56": {"__typename": "QuestionLightNode", "acRate": 0.49908591235924893, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "56", "isFavor": false, "solutionNum": 5014, "title": "Merge Intervals", "titleCn": "合并区间", "titleSlug": "merge-intervals", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 175, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> 。请你合并所有重叠的区间，并返回&nbsp;<em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,3],[2,6],[8,10],[15,18]]\n<strong>输出：</strong>[[1,6],[8,10],[15,18]]\n<strong>解释：</strong>区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,4],[4,5]]\n<strong>输出：</strong>[[1,5]]\n<strong>解释：</strong>区间 [1,4] 和 [4,5] 可被视为重叠区间。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given an array&nbsp;of <code>intervals</code>&nbsp;where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, merge all overlapping intervals, and return <em>an array of the non-overlapping intervals that cover all the intervals in the input</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,3],[2,6],[8,10],[15,18]]\n<strong>Output:</strong> [[1,6],[8,10],[15,18]]\n<strong>Explanation:</strong> Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,4],[4,5]]\n<strong>Output:</strong> [[1,5]]\n<strong>Explanation:</strong> Intervals [1,4] and [4,5] are considered overlapping.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "57": {"__typename": "QuestionLightNode", "acRate": 0.42636890612619377, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "57", "isFavor": false, "solutionNum": 1743, "title": "Insert Interval", "titleCn": "插入区间", "titleSlug": "insert-interval", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 70, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个<strong> 无重叠的</strong><em> ，</em>按照区间起始端点排序的区间列表 <code>intervals</code>，其中&nbsp;<code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;表示第&nbsp;<code>i</code>&nbsp;个区间的开始和结束，并且&nbsp;<code>intervals</code>&nbsp;按照&nbsp;<code>start<sub>i</sub></code>&nbsp;升序排列。同样给定一个区间&nbsp;<code>newInterval = [start, end]</code>&nbsp;表示另一个区间的开始和结束。</p>\n\n<p>在&nbsp;<code>intervals</code> 中插入区间&nbsp;<code>newInterval</code>，使得&nbsp;<code>intervals</code>&nbsp;依然按照&nbsp;<code>start<sub>i</sub></code>&nbsp;升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。</p>\n\n<p>返回插入之后的&nbsp;<code>intervals</code>。</p>\n\n<p><strong>注意</strong> 你不需要原地修改&nbsp;<code>intervals</code>。你可以创建一个新数组然后返回它。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,3],[6,9]], newInterval = [2,5]\n<strong>输出：</strong>[[1,5],[6,9]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n<strong>输出：</strong>[[1,2],[3,10],[12,16]]\n<strong>解释：</strong>这是因为新的区间 <code>[4,8]</code> 与 <code>[3,5],[6,7],[8,10]</code>&nbsp;重叠。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;=&nbsp;start<sub>i</sub> &lt;=&nbsp;end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals</code> 根据 <code>start<sub>i</sub></code> 按 <strong>升序</strong> 排列</li>\n\t<li><code>newInterval.length == 2</code></li>\n\t<li><code>0 &lt;=&nbsp;start &lt;=&nbsp;end &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>You are given an array of non-overlapping intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represent the start and the end of the <code>i<sup>th</sup></code> interval and <code>intervals</code> is sorted in ascending order by <code>start<sub>i</sub></code>. You are also given an interval <code>newInterval = [start, end]</code> that represents the start and end of another interval.</p>\n\n<p>Insert <code>newInterval</code> into <code>intervals</code> such that <code>intervals</code> is still sorted in ascending order by <code>start<sub>i</sub></code> and <code>intervals</code> still does not have any overlapping intervals (merge overlapping intervals if necessary).</p>\n\n<p>Return <code>intervals</code><em> after the insertion</em>.</p>\n\n<p><strong>Note</strong> that you don&#39;t need to modify <code>intervals</code> in-place. You can make a new array and return it.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]\n<strong>Output:</strong> [[1,5],[6,9]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n<strong>Output:</strong> [[1,2],[3,10],[12,16]]\n<strong>Explanation:</strong> Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals</code> is sorted by <code>start<sub>i</sub></code> in <strong>ascending</strong> order.</li>\n\t<li><code>newInterval.length == 2</code></li>\n\t<li><code>0 &lt;= start &lt;= end &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "58": {"__typename": "QuestionLightNode", "acRate": 0.4535110069468081, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "58", "isFavor": false, "solutionNum": 5538, "title": "Length of Last Word", "titleCn": "最后一个单词的长度", "titleSlug": "length-of-last-word", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 39, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 <strong>最后一个</strong> 单词的长度。</p>\n\n<p><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大<span data-keyword=\"substring\">子字符串</span>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"Hello World\"\n<strong>输出：</strong>5\n<strong>解释：</strong>最后一个单词是“World”，长度为5。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"   fly me   to   the moon  \"\n<strong>输出：</strong>4<strong>\n解释：</strong>最后一个单词是“moon”，长度为4。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"luffy is still joyboy\"\n<strong>输出：</strong>6\n<strong>解释：</strong>最后一个单词是长度为6的“joyboy”。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 仅有英文字母和空格 <code>' '</code> 组成</li>\n\t<li><code>s</code> 中至少存在一个单词</li>\n</ul>\n", "en": "<p>Given a string <code>s</code> consisting of words and spaces, return <em>the length of the <strong>last</strong> word in the string.</em></p>\n\n<p>A <strong>word</strong> is a maximal <span data-keyword=\"substring-nonempty\">substring</span> consisting of non-space characters only.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;Hello World&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The last word is &quot;World&quot; with length 5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;   fly me   to   the moon  &quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The last word is &quot;moon&quot; with length 4.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;luffy is still joyboy&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The last word is &quot;joyboy&quot; with length 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of only English letters and spaces <code>&#39; &#39;</code>.</li>\n\t<li>There will be at least one word in <code>s</code>.</li>\n</ul>\n"}}, "59": {"__typename": "QuestionLightNode", "acRate": 0.7101145191546411, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "59", "isFavor": false, "solutionNum": 4069, "title": "Spiral Matrix II", "titleCn": "螺旋矩阵 II", "titleSlug": "spiral-matrix-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 71, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n<sup>2</sup></code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[[1,2,3],[8,9,4],[7,6,5]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 20</code></li>\n</ul>\n", "en": "<p>Given a positive integer <code>n</code>, generate an <code>n x n</code> <code>matrix</code> filled with elements from <code>1</code> to <code>n<sup>2</sup></code> in spiral order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> [[1,2,3],[8,9,4],[7,6,5]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n"}}, "60": {"__typename": "QuestionLightNode", "acRate": 0.5366123270170822, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "60", "isFavor": false, "solutionNum": 1539, "title": "Permutation Sequence", "titleCn": "排列序列", "titleSlug": "permutation-sequence", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 40, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给出集合 <code>[1,2,3,...,n]</code>，其所有元素共有 <code>n!</code> 种排列。</p>\n\n<p>按大小顺序列出所有排列情况，并一一标记，当 <code>n = 3</code> 时, 所有排列如下：</p>\n\n<ol>\n\t<li><code>\"123\"</code></li>\n\t<li><code>\"132\"</code></li>\n\t<li><code>\"213\"</code></li>\n\t<li><code>\"231\"</code></li>\n\t<li><code>\"312\"</code></li>\n\t<li><code>\"321\"</code></li>\n</ol>\n\n<p>给定 <code>n</code> 和 <code>k</code>，返回第 <code>k</code> 个排列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 3\n<strong>输出：</strong>\"213\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, k = 9\n<strong>输出：</strong>\"2314\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 1\n<strong>输出：</strong>\"123\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 9</code></li>\n\t<li><code>1 <= k <= n!</code></li>\n</ul>\n", "en": "<p>The set <code>[1, 2, 3, ...,&nbsp;n]</code> contains a total of <code>n!</code> unique permutations.</p>\n\n<p>By listing and labeling all of the permutations in order, we get the following sequence for <code>n = 3</code>:</p>\n\n<ol>\n\t<li><code>&quot;123&quot;</code></li>\n\t<li><code>&quot;132&quot;</code></li>\n\t<li><code>&quot;213&quot;</code></li>\n\t<li><code>&quot;231&quot;</code></li>\n\t<li><code>&quot;312&quot;</code></li>\n\t<li><code>&quot;321&quot;</code></li>\n</ol>\n\n<p>Given <code>n</code> and <code>k</code>, return the <code>k<sup>th</sup></code> permutation sequence.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 3, k = 3\n<strong>Output:</strong> \"213\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 4, k = 9\n<strong>Output:</strong> \"2314\"\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> n = 3, k = 1\n<strong>Output:</strong> \"123\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 9</code></li>\n\t<li><code>1 &lt;= k &lt;= n!</code></li>\n</ul>\n"}}, "61": {"__typename": "QuestionLightNode", "acRate": 0.4133507896786596, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "61", "isFavor": false, "solutionNum": 3417, "title": "Rotate List", "titleCn": "旋转链表", "titleSlug": "rotate-list", "topicTags": [{"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 56, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动&nbsp;<code>k</code><em>&nbsp;</em>个位置。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg\" style=\"width: 450px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], k = 2\n<strong>输出：</strong>[4,5,1,2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg\" style=\"width: 305px; height: 350px;\" />\n<pre>\n<strong>输入：</strong>head = [0,1,2], k = 4\n<strong>输出：</strong>[2,0,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[0, 500]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt;= 2 * 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Given the <code>head</code> of a linked&nbsp;list, rotate the list to the right by <code>k</code> places.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg\" style=\"width: 450px; height: 191px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], k = 2\n<strong>Output:</strong> [4,5,1,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg\" style=\"width: 305px; height: 350px;\" />\n<pre>\n<strong>Input:</strong> head = [0,1,2], k = 4\n<strong>Output:</strong> [2,0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 500]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt;= 2 * 10<sup>9</sup></code></li>\n</ul>\n"}}, "62": {"__typename": "QuestionLightNode", "acRate": 0.6814372274009713, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "62", "isFavor": false, "solutionNum": 4809, "title": "Unique Paths", "titleCn": "不同路径", "titleSlug": "unique-paths", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "rwhb85", "name": "Combinatorics", "slug": "combinatorics", "nameTranslated": "组合数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 112, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>一个机器人位于一个 <code>m x n</code><em>&nbsp;</em>网格的左上角 （起始点在下图中标记为 “Start” ）。</p>\n\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>\n\n<p>问总共有多少条不同的路径？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://pic.leetcode.cn/1697422740-adxmsI-image.png\" style=\"width: 400px; height: 183px;\" />\n<pre>\n<strong>输入：</strong>m = 3, n = 7\n<strong>输出：</strong>28</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -&gt; 向下 -&gt; 向下\n2. 向下 -&gt; 向下 -&gt; 向右\n3. 向下 -&gt; 向右 -&gt; 向下\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 7, n = 3\n<strong>输出：</strong>28\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>m = 3, n = 3\n<strong>输出：</strong>6</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li>题目数据保证答案小于等于 <code>2 * 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>\n\n<p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>\n\n<p>The test cases are generated so that the answer will be less than or equal to <code>2 * 10<sup>9</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\" style=\"width: 400px; height: 183px;\" />\n<pre>\n<strong>Input:</strong> m = 3, n = 7\n<strong>Output:</strong> 28\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> m = 3, n = 2\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -&gt; Down -&gt; Down\n2. Down -&gt; Down -&gt; Right\n3. Down -&gt; Right -&gt; Down\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n</ul>\n"}}, "63": {"__typename": "QuestionLightNode", "acRate": 0.413015967415132, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "63", "isFavor": false, "solutionNum": 3474, "title": "Unique Paths II", "titleCn": "不同路径 II", "titleSlug": "unique-paths-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 76, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>一个机器人位于一个<meta charset=\"UTF-8\" />&nbsp;<code>m x n</code>&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）。</p>\n\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>\n\n<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>\n\n<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg\" />\n<pre>\n<strong>输入：</strong>obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 <code>2</code> 条不同的路径：\n1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下\n2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg\" />\n<pre>\n<strong>输入：</strong>obstacleGrid = [[0,1],[0,0]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m ==&nbsp;obstacleGrid.length</code></li>\n\t<li><code>n ==&nbsp;obstacleGrid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n", "en": "<p>You are given an <code>m x n</code> integer array <code>grid</code>. There is a robot initially located at the <b>top-left corner</b> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>\n\n<p>An obstacle and space are marked as <code>1</code> or <code>0</code> respectively in <code>grid</code>. A path that the robot takes cannot include <strong>any</strong> square that is an obstacle.</p>\n\n<p>Return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p>\n\n<p>The testcases are generated so that the answer will be less than or equal to <code>2 * 10<sup>9</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -&gt; Right -&gt; Down -&gt; Down\n2. Down -&gt; Down -&gt; Right -&gt; Right\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> obstacleGrid = [[0,1],[0,0]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == obstacleGrid.length</code></li>\n\t<li><code>n == obstacleGrid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>obstacleGrid[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n</ul>\n"}}, "64": {"__typename": "QuestionLightNode", "acRate": 0.7024737195577931, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "64", "isFavor": false, "solutionNum": 3812, "title": "Minimum Path Sum", "titleCn": "最小路径和", "titleSlug": "minimum-path-sum", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 108, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个包含非负整数的 <code><em>m</em>&nbsp;x&nbsp;<em>n</em></code>&nbsp;网格&nbsp;<code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>\n\n<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>grid = [[1,3,1],[1,5,1],[4,2,1]]\n<strong>输出：</strong>7\n<strong>解释：</strong>因为路径 1→3→1→1→1 的总和最小。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,2,3],[4,5,6]]\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 200</code></li>\n</ul>\n", "en": "<p>Given a <code>m x n</code> <code>grid</code> filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p>\n\n<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,3,1],[1,5,1],[4,2,1]]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Because the path 1 &rarr; 3 &rarr; 1 &rarr; 1 &rarr; 1 minimizes the sum.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1,2,3],[4,5,6]]\n<strong>Output:</strong> 12\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 200</code></li>\n</ul>\n"}}, "65": {"__typename": "QuestionLightNode", "acRate": 0.276725174873394, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "65", "isFavor": false, "solutionNum": 978, "title": "Valid Number", "titleCn": "有效数字", "titleSlug": "valid-number", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 41, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p>\n\n<ol>\n\t<li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li>\n\t<li>（可选）一个 <code>'e'</code> 或 <code>'E'</code> ，后面跟着一个 <strong>整数</strong></li>\n</ol>\n\n<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>\n\n<ol>\n\t<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>\n\t<li>下述格式之一：\n\t<ol>\n\t\t<li>至少一位数字，后面跟着一个点 <code>'.'</code></li>\n\t\t<li>至少一位数字，后面跟着一个点 <code>'.'</code> ，后面再跟着至少一位数字</li>\n\t\t<li>一个点 <code>'.'</code> ，后面跟着至少一位数字</li>\n\t</ol>\n\t</li>\n</ol>\n\n<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>\n\n<ol>\n\t<li>（可选）一个符号字符（<code>'+'</code> 或 <code>'-'</code>）</li>\n\t<li>至少一位数字</li>\n</ol>\n\n<p>部分有效数字列举如下：<code>[\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"]</code></p>\n\n<p>部分无效数字列举如下：<code>[\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"]</code></p>\n\n<p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>有效数字</strong> ，请返回 <code>true</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"e\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \".\"\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>'+'</code> ，减号 <code>'-'</code> ，或者点 <code>'.'</code> 。</li>\n</ul>\n", "en": "<p>A <strong>valid number</strong> can be split up into these components (in order):</p>\n\n<ol>\n\t<li>A <strong>decimal number</strong> or an <strong>integer</strong>.</li>\n\t<li>(Optional) An <code>&#39;e&#39;</code> or <code>&#39;E&#39;</code>, followed by an <strong>integer</strong>.</li>\n</ol>\n\n<p>A <strong>decimal number</strong> can be split up into these components (in order):</p>\n\n<ol>\n\t<li>(Optional) A sign character (either <code>&#39;+&#39;</code> or <code>&#39;-&#39;</code>).</li>\n\t<li>One of the following formats:\n\t<ol>\n\t\t<li>One or more digits, followed by a dot <code>&#39;.&#39;</code>.</li>\n\t\t<li>One or more digits, followed by a dot <code>&#39;.&#39;</code>, followed by one or more digits.</li>\n\t\t<li>A dot <code>&#39;.&#39;</code>, followed by one or more digits.</li>\n\t</ol>\n\t</li>\n</ol>\n\n<p>An <strong>integer</strong> can be split up into these components (in order):</p>\n\n<ol>\n\t<li>(Optional) A sign character (either <code>&#39;+&#39;</code> or <code>&#39;-&#39;</code>).</li>\n\t<li>One or more digits.</li>\n</ol>\n\n<p>For example, all the following are valid numbers: <code>[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;]</code>, while the following are not valid numbers: <code>[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code>.</p>\n\n<p>Given a string <code>s</code>, return <code>true</code><em> if </em><code>s</code><em> is a <strong>valid number</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;0&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;e&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;.&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> consists of only English letters (both uppercase and lowercase), digits (<code>0-9</code>), plus <code>&#39;+&#39;</code>, minus <code>&#39;-&#39;</code>, or dot <code>&#39;.&#39;</code>.</li>\n</ul>\n"}}, "66": {"__typename": "QuestionLightNode", "acRate": 0.45670649539565944, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "66", "isFavor": false, "solutionNum": 6465, "title": "Plus One", "titleCn": "加一", "titleSlug": "plus-one", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 71, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个由 <strong>整数 </strong>组成的<strong> 非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p>\n\n<p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p>\n\n<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [1,2,3]\n<strong>输出：</strong>[1,2,4]\n<strong>解释：</strong>输入数组表示数字 123。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [4,3,2,1]\n<strong>输出：</strong>[4,3,2,2]\n<strong>解释：</strong>输入数组表示数字 4321。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>digits = [0]\n<strong>输出：</strong>[1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= digits.length <= 100</code></li>\n\t<li><code>0 <= digits[i] <= 9</code></li>\n</ul>\n", "en": "<p>You are given a <strong>large integer</strong> represented as an integer array <code>digits</code>, where each <code>digits[i]</code> is the <code>i<sup>th</sup></code> digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading <code>0</code>&#39;s.</p>\n\n<p>Increment the large integer by one and return <em>the resulting array of digits</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [1,2,3]\n<strong>Output:</strong> [1,2,4]\n<strong>Explanation:</strong> The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [4,3,2,1]\n<strong>Output:</strong> [4,3,2,2]\n<strong>Explanation:</strong> The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> digits = [9]\n<strong>Output:</strong> [1,0]\n<strong>Explanation:</strong> The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= digits.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= digits[i] &lt;= 9</code></li>\n\t<li><code>digits</code> does not contain any leading <code>0</code>&#39;s.</li>\n</ul>\n"}}, "67": {"__typename": "QuestionLightNode", "acRate": 0.5301464325270155, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "67", "isFavor": false, "solutionNum": 3395, "title": "Add Binary", "titleCn": "二进制求和", "titleSlug": "add-binary", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 64, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个二进制字符串 <code>a</code> 和 <code>b</code> ，以二进制字符串的形式返回它们的和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入:</strong>a = \"11\", b = \"1\"\n<strong>输出：</strong>\"100\"</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = \"1010\", b = \"1011\"\n<strong>输出：</strong>\"10101\"</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>a</code> 和 <code>b</code> 仅由字符 <code>'0'</code> 或 <code>'1'</code> 组成</li>\n\t<li>字符串如果不是 <code>\"0\"</code> ，就不含前导零</li>\n</ul>\n", "en": "<p>Given two binary strings <code>a</code> and <code>b</code>, return <em>their sum as a binary string</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> a = \"11\", b = \"1\"\n<strong>Output:</strong> \"100\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> a = \"1010\", b = \"1011\"\n<strong>Output:</strong> \"10101\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>a</code> and <code>b</code> consist&nbsp;only of <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code> characters.</li>\n\t<li>Each string does not contain leading zeros except for the zero itself.</li>\n</ul>\n"}}, "68": {"__typename": "QuestionLightNode", "acRate": 0.5380379737806879, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "68", "isFavor": false, "solutionNum": 1004, "title": "Text Justification", "titleCn": "文本左右对齐", "titleSlug": "text-justification", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 68, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个单词数组&nbsp;<code>words</code> 和一个长度&nbsp;<code>maxWidth</code>&nbsp;，重新排版单词，使其成为每行恰好有&nbsp;<code>maxWidth</code>&nbsp;个字符，且左右两端对齐的文本。</p>\n\n<p>你应该使用 “<strong>贪心算法</strong>” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格&nbsp;<code>' '</code>&nbsp;填充，使得每行恰好有 <em>maxWidth</em>&nbsp;个字符。</p>\n\n<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>\n\n<p>文本的最后一行应为左对齐，且单词之间不插入<strong>额外的</strong>空格。</p>\n\n<p><strong>注意:</strong></p>\n\n<ul>\n\t<li>单词是指由非空格字符组成的字符序列。</li>\n\t<li>每个单词的长度大于 0，小于等于&nbsp;<em>maxWidth</em>。</li>\n\t<li>输入单词数组 <code>words</code>&nbsp;至少包含一个单词。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n<strong>输出:</strong>\n[\n&nbsp; &nbsp;\"This &nbsp; &nbsp;is &nbsp; &nbsp;an\",\n&nbsp; &nbsp;\"example &nbsp;of text\",\n&nbsp; &nbsp;\"justification. &nbsp;\"\n]\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong>words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n<strong>输出:</strong>\n[\n&nbsp; \"What &nbsp; must &nbsp; be\",\n&nbsp; \"acknowledgment &nbsp;\",\n&nbsp; \"shall be &nbsp; &nbsp; &nbsp; &nbsp;\"\n]\n<strong>解释: </strong>注意最后一行的格式应为 \"shall be    \" 而不是 \"shall     be\",\n&nbsp;    因为最后一行应为左对齐，而不是左右两端对齐。       \n     第二行同样为左对齐，这是因为这行只包含一个单词。\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre>\n<strong>输入:</strong>words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]，maxWidth = 20\n<strong>输出:</strong>\n[\n&nbsp; \"Science &nbsp;is &nbsp;what we\",\n  \"understand &nbsp; &nbsp; &nbsp;well\",\n&nbsp; \"enough to explain to\",\n&nbsp; \"a &nbsp;computer. &nbsp;Art is\",\n&nbsp; \"everything &nbsp;else &nbsp;we\",\n&nbsp; \"do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\"\n]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>words[i]</code>&nbsp;由小写英文字母和符号组成</li>\n\t<li><code>1 &lt;= maxWidth &lt;= 100</code></li>\n\t<li><code>words[i].length &lt;= maxWidth</code></li>\n</ul>\n", "en": "<p>Given an array of strings <code>words</code> and a width <code>maxWidth</code>, format the text such that each line has exactly <code>maxWidth</code> characters and is fully (left and right) justified.</p>\n\n<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>&#39; &#39;</code> when necessary so that each line has exactly <code>maxWidth</code> characters.</p>\n\n<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>\n\n<p>For the last line of text, it should be left-justified, and no extra space is inserted between words.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>A word is defined as a character sequence consisting of non-space characters only.</li>\n\t<li>Each word&#39;s length is guaranteed to be greater than <code>0</code> and not exceed <code>maxWidth</code>.</li>\n\t<li>The input array <code>words</code> contains at least one word.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;], maxWidth = 16\n<strong>Output:</strong>\n[\n&nbsp; &nbsp;&quot;This &nbsp; &nbsp;is &nbsp; &nbsp;an&quot;,\n&nbsp; &nbsp;&quot;example &nbsp;of text&quot;,\n&nbsp; &nbsp;&quot;justification. &nbsp;&quot;\n]</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;], maxWidth = 16\n<strong>Output:</strong>\n[\n&nbsp; &quot;What &nbsp; must &nbsp; be&quot;,\n&nbsp; &quot;acknowledgment &nbsp;&quot;,\n&nbsp; &quot;shall be &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]\n<strong>Explanation:</strong> Note that the last line is &quot;shall be    &quot; instead of &quot;shall     be&quot;, because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,&quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;], maxWidth = 20\n<strong>Output:</strong>\n[\n&nbsp; &quot;Science &nbsp;is &nbsp;what we&quot;,\n  &quot;understand &nbsp; &nbsp; &nbsp;well&quot;,\n&nbsp; &quot;enough to explain to&quot;,\n&nbsp; &quot;a &nbsp;computer. &nbsp;Art is&quot;,\n&nbsp; &quot;everything &nbsp;else &nbsp;we&quot;,\n&nbsp; &quot;do &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;\n]</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>words[i]</code> consists of only English letters and symbols.</li>\n\t<li><code>1 &lt;= maxWidth &lt;= 100</code></li>\n\t<li><code>words[i].length &lt;= maxWidth</code></li>\n</ul>\n"}}, "69": {"__typename": "QuestionLightNode", "acRate": 0.38510381435183616, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "69", "isFavor": false, "solutionNum": 4343, "title": "Sqrt(x)", "titleCn": "x 的平方根 ", "titleSlug": "sqrtx", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 113, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个非负整数 <code>x</code> ，计算并返回&nbsp;<code>x</code>&nbsp;的 <strong>算术平方根</strong> 。</p>\n\n<p>由于返回类型是整数，结果只保留 <strong>整数部分 </strong>，小数部分将被 <strong>舍去 。</strong></p>\n\n<p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 4\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 8\n<strong>输出：</strong>2\n<strong>解释：</strong>8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= x &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given a non-negative integer <code>x</code>, return <em>the square root of </em><code>x</code><em> rounded down to the nearest integer</em>. The returned integer should be <strong>non-negative</strong> as well.</p>\n\n<p>You <strong>must not use</strong> any built-in exponent function or operator.</p>\n\n<ul>\n\t<li>For example, do not use <code>pow(x, 0.5)</code> in c++ or <code>x ** 0.5</code> in python.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 4\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The square root of 4 is 2, so we return 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 8\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= x &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "70": {"__typename": "QuestionLightNode", "acRate": 0.5449007618389716, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "70", "isFavor": false, "solutionNum": 7296, "title": "Climbing Stairs", "titleCn": "爬楼梯", "titleSlug": "climbing-stairs", "topicTags": [{"id": "vhos7", "name": "Memoization", "slug": "memoization", "nameTranslated": "记忆化搜索", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 195, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>假设你正在爬楼梯。需要 <code>n</code>&nbsp;阶你才能到达楼顶。</p>\n\n<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>有两种方法可以爬到楼顶。\n1. 1 阶 + 1 阶\n2. 2 阶</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>有三种方法可以爬到楼顶。\n1. 1 阶 + 1 阶 + 1 阶\n2. 1 阶 + 2 阶\n3. 2 阶 + 1 阶\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 45</code></li>\n</ul>\n", "en": "<p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p>\n\n<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 45</code></li>\n</ul>\n"}}, "71": {"__typename": "QuestionLightNode", "acRate": 0.44821439863412166, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "71", "isFavor": false, "solutionNum": 1872, "title": "Simplify Path", "titleCn": "简化路径", "titleSlug": "simplify-path", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 72, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 <strong>绝对路径 </strong>（以 <code>'/'</code> 开头），请你将其转化为更加简洁的规范路径。</p>\n\n<p class=\"MachineTrans-lang-zh-CN\">在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>'//'</code>）都被视为单个斜杠 <code>'/'</code> 。 对于此问题，任何其他格式的点（例如，<code>'...'</code>）均被视为文件/目录名称。</p>\n\n<p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p>\n\n<ul>\n\t<li>始终以斜杠 <code>'/'</code> 开头。</li>\n\t<li>两个目录名之间必须只有一个斜杠 <code>'/'</code> 。</li>\n\t<li>最后一个目录名（如果存在）<strong>不能 </strong>以 <code>'/'</code> 结尾。</li>\n\t<li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>'.'</code> 或 <code>'..'</code>）。</li>\n</ul>\n\n<p>返回简化后得到的 <strong>规范路径</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>path = \"/home/\"\n<strong>输出：</strong>\"/home\"\n<strong>解释：</strong>注意，最后一个目录名后面没有斜杠。 </pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>path = \"/../\"\n<strong>输出：</strong>\"/\"\n<strong>解释：</strong>从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>path = \"/home//foo/\"\n<strong>输出：</strong>\"/home/foo\"\n<strong>解释：</strong>在规范路径中，多个连续斜杠需要用一个斜杠替换。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>path = \"/a/./b/../../c/\"\n<strong>输出：</strong>\"/c\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= path.length <= 3000</code></li>\n\t<li><code>path</code> 由英文字母，数字，<code>'.'</code>，<code>'/'</code> 或 <code>'_'</code> 组成。</li>\n\t<li><code>path</code> 是一个有效的 Unix 风格绝对路径。</li>\n</ul>\n", "en": "<p>Given a string <code>path</code>, which is an <strong>absolute path</strong> (starting with a slash <code>&#39;/&#39;</code>) to a file or directory in a Unix-style file system, convert it to the simplified <strong>canonical path</strong>.</p>\n\n<p>In a Unix-style file system, a period <code>&#39;.&#39;</code> refers to the current directory, a double period <code>&#39;..&#39;</code> refers to the directory up a level, and any multiple consecutive slashes (i.e. <code>&#39;//&#39;</code>) are treated as a single slash <code>&#39;/&#39;</code>. For this problem, any other format of periods such as <code>&#39;...&#39;</code> are treated as file/directory names.</p>\n\n<p>The <strong>canonical path</strong> should have the following format:</p>\n\n<ul>\n\t<li>The path starts with a single slash <code>&#39;/&#39;</code>.</li>\n\t<li>Any two directories are separated by a single slash <code>&#39;/&#39;</code>.</li>\n\t<li>The path does not end with a trailing <code>&#39;/&#39;</code>.</li>\n\t<li>The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period <code>&#39;.&#39;</code> or double period <code>&#39;..&#39;</code>)</li>\n</ul>\n\n<p>Return <em>the simplified <strong>canonical path</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> path = &quot;/home/&quot;\n<strong>Output:</strong> &quot;/home&quot;\n<strong>Explanation:</strong> Note that there is no trailing slash after the last directory name.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> path = &quot;/../&quot;\n<strong>Output:</strong> &quot;/&quot;\n<strong>Explanation:</strong> Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> path = &quot;/home//foo/&quot;\n<strong>Output:</strong> &quot;/home/foo&quot;\n<strong>Explanation:</strong> In the canonical path, multiple consecutive slashes are replaced by a single one.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= path.length &lt;= 3000</code></li>\n\t<li><code>path</code> consists of English letters, digits, period <code>&#39;.&#39;</code>, slash <code>&#39;/&#39;</code> or <code>&#39;_&#39;</code>.</li>\n\t<li><code>path</code> is a valid absolute Unix path.</li>\n</ul>\n"}}, "72": {"__typename": "QuestionLightNode", "acRate": 0.6282719229178065, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "72", "isFavor": false, "solutionNum": 3447, "title": "Edit Distance", "titleCn": "编辑距离", "titleSlug": "edit-distance", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 126, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个单词&nbsp;<code>word1</code> 和&nbsp;<code>word2</code>， <em>请返回将&nbsp;<code>word1</code>&nbsp;转换成&nbsp;<code>word2</code> 所使用的最少操作数</em> &nbsp;。</p>\n\n<p>你可以对一个单词进行如下三种操作：</p>\n\n<ul>\n\t<li>插入一个字符</li>\n\t<li>删除一个字符</li>\n\t<li>替换一个字符</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"horse\", word2 = \"ros\"\n<strong>输出：</strong>3\n<strong>解释：</strong>\nhorse -&gt; rorse (将 'h' 替换为 'r')\nrorse -&gt; rose (删除 'r')\nrose -&gt; ros (删除 'e')\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word1 = \"intention\", word2 = \"execution\"\n<strong>输出：</strong>5\n<strong>解释：</strong>\nintention -&gt; inention (删除 't')\ninention -&gt; enention (将 'i' 替换为 'e')\nenention -&gt; exention (将 'n' 替换为 'x')\nexention -&gt; exection (将 'n' 替换为 'c')\nexection -&gt; execution (插入 'u')\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>\n\t<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>\n</ul>\n", "en": "<p>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of operations required to convert <code>word1</code> to <code>word2</code></em>.</p>\n\n<p>You have the following three operations permitted on a word:</p>\n\n<ul>\n\t<li>Insert a character</li>\n\t<li>Delete a character</li>\n\t<li>Replace a character</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;horse&quot;, word2 = &quot;ros&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> \nhorse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)\nrorse -&gt; rose (remove &#39;r&#39;)\nrose -&gt; ros (remove &#39;e&#39;)\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;intention&quot;, word2 = &quot;execution&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> \nintention -&gt; inention (remove &#39;t&#39;)\ninention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)\nenention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)\nexention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)\nexection -&gt; execution (insert &#39;u&#39;)\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>\n\t<li><code>word1</code> and <code>word2</code> consist of lowercase English letters.</li>\n</ul>\n"}}, "73": {"__typename": "QuestionLightNode", "acRate": 0.662336439623178, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "73", "isFavor": false, "solutionNum": 2246, "title": "Set Matrix Zeroes", "titleCn": "矩阵置零", "titleSlug": "set-matrix-zeroes", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 58, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个&nbsp;<code><em>m</em> x <em>n</em></code> 的矩阵，如果一个元素为 <strong>0 </strong>，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href=\"http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地</a></strong> 算法<strong>。</strong></p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg\" style=\"width: 450px; height: 169px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>输出：</strong>[[1,0,1],[0,0,0],[1,0,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg\" style=\"width: 450px; height: 137px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n<strong>输出：</strong>[[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[0].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>一个直观的解决方案是使用 &nbsp;<code>O(<em>m</em><em>n</em>)</code>&nbsp;的额外空间，但这并不是一个好的解决方案。</li>\n\t<li>一个简单的改进方案是使用 <code>O(<em>m</em>&nbsp;+&nbsp;<em>n</em>)</code> 的额外空间，但这仍然不是最好的解决方案。</li>\n\t<li>你能想出一个仅使用常量空间的解决方案吗？</li>\n</ul>\n", "en": "<p>Given an <code>m x n</code> integer matrix <code>matrix</code>, if an element is <code>0</code>, set its entire row and column to <code>0</code>&#39;s.</p>\n\n<p>You must do it <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in place</a>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg\" style=\"width: 450px; height: 169px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>Output:</strong> [[1,0,1],[0,0,0],[1,0,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg\" style=\"width: 450px; height: 137px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n<strong>Output:</strong> [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[0].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>A straightforward solution using <code>O(mn)</code> space is probably a bad idea.</li>\n\t<li>A simple improvement uses <code>O(m + n)</code> space, but still not the best solution.</li>\n\t<li>Could you devise a constant space solution?</li>\n</ul>\n"}}, "74": {"__typename": "QuestionLightNode", "acRate": 0.49531813511172, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "74", "isFavor": false, "solutionNum": 3344, "title": "Search a 2D Matrix", "titleCn": "搜索二维矩阵", "titleSlug": "search-a-2d-matrix", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 78, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>\n\n<ul>\n\t<li>每行中的整数从左到右按非严格递增顺序排列。</li>\n\t<li>每行的第一个整数大于前一行的最后一个整数。</li>\n</ul>\n\n<p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= matrix[i][j], target &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>You are given an <code>m x n</code> integer matrix <code>matrix</code> with the following two properties:</p>\n\n<ul>\n\t<li>Each row is sorted in non-decreasing order.</li>\n\t<li>The first integer of each row is greater than the last integer of the previous row.</li>\n</ul>\n\n<p>Given an integer <code>target</code>, return <code>true</code> <em>if</em> <code>target</code> <em>is in</em> <code>matrix</code> <em>or</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>You must write a solution in <code>O(log(m * n))</code> time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= matrix[i][j], target &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "75": {"__typename": "QuestionLightNode", "acRate": 0.6112206043308454, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "75", "isFavor": false, "solutionNum": 3986, "title": "Sort Colors", "titleCn": "颜色分类", "titleSlug": "sort-colors", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 83, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个包含红色、白色和蓝色、共&nbsp;<code>n</code><em> </em>个元素的数组<meta charset=\"UTF-8\" />&nbsp;<code>nums</code>&nbsp;，<strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>\n\n<p>我们使用整数 <code>0</code>、&nbsp;<code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>\n\n<ul>\n</ul>\n\n<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,0,2,1,1,0]\n<strong>输出：</strong>[0,0,1,1,2,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,0,1]\n<strong>输出：</strong>[0,1,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 300</code></li>\n\t<li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>\n</ul>\n", "en": "<p>Given an array <code>nums</code> with <code>n</code> objects colored red, white, or blue, sort them <strong><a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a> </strong>so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p>\n\n<p>We will use the integers <code>0</code>, <code>1</code>, and <code>2</code> to represent the color red, white, and blue, respectively.</p>\n\n<p>You must solve this problem without using the library&#39;s sort function.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,0,2,1,1,0]\n<strong>Output:</strong> [0,0,1,1,2,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,0,1]\n<strong>Output:</strong> [0,1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 300</code></li>\n\t<li><code>nums[i]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong>&nbsp;Could you come up with a one-pass algorithm using only&nbsp;constant extra space?</p>\n"}}, "76": {"__typename": "QuestionLightNode", "acRate": 0.4563573633617229, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "76", "isFavor": false, "solutionNum": 4044, "title": "Minimum Window Substring", "titleCn": "最小覆盖子串", "titleSlug": "minimum-window-substring", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 89, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>\"\"</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>\n\t<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ADOBECODEBANC\", t = \"ABC\"\n<strong>输出：</strong>\"BANC\"\n<strong>解释：</strong>最小覆盖子串 \"BANC\" 包含来自字符串 t 的 'A'、'B' 和 'C'。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a\", t = \"a\"\n<strong>输出：</strong>\"a\"\n<strong>解释：</strong>整个字符串 s 是最小覆盖子串。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"a\", t = \"aa\"\n<strong>输出:</strong> \"\"\n<strong>解释:</strong> t 中两个字符 'a' 均应包含在 s 的子串中，\n因此没有符合条件的子字符串，返回空字符串。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code><sup>m == s.length</sup></code></li>\n\t<li><code><sup>n == t.length</sup></code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>进阶：</strong>你能设计一个在 <code>o(m+n)</code> 时间内解决此问题的算法吗？", "en": "<p>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window</strong></em> <span data-keyword=\"substring-nonempty\"><strong><em>substring</em></strong></span><em> of </em><code>s</code><em> such that every character in </em><code>t</code><em> (<strong>including duplicates</strong>) is included in the window</em>. If there is no such substring, return <em>the empty string </em><code>&quot;&quot;</code>.</p>\n\n<p>The testcases will be generated such that the answer is <strong>unique</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;\n<strong>Output:</strong> &quot;BANC&quot;\n<strong>Explanation:</strong> The minimum window substring &quot;BANC&quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;, t = &quot;a&quot;\n<strong>Output:</strong> &quot;a&quot;\n<strong>Explanation:</strong> The entire string s is the minimum window.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;, t = &quot;aa&quot;\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> Both &#39;a&#39;s from t must be included in the window.\nSince the largest window of s only has one &#39;a&#39;, return empty string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == s.length</code></li>\n\t<li><code>n == t.length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you find an algorithm that runs in <code>O(m + n)</code> time?</p>\n"}}, "77": {"__typename": "QuestionLightNode", "acRate": 0.7692943382891351, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "77", "isFavor": false, "solutionNum": 3290, "title": "Combinations", "titleCn": "组合", "titleSlug": "combinations", "topicTags": [{"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 50, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>\n\n<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4, k = 2\n<strong>输出：</strong>\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, k = 1\n<strong>输出：</strong>[[1]]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 20</code></li>\n\t<li><code>1 <= k <= n</code></li>\n</ul>\n", "en": "<p>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers chosen from the range</em> <code>[1, n]</code>.</p>\n\n<p>You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, k = 2\n<strong>Output:</strong> [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n<strong>Explanation:</strong> There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, k = 1\n<strong>Output:</strong> [[1]]\n<strong>Explanation:</strong> There is 1 choose 1 = 1 total combination.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n</ul>\n"}}, "78": {"__typename": "QuestionLightNode", "acRate": 0.8125401922480882, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "78", "isFavor": false, "solutionNum": 4788, "title": "Subsets", "titleCn": "子集", "titleSlug": "subsets", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 100, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组&nbsp;<code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的<span data-keyword=\"subset\">子集</span>（幂集）。</p>\n\n<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[[],[0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible</em> <span data-keyword=\"subset\"><em>subsets</em></span> <em>(the power set)</em>.</p>\n\n<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0]\n<strong>Output:</strong> [[],[0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li>All the numbers of&nbsp;<code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n"}}, "79": {"__typename": "QuestionLightNode", "acRate": 0.46842348699581354, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "79", "isFavor": false, "solutionNum": 2942, "title": "Word Search", "titleCn": "单词搜索", "titleSlug": "word-search", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 88, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/word3.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n = board[i].length</code></li>\n\t<li><code>1 <= m, n <= 6</code></li>\n\t<li><code>1 <= word.length <= 15</code></li>\n\t<li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你可以使用搜索剪枝的技术来优化解决方案，使其在 <code>board</code> 更大的情况下可以更快解决问题？</p>\n", "en": "<p>Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.</p>\n\n<p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/word3.jpg\" style=\"width: 322px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n = board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 6</code></li>\n\t<li><code>1 &lt;= word.length &lt;= 15</code></li>\n\t<li><code>board</code> and <code>word</code> consists of only lowercase and uppercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you use search pruning to make your solution faster with a larger <code>board</code>?</p>\n"}}, "80": {"__typename": "QuestionLightNode", "acRate": 0.616461627071698, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "80", "isFavor": false, "solutionNum": 2834, "title": "Remove Duplicates from Sorted Array II", "titleCn": "删除有序数组中的重复项 II", "titleSlug": "remove-duplicates-from-sorted-array-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 36, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个有序数组 <code>nums</code> ，请你<strong><a href=\"http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\"> 原地</a></strong> 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p>\n\n<p>不要使用额外的数组空间，你必须在 <strong><a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\" target=\"_blank\">原地 </a>修改输入数组 </strong>并在使用 O(1) 额外空间的条件下完成。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>说明：</strong></p>\n\n<p>为什么返回数值是整数，但输出的答案是数组呢？</p>\n\n<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>\n\n<p>你可以想象内部操作如下:</p>\n\n<pre>\n// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中<strong> 该长度范围内</strong> 的所有元素。\nfor (int i = 0; i &lt; len; i++) {\n&nbsp; &nbsp; print(nums[i]);\n}\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,2,2,3]\n<strong>输出：</strong>5, nums = [1,1,2,2,3]\n<strong>解释：</strong>函数应返回新长度 length = <strong><code>5</code></strong>, 并且原数组的前五个元素被修改为 <strong><code>1, 1, 2, 2, 3</code></strong>。 不需要考虑数组中超出新长度后面的元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,0,1,1,1,1,2,3,3]\n<strong>输出：</strong>7, nums = [0,0,1,1,2,3,3]\n<strong>解释：</strong>函数应返回新长度 length = <strong><code>7</code></strong>, 并且原数组的前七个元素被修改为&nbsp;<strong><code>0, 0, 1, 1, 2, 3, 3</code></strong>。不需要考虑数组中超出新长度后面的元素。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 已按升序排列</li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove some duplicates <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\"><strong>in-place</strong></a> such that each unique element appears <strong>at most twice</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>.</p>\n\n<p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the <strong>first part</strong> of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code>&nbsp;should hold the final result. It does not matter what you leave beyond the first&nbsp;<code>k</code>&nbsp;elements.</p>\n\n<p>Return <code>k</code><em> after placing the final result in the first </em><code>k</code><em> slots of </em><code>nums</code>.</p>\n\n<p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a></strong> with O(1) extra memory.</p>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The judge will test your solution with the following code:</p>\n\n<pre>\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i &lt; k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n</pre>\n\n<p>If all assertions pass, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1,2,2,3]\n<strong>Output:</strong> 5, nums = [1,1,2,2,3,_]\n<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,1,1,1,1,2,3,3]\n<strong>Output:</strong> 7, nums = [0,0,1,1,2,3,3,_,_]\n<strong>Explanation:</strong> Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n"}}, "81": {"__typename": "QuestionLightNode", "acRate": 0.410453269784887, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "81", "isFavor": false, "solutionNum": 1569, "title": "Search in Rotated Sorted Array II", "titleCn": "搜索旋转排序数组 II", "titleSlug": "search-in-rotated-sorted-array-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 46, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p>\n\n<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转 </strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 <code>5</code> 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p>\n\n<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>你必须尽可能减少整个操作步骤。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2<code>,5,6,0,0,1,2]</code>, target = 0\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2<code>,5,6,0,0,1,2]</code>, target = 3\n<strong>输出：</strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>这是 <a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/\">搜索旋转排序数组</a>&nbsp;的延伸题目，本题中的&nbsp;<code>nums</code>&nbsp; 可能包含重复元素。</li>\n\t<li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</li>\n</ul>\n\n<p>&nbsp;</p>\n", "en": "<p>There is an integer array <code>nums</code> sorted in non-decreasing order (not necessarily with <strong>distinct</strong> values).</p>\n\n<p>Before being passed to your function, <code>nums</code> is <strong>rotated</strong> at an unknown pivot index <code>k</code> (<code>0 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,4,4,5,6,6,7]</code> might be rotated at pivot index <code>5</code> and become <code>[4,5,6,6,7,0,1,2,4,4]</code>.</p>\n\n<p>Given the array <code>nums</code> <strong>after</strong> the rotation and an integer <code>target</code>, return <code>true</code><em> if </em><code>target</code><em> is in </em><code>nums</code><em>, or </em><code>false</code><em> if it is not in </em><code>nums</code><em>.</em></p>\n\n<p>You must decrease the overall operation steps as much as possible.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [2,5,6,0,0,1,2], target = 0\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [2,5,6,0,0,1,2], target = 3\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is guaranteed to be rotated at some pivot.</li>\n\t<li><code>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> This problem is similar to&nbsp;<a href=\"/problems/search-in-rotated-sorted-array/description/\" target=\"_blank\">Search in Rotated Sorted Array</a>, but&nbsp;<code>nums</code> may contain <strong>duplicates</strong>. Would this affect the runtime complexity? How and why?</p>\n"}}, "82": {"__typename": "QuestionLightNode", "acRate": 0.5428794417987717, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "82", "isFavor": false, "solutionNum": 3233, "title": "Remove Duplicates from Sorted List II", "titleCn": "删除排序链表中的重复元素 II", "titleSlug": "remove-duplicates-from-sorted-list-ii", "topicTags": [{"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 68, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个已排序的链表的头&nbsp;<code>head</code> ，&nbsp;<em>删除原始链表中所有重复数字的节点，只留下不同的数字</em>&nbsp;。返回 <em>已排序的链表</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg\" style=\"height: 142px; width: 500px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,3,4,4,5]\n<strong>输出：</strong>[1,2,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg\" style=\"height: 164px; width: 400px;\" />\n<pre>\n<strong>输入：</strong>head = [1,1,1,2,3]\n<strong>输出：</strong>[2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li>题目数据保证链表已经按升序 <strong>排列</strong></li>\n</ul>\n", "en": "<p>Given the <code>head</code> of a sorted linked list, <em>delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list</em>. Return <em>the linked list <strong>sorted</strong> as well</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg\" style=\"width: 500px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,3,4,4,5]\n<strong>Output:</strong> [1,2,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg\" style=\"width: 500px; height: 205px;\" />\n<pre>\n<strong>Input:</strong> head = [1,1,1,2,3]\n<strong>Output:</strong> [2,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 300]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li>The list is guaranteed to be <strong>sorted</strong> in ascending order.</li>\n</ul>\n"}}, "83": {"__typename": "QuestionLightNode", "acRate": 0.5378392707094232, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "83", "isFavor": false, "solutionNum": 4069, "title": "Remove Duplicates from Sorted List", "titleCn": "删除排序链表中的重复元素", "titleSlug": "remove-duplicates-from-sorted-list", "topicTags": [{"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 69, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个已排序的链表的头<meta charset=\"UTF-8\" />&nbsp;<code>head</code>&nbsp;，&nbsp;<em>删除所有重复的元素，使每个元素只出现一次</em>&nbsp;。返回 <em>已排序的链表</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/list1.jpg\" style=\"height: 160px; width: 200px;\" />\n<pre>\n<strong>输入：</strong>head = [1,1,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/list2.jpg\" style=\"height: 123px; width: 300px;\" />\n<pre>\n<strong>输入：</strong>head = [1,1,2,3,3]\n<strong>输出：</strong>[1,2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li>题目数据保证链表已经按升序 <strong>排列</strong></li>\n</ul>\n", "en": "<p>Given the <code>head</code> of a sorted linked list, <em>delete all duplicates such that each element appears only once</em>. Return <em>the linked list <strong>sorted</strong> as well</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/list1.jpg\" style=\"width: 302px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> head = [1,1,2]\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/list2.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,1,2,3,3]\n<strong>Output:</strong> [1,2,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 300]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li>The list is guaranteed to be <strong>sorted</strong> in ascending order.</li>\n</ul>\n"}}, "84": {"__typename": "QuestionLightNode", "acRate": 0.45648879700508466, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "84", "isFavor": false, "solutionNum": 2254, "title": "Largest Rectangle in Histogram", "titleCn": "柱状图中最大的矩形", "titleSlug": "largest-rectangle-in-histogram", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "xeyj5r5", "name": "Monotonic Stack", "slug": "monotonic-stack", "nameTranslated": "单调栈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 84, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>\n\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>heights = [2,1,5,6,2,3]\n<strong>输出：</strong>10\n<strong>解释：</strong>最大的矩形为图中红色区域，面积为 10\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong> heights = [2,4]\n<b>输出：</b> 4</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= heights.length <=10<sup>5</sup></code></li>\n\t<li><code>0 <= heights[i] <= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given an array of integers <code>heights</code> representing the histogram&#39;s bar height where the width of each bar is <code>1</code>, return <em>the area of the largest rectangle in the histogram</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\" style=\"width: 522px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> heights = [2,1,5,6,2,3]\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg\" style=\"width: 202px; height: 362px;\" />\n<pre>\n<strong>Input:</strong> heights = [2,4]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= heights.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= heights[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "85": {"__typename": "QuestionLightNode", "acRate": 0.5508336859923826, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "85", "isFavor": false, "solutionNum": 1279, "title": "Maximal Rectangle", "titleCn": "最大矩形", "titleSlug": "maximal-rectangle", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}, {"id": "xeyj5r5", "name": "Monotonic Stack", "slug": "monotonic-stack", "nameTranslated": "单调栈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 91, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个仅包含&nbsp;<code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg\" style=\"width: 402px; height: 322px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\n<strong>输出：</strong>6\n<strong>解释：</strong>最大矩形如上图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[\"0\"]]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[\"1\"]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>rows == matrix.length</code></li>\n\t<li><code>cols == matrix[0].length</code></li>\n\t<li><code>1 &lt;= row, cols &lt;= 200</code></li>\n\t<li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n", "en": "<p>Given a <code>rows x cols</code>&nbsp;binary <code>matrix</code> filled with <code>0</code>&#39;s and <code>1</code>&#39;s, find the largest rectangle containing only <code>1</code>&#39;s and return <em>its area</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg\" style=\"width: 402px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The maximal rectangle is shown in the above picture.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[&quot;0&quot;]]\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[&quot;1&quot;]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>rows == matrix.length</code></li>\n\t<li><code>cols == matrix[i].length</code></li>\n\t<li><code>1 &lt;= row, cols &lt;= 200</code></li>\n\t<li><code>matrix[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n"}}, "86": {"__typename": "QuestionLightNode", "acRate": 0.645792614231047, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "86", "isFavor": false, "solutionNum": 2431, "title": "Partition List", "titleCn": "分隔链表", "titleSlug": "partition-list", "topicTags": [{"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 61, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个链表的头节点 <code>head</code> 和一个特定值<em> </em><code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p>\n\n<p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/partition.jpg\" style=\"width: 662px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,4,3,2,5,2], x = 3\n<strong>输出</strong>：[1,2,2,4,3,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [2,1], x = 2\n<strong>输出</strong>：[1,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目在范围 <code>[0, 200]</code> 内</li>\n\t<li><code>-100 <= Node.val <= 100</code></li>\n\t<li><code>-200 <= x <= 200</code></li>\n</ul>\n", "en": "<p>Given the <code>head</code> of a linked list and a value <code>x</code>, partition it such that all nodes <strong>less than</strong> <code>x</code> come before nodes <strong>greater than or equal</strong> to <code>x</code>.</p>\n\n<p>You should <strong>preserve</strong> the original relative order of the nodes in each of the two partitions.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/04/partition.jpg\" style=\"width: 662px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,4,3,2,5,2], x = 3\n<strong>Output:</strong> [1,2,2,4,3,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [2,1], x = 2\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 200]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>-200 &lt;= x &lt;= 200</code></li>\n</ul>\n"}}, "87": {"__typename": "QuestionLightNode", "acRate": 0.47075804153857687, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "87", "isFavor": false, "solutionNum": 474, "title": "Scramble String", "titleCn": "扰乱字符串", "titleSlug": "scramble-string", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 24, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "使用下面描述的算法可以扰乱字符串 <code>s</code> 得到字符串 <code>t</code> ：\n<ol>\n\t<li>如果字符串的长度为 1 ，算法停止</li>\n\t<li>如果字符串的长度 > 1 ，执行下述步骤：\n\t<ul>\n\t\t<li>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 <code>s</code> ，则可以将其分成两个子字符串 <code>x</code> 和 <code>y</code> ，且满足 <code>s = x + y</code> 。</li>\n\t\t<li><strong>随机</strong> 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，<code>s</code> 可能是 <code>s = x + y</code> 或者 <code>s = y + x</code> 。</li>\n\t\t<li>在 <code>x</code> 和 <code>y</code> 这两个子字符串上继续从步骤 1 开始递归执行此算法。</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>给你两个 <strong>长度相等</strong> 的字符串 <code>s1</code><em> </em>和 <code>s2</code>，判断 <code>s2</code><em> </em>是否是 <code>s1</code><em> </em>的扰乱字符串。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"great\", s2 = \"rgeat\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s1 上可能发生的一种情形是：\n\"great\" --> \"gr/eat\" // 在一个随机下标处分割得到两个子字符串\n\"gr/eat\" --> \"gr/eat\" // 随机决定：「保持这两个子字符串的顺序不变」\n\"gr/eat\" --> \"g/r / e/at\" // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割\n\"g/r / e/at\" --> \"r/g / e/at\" // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // 继续递归执行此算法，将 \"at\" 分割得到 \"a/t\"\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // 随机决定：「保持这两个子字符串的顺序不变」\n算法终止，结果字符串和 s2 相同，都是 \"rgeat\"\n这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"abcde\", s2 = \"caebd\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"a\", s2 = \"a\"\n<strong>输出：</strong>true\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>s1.length == s2.length</code></li>\n\t<li><code>1 <= s1.length <= 30</code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 由小写英文字母组成</li>\n</ul>\n", "en": "<p>We can scramble a string s to get a string t using the following algorithm:</p>\n\n<ol>\n\t<li>If the length of the string is 1, stop.</li>\n\t<li>If the length of the string is &gt; 1, do the following:\n\t<ul>\n\t\t<li>Split the string into two non-empty substrings at a random index, i.e., if the string is <code>s</code>, divide it to <code>x</code> and <code>y</code> where <code>s = x + y</code>.</li>\n\t\t<li><strong>Randomly</strong>&nbsp;decide to swap the two substrings or to keep them in the same order. i.e., after this step, <code>s</code> may become <code>s = x + y</code> or <code>s = y + x</code>.</li>\n\t\t<li>Apply step 1 recursively on each of the two substrings <code>x</code> and <code>y</code>.</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>Given two strings <code>s1</code> and <code>s2</code> of <strong>the same length</strong>, return <code>true</code> if <code>s2</code> is a scrambled string of <code>s1</code>, otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> One possible scenario applied on s1 is:\n&quot;great&quot; --&gt; &quot;gr/eat&quot; // divide at random index.\n&quot;gr/eat&quot; --&gt; &quot;gr/eat&quot; // random decision is not to swap the two substrings and keep them in order.\n&quot;gr/eat&quot; --&gt; &quot;g/r / e/at&quot; // apply the same algorithm recursively on both substrings. divide at random index each of them.\n&quot;g/r / e/at&quot; --&gt; &quot;r/g / e/at&quot; // random decision was to swap the first substring and to keep the second substring in the same order.\n&quot;r/g / e/at&quot; --&gt; &quot;r/g / e/ a/t&quot; // again apply the algorithm recursively, divide &quot;at&quot; to &quot;a/t&quot;.\n&quot;r/g / e/ a/t&quot; --&gt; &quot;r/g / e/ a/t&quot; // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is &quot;rgeat&quot; which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;a&quot;, s2 = &quot;a&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>s1.length == s2.length</code></li>\n\t<li><code>1 &lt;= s1.length &lt;= 30</code></li>\n\t<li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li>\n</ul>\n"}}, "88": {"__typename": "QuestionLightNode", "acRate": 0.5344938651958936, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "88", "isFavor": false, "solutionNum": 7685, "title": "Merge Sorted Array", "titleCn": "合并两个有序数组", "titleSlug": "merge-sorted-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 158, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组&nbsp;<code>nums1</code><em> </em>和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p>\n\n<p>请你 <strong>合并</strong> <code>nums2</code><em> </em>到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p>\n\n<p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n<strong>输出：</strong>[1,2,2,3,5,6]\n<strong>解释：</strong>需要合并 [1,2,3] 和 [2,5,6] 。\n合并结果是 [<em><strong>1</strong></em>,<em><strong>2</strong></em>,2,<em><strong>3</strong></em>,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1], m = 1, nums2 = [], n = 0\n<strong>输出：</strong>[1]\n<strong>解释：</strong>需要合并 [1] 和 [] 。\n合并结果是 [1] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [0], m = 0, nums2 = [1], n = 1\n<strong>输出：</strong>[1]\n<strong>解释：</strong>需要合并的数组是 [] 和 [1] 。\n合并结果是 [1] 。\n注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m + n</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计实现一个时间复杂度为 <code>O(m + n)</code> 的算法解决此问题吗？</p>\n", "en": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <strong>non-decreasing order</strong>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p>\n\n<p><strong>Merge</strong> <code>nums1</code> and <code>nums2</code> into a single array sorted in <strong>non-decreasing order</strong>.</p>\n\n<p>The final sorted array should not be returned by the function, but instead be <em>stored inside the array </em><code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n<strong>Output:</strong> [1,2,2,3,5,6]\n<strong>Explanation:</strong> The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [<u>1</u>,<u>2</u>,2,<u>3</u>,5,6] with the underlined elements coming from nums1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1], m = 1, nums2 = [], n = 0\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [0], m = 0, nums2 = [1], n = 1\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m + n</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up: </strong>Can you come up with an algorithm that runs in <code>O(m + n)</code> time?</p>\n"}}, "89": {"__typename": "QuestionLightNode", "acRate": 0.754129381388604, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "89", "isFavor": false, "solutionNum": 949, "title": "Gray Code", "titleCn": "格雷编码", "titleSlug": "gray-code", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 38, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<strong>n 位格雷码序列</strong> 是一个由 <code>2<sup>n</sup></code> 个整数组成的序列，其中：\n<ul>\n\t<li>每个整数都在范围 <code>[0, 2<sup>n</sup> - 1]</code> 内（含 <code>0</code> 和 <code>2<sup>n</sup> - 1</code>）</li>\n\t<li>第一个整数是 <code>0</code></li>\n\t<li>一个整数在序列中出现 <strong>不超过一次</strong></li>\n\t<li>每对 <strong>相邻</strong> 整数的二进制表示 <strong>恰好一位不同</strong> ，且</li>\n\t<li><strong>第一个</strong> 和 <strong>最后一个</strong> 整数的二进制表示 <strong>恰好一位不同</strong></li>\n</ul>\n\n<p>给你一个整数 <code>n</code> ，返回任一有效的 <strong>n 位格雷码序列</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>[0,1,3,2]\n<strong>解释：</strong>\n[0,1,3,2] 的二进制表示是 [00,01,11,10] 。\n- 0<strong><em>0</em></strong> 和 0<em><strong>1</strong></em> 有一位不同\n- <em><strong>0</strong></em>1 和 <em><strong>1</strong></em>1 有一位不同\n- 1<em><strong>1</strong></em> 和 1<em><strong>0</strong></em> 有一位不同\n- <em><strong>1</strong></em>0 和 <em><strong>0</strong></em>0 有一位不同\n[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。\n- <em><strong>0</strong></em>0 和 <em><strong>1</strong></em>0 有一位不同\n- 1<em><strong>0</strong></em> 和 1<em><strong>1</strong></em> 有一位不同\n- <em><strong>1</strong></em>1 和 <em><strong>0</strong></em>1 有一位不同\n- 0<em><strong>1</strong></em> 和 0<em><strong>0</strong></em> 有一位不同\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>[0,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 16</code></li>\n</ul>\n", "en": "<p>An <strong>n-bit gray code sequence</strong> is a sequence of <code>2<sup>n</sup></code> integers where:</p>\n\n<ul>\n\t<li>Every integer is in the <strong>inclusive</strong> range <code>[0, 2<sup>n</sup> - 1]</code>,</li>\n\t<li>The first integer is <code>0</code>,</li>\n\t<li>An integer appears <strong>no more than once</strong> in the sequence,</li>\n\t<li>The binary representation of every pair of <strong>adjacent</strong> integers differs by <strong>exactly one bit</strong>, and</li>\n\t<li>The binary representation of the <strong>first</strong> and <strong>last</strong> integers differs by <strong>exactly one bit</strong>.</li>\n</ul>\n\n<p>Given an integer <code>n</code>, return <em>any valid <strong>n-bit gray code sequence</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> [0,1,3,2]\n<strong>Explanation:</strong>\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 0<u>0</u> and 0<u>1</u> differ by one bit\n- <u>0</u>1 and <u>1</u>1 differ by one bit\n- 1<u>1</u> and 1<u>0</u> differ by one bit\n- <u>1</u>0 and <u>0</u>0 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- <u>0</u>0 and <u>1</u>0 differ by one bit\n- 1<u>0</u> and 1<u>1</u> differ by one bit\n- <u>1</u>1 and <u>0</u>1 differ by one bit\n- 0<u>1</u> and 0<u>0</u> differ by one bit\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 16</code></li>\n</ul>\n"}}, "90": {"__typename": "QuestionLightNode", "acRate": 0.6339582342498663, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "90", "isFavor": false, "solutionNum": 2515, "title": "Subsets II", "titleCn": "子集 II", "titleSlug": "subsets-ii", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 47, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的 <span data-keyword=\"subset\">子集</span>（幂集）。</p>\n\n<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2]\n<strong>输出：</strong>[[],[1],[1,2],[1,2,2],[2],[2,2]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>[[],[0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>Given an integer array <code>nums</code> that may contain duplicates, return <em>all possible</em> <span data-keyword=\"subset\"><em>subsets</em></span><em> (the power set)</em>.</p>\n\n<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,2]\n<strong>Output:</strong> [[],[1],[1,2],[1,2,2],[2],[2,2]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0]\n<strong>Output:</strong> [[],[0]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n</ul>\n"}}, "91": {"__typename": "QuestionLightNode", "acRate": 0.33612774049666927, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "91", "isFavor": false, "solutionNum": 2460, "title": "Decode Ways", "titleCn": "解码方法", "titleSlug": "decode-ways", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 90, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1604559404-lBlorc-https---i.forbesimg.com-media-lists-companies-jpmorgan-chase_416x416.jpg", "slug": "jpmorgan", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>一条包含字母&nbsp;<code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p>\n\n<pre>\n'A' -&gt; \"1\"\n'B' -&gt; \"2\"\n...\n'Z' -&gt; \"26\"</pre>\n\n<p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>\"11106\"</code> 可以映射为：</p>\n\n<ul>\n\t<li><code>\"AAJF\"</code> ，将消息分组为 <code>(1 1 10 6)</code></li>\n\t<li><code>\"KJF\"</code> ，将消息分组为 <code>(11 10 6)</code></li>\n</ul>\n\n<p>注意，消息不能分组为&nbsp; <code>(1 11 06)</code> ，因为 <code>\"06\"</code> 不能映射为 <code>\"F\"</code> ，这是由于 <code>\"6\"</code> 和 <code>\"06\"</code> 在映射中并不等价。</p>\n\n<p>给你一个只含数字的 <strong>非空 </strong>字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p>\n\n<p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"12\"\n<strong>输出：</strong>2\n<strong>解释：</strong>它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"226\"\n<strong>输出：</strong>3\n<strong>解释：</strong>它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"06\"\n<strong>输出：</strong>0\n<strong>解释：</strong>\"06\" 无法映射到 \"F\" ，因为存在前导零（\"6\" 和 \"06\" 并不等价）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 只包含数字，并且可能包含前导零。</li>\n</ul>\n", "en": "<p>A message containing letters from <code>A-Z</code> can be <strong>encoded</strong> into numbers using the following mapping:</p>\n\n<pre>\n&#39;A&#39; -&gt; &quot;1&quot;\n&#39;B&#39; -&gt; &quot;2&quot;\n...\n&#39;Z&#39; -&gt; &quot;26&quot;\n</pre>\n\n<p>To <strong>decode</strong> an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, <code>&quot;11106&quot;</code> can be mapped into:</p>\n\n<ul>\n\t<li><code>&quot;AAJF&quot;</code> with the grouping <code>(1 1 10 6)</code></li>\n\t<li><code>&quot;KJF&quot;</code> with the grouping <code>(11 10 6)</code></li>\n</ul>\n\n<p>Note that the grouping <code>(1 11 06)</code> is invalid because <code>&quot;06&quot;</code> cannot be mapped into <code>&#39;F&#39;</code> since <code>&quot;6&quot;</code> is different from <code>&quot;06&quot;</code>.</p>\n\n<p>Given a string <code>s</code> containing only digits, return <em>the <strong>number</strong> of ways to <strong>decode</strong> it</em>.</p>\n\n<p>The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;12&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> &quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;226&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> &quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;06&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> &quot;06&quot; cannot be mapped to &quot;F&quot; because of the leading zero (&quot;6&quot; is different from &quot;06&quot;).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> contains only digits and may contain leading zero(s).</li>\n</ul>\n"}}, "92": {"__typename": "QuestionLightNode", "acRate": 0.5610649064313094, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "92", "isFavor": false, "solutionNum": 4169, "title": "Reverse Linked List II", "titleCn": "反转链表 II", "titleSlug": "reverse-linked-list-ii", "topicTags": [{"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 107, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left <= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5], left = 2, right = 4\n<strong>输出：</strong>[1,4,3,2,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [5], left = 1, right = 1\n<strong>输出：</strong>[5]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数目为 <code>n</code></li>\n\t<li><code>1 <= n <= 500</code></li>\n\t<li><code>-500 <= Node.val <= 500</code></li>\n\t<li><code>1 <= left <= right <= n</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong> 你可以使用一趟扫描完成反转吗？</p>\n", "en": "<p>Given the <code>head</code> of a singly linked list and two integers <code>left</code> and <code>right</code> where <code>left &lt;= right</code>, reverse the nodes of the list from position <code>left</code> to position <code>right</code>, and return <em>the reversed list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5], left = 2, right = 4\n<strong>Output:</strong> [1,4,3,2,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [5], left = 1, right = 1\n<strong>Output:</strong> [5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is <code>n</code>.</li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>-500 &lt;= Node.val &lt;= 500</code></li>\n\t<li><code>1 &lt;= left &lt;= right &lt;= n</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you do it in one pass?"}}, "93": {"__typename": "QuestionLightNode", "acRate": 0.593031822235498, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "93", "isFavor": false, "solutionNum": 2813, "title": "Restore IP Addresses", "titleCn": "复原 IP 地址", "titleSlug": "restore-ip-addresses", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 80, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>'.'</code> 分隔。</p>\n\n<ul>\n\t<li>例如：<code>\"0.1.2.201\"</code> 和<code> \"192.168.1.1\"</code> 是 <strong>有效</strong> IP 地址，但是 <code>\"0.011.255.245\"</code>、<code>\"192.168.1.312\"</code> 和 <code>\"192.168@1.1\"</code> 是 <strong>无效</strong> IP 地址。</li>\n</ul>\n\n<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入&nbsp;<code>'.'</code> 来形成。你 <strong>不能</strong>&nbsp;重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"25525511135\"\n<strong>输出：</strong>[\"255.255.11.135\",\"255.255.111.35\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"0000\"\n<strong>输出：</strong>[\"0.0.0.0\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"101023\"\n<strong>输出：</strong>[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> 仅由数字组成</li>\n</ul>\n", "en": "<p>A <strong>valid IP address</strong> consists of exactly four integers separated by single dots. Each integer is between <code>0</code> and <code>255</code> (<strong>inclusive</strong>) and cannot have leading zeros.</p>\n\n<ul>\n\t<li>For example, <code>&quot;0.1.2.201&quot;</code> and <code>&quot;192.168.1.1&quot;</code> are <strong>valid</strong> IP addresses, but <code>&quot;0.011.255.245&quot;</code>, <code>&quot;192.168.1.312&quot;</code> and <code>&quot;192.168@1.1&quot;</code> are <strong>invalid</strong> IP addresses.</li>\n</ul>\n\n<p>Given a string <code>s</code> containing only digits, return <em>all possible valid IP addresses that can be formed by inserting dots into </em><code>s</code>. You are <strong>not</strong> allowed to reorder or remove any digits in <code>s</code>. You may return the valid IP addresses in <strong>any</strong> order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;25525511135&quot;\n<strong>Output:</strong> [&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;0000&quot;\n<strong>Output:</strong> [&quot;0.0.0.0&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;101023&quot;\n<strong>Output:</strong> [&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> consists of digits only.</li>\n</ul>\n"}}, "94": {"__typename": "QuestionLightNode", "acRate": 0.7671229712211702, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "94", "isFavor": false, "solutionNum": 4885, "title": "Binary Tree Inorder Traversal", "titleCn": "二叉树的中序遍历", "titleSlug": "binary-tree-inorder-traversal", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 89, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong>&nbsp;遍历</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" style=\"height: 200px; width: 125px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,2,3]\n<strong>输出：</strong>[1,3,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶:</strong>&nbsp;递归算法很简单，你可以通过迭代算法完成吗？</p>\n", "en": "<p>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" style=\"width: 125px; height: 200px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [1,3,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?"}}, "95": {"__typename": "QuestionLightNode", "acRate": 0.738900048350387, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "95", "isFavor": false, "solutionNum": 1136, "title": "Unique Binary Search Trees II", "titleCn": "不同的二叉搜索树 II", "titleSlug": "unique-binary-search-trees-ii", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 32, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong><em> </em>。可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p> </p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg\" style=\"width: 600px; height: 148px;\" />\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 8</code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>Given an integer <code>n</code>, return <em>all the structurally unique <strong>BST&#39;</strong>s (binary search trees), which has exactly </em><code>n</code><em> nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>. Return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg\" style=\"width: 600px; height: 148px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n"}}, "96": {"__typename": "QuestionLightNode", "acRate": 0.7105143570089469, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "96", "isFavor": false, "solutionNum": 2751, "title": "Unique Binary Search Trees", "titleCn": "不同的二叉搜索树", "titleSlug": "unique-binary-search-trees", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 61, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg\" style=\"width: 600px; height: 148px;\" />\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 19</code></li>\n</ul>\n", "en": "<p>Given an integer <code>n</code>, return <em>the number of structurally unique <strong>BST&#39;</strong>s (binary search trees) which has exactly </em><code>n</code><em> nodes of unique values from</em> <code>1</code> <em>to</em> <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg\" style=\"width: 600px; height: 148px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 5\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 19</code></li>\n</ul>\n"}}, "97": {"__typename": "QuestionLightNode", "acRate": 0.4480177189925451, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "97", "isFavor": false, "solutionNum": 999, "title": "Interleaving String", "titleCn": "交错字符串", "titleSlug": "interleaving-string", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 55, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定三个字符串&nbsp;<code>s1</code>、<code>s2</code>、<code>s3</code>，请你帮忙验证&nbsp;<code>s3</code>&nbsp;是否是由&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code><em> </em><strong>交错 </strong>组成的。</p>\n\n<p>两个字符串 <code>s</code> 和 <code>t</code> <strong>交错</strong> 的定义与过程如下，其中每个字符串都会被分割成若干 <strong>非空</strong> <span data-keyword=\"substring-nonempty\">子字符串</span>：</p>\n\n<ul>\n\t<li><code>s = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>n</sub></code></li>\n\t<li><code>t = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>m</sub></code></li>\n\t<li><code>|n - m| &lt;= 1</code></li>\n\t<li><strong>交错</strong> 是 <code>s<sub>1</sub> + t<sub>1</sub> + s<sub>2</sub> + t<sub>2</sub> + s<sub>3</sub> + t<sub>3</sub> + ...</code> 或者 <code>t<sub>1</sub> + s<sub>1</sub> + t<sub>2</sub> + s<sub>2</sub> + t<sub>3</sub> + s<sub>3</sub> + ...</code></li>\n</ul>\n\n<p><strong>注意：</strong><code>a + b</code> 意味着字符串 <code>a</code> 和 <code>b</code> 连接。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg\" />\n<pre>\n<strong>输入：</strong>s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"\", s2 = \"\", s3 = \"\"\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= s3.length &lt;= 200</code></li>\n\t<li><code>s1</code>、<code>s2</code>、和 <code>s3</code> 都由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>您能否仅使用 <code>O(s2.length)</code> 额外的内存空间来解决它?</p>\n", "en": "<p>Given strings <code>s1</code>, <code>s2</code>, and <code>s3</code>, find whether <code>s3</code> is formed by an <strong>interleaving</strong> of <code>s1</code> and <code>s2</code>.</p>\n\n<p>An <strong>interleaving</strong> of two strings <code>s</code> and <code>t</code> is a configuration where <code>s</code> and <code>t</code> are divided into <code>n</code> and <code>m</code> <span data-keyword=\"substring-nonempty\">substrings</span> respectively, such that:</p>\n\n<ul>\n\t<li><code>s = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>n</sub></code></li>\n\t<li><code>t = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>m</sub></code></li>\n\t<li><code>|n - m| &lt;= 1</code></li>\n\t<li>The <strong>interleaving</strong> is <code>s<sub>1</sub> + t<sub>1</sub> + s<sub>2</sub> + t<sub>2</sub> + s<sub>3</sub> + t<sub>3</sub> + ...</code> or <code>t<sub>1</sub> + s<sub>1</sub> + t<sub>2</sub> + s<sub>2</sub> + t<sub>3</sub> + s<sub>3</sub> + ...</code></li>\n</ul>\n\n<p><strong>Note:</strong> <code>a + b</code> is the concatenation of strings <code>a</code> and <code>b</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg\" style=\"width: 561px; height: 203px;\" />\n<pre>\n<strong>Input:</strong> s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> One way to obtain s3 is:\nSplit s1 into s1 = &quot;aa&quot; + &quot;bc&quot; + &quot;c&quot;, and s2 into s2 = &quot;dbbc&quot; + &quot;a&quot;.\nInterleaving the two splits, we get &quot;aa&quot; + &quot;dbbc&quot; + &quot;bc&quot; + &quot;a&quot; + &quot;c&quot; = &quot;aadbbcbcac&quot;.\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Notice how it is impossible to interleave s2 with any other string to obtain s3.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s1.length, s2.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= s3.length &lt;= 200</code></li>\n\t<li><code>s1</code>, <code>s2</code>, and <code>s3</code> consist of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve it using only <code>O(s2.length)</code> additional memory space?</p>\n"}}, "98": {"__typename": "QuestionLightNode", "acRate": 0.37803716156312384, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "98", "isFavor": false, "solutionNum": 4621, "title": "Validate Binary Search Tree", "titleCn": "验证二叉搜索树", "titleSlug": "validate-binary-search-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 99, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>\n\n<p><strong>有效</strong> 二叉搜索树定义如下：</p>\n\n<ul>\n\t<li>节点的左<span data-keyword=\"subtree\">子树</span>只包含<strong> 小于 </strong>当前节点的数。</li>\n\t<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>\n\t<li>所有左子树和右子树自身必须也是二叉搜索树。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\" style=\"width: 302px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>root = [2,1,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\" style=\"width: 422px; height: 292px;\" />\n<pre>\n<strong>输入：</strong>root = [5,1,4,null,null,3,6]\n<strong>输出：</strong>false\n<strong>解释：</strong>根节点的值是 5 ，但是右子节点的值是 4 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目范围在<code>[1, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p>\n\n<p>A <strong>valid BST</strong> is defined as follows:</p>\n\n<ul>\n\t<li>The left <span data-keyword=\"subtree\">subtree</span> of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>\n\t<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg\" style=\"width: 302px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg\" style=\"width: 422px; height: 292px;\" />\n<pre>\n<strong>Input:</strong> root = [5,1,4,null,null,3,6]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The root node&#39;s value is 5 but its right child&#39;s value is 4.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "99": {"__typename": "QuestionLightNode", "acRate": 0.6055351437699681, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "99", "isFavor": false, "solutionNum": 1183, "title": "Recover Binary Search Tree", "titleCn": "恢复二叉搜索树", "titleSlug": "recover-binary-search-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 43, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你二叉搜索树的根节点 <code>root</code> ，该树中的 <strong>恰好</strong> 两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg\" style=\"width: 300px;\" />\n<pre>\n<strong>输入：</strong>root = [1,3,null,null,2]\n<strong>输出：</strong>[3,1,null,null,2]\n<strong>解释：</strong>3 不能是 1 的左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg\" style=\"height: 208px; width: 400px;\" />\n<pre>\n<strong>输入：</strong>root = [3,1,4,null,null,2]\n<strong>输出：</strong>[2,1,4,null,null,3]\n<strong>解释：</strong>2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树上节点的数目在范围 <code>[2, 1000]</code> 内</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>使用 <code>O(n)</code> 空间复杂度的解法很容易实现。你能想出一个只使用&nbsp;<code>O(1)</code> 空间的解决方案吗？</p>\n", "en": "<p>You are given the <code>root</code> of a binary search tree (BST), where the values of <strong>exactly</strong> two nodes of the tree were swapped by mistake. <em>Recover the tree without changing its structure</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg\" style=\"width: 422px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,3,null,null,2]\n<strong>Output:</strong> [3,1,null,null,2]\n<strong>Explanation:</strong> 3 cannot be a left child of 1 because 3 &gt; 1. Swapping 1 and 3 makes the BST valid.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg\" style=\"width: 581px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,1,4,null,null,2]\n<strong>Output:</strong> [2,1,4,null,null,3]\n<strong>Explanation:</strong> 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 1000]</code>.</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> A solution using <code>O(n)</code> space is pretty straight-forward. Could you devise a constant <code>O(1)</code> space solution?"}}, "100": {"__typename": "QuestionLightNode", "acRate": 0.612100641294366, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "100", "isFavor": false, "solutionNum": 3514, "title": "Same Tree", "titleCn": "相同的树", "titleSlug": "same-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 44, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>\n\n<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg\" style=\"width: 622px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>p = [1,2,3], q = [1,2,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg\" style=\"width: 382px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>p = [1,2], q = [1,null,2]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg\" style=\"width: 622px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>p = [1,2,1], q = [1,1,2]\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li>\n\t<li><code>-10<sup>4</sup> <= Node.val <= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.</p>\n\n<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg\" style=\"width: 622px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> p = [1,2,3], q = [1,2,3]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg\" style=\"width: 382px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> p = [1,2], q = [1,null,2]\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg\" style=\"width: 622px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> p = [1,2,1], q = [1,1,2]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in both trees is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "101": {"__typename": "QuestionLightNode", "acRate": 0.6008089656688379, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "101", "isFavor": false, "solutionNum": 4959, "title": "Symmetric Tree", "titleCn": "对称二叉树", "titleSlug": "symmetric-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 93, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://pic.leetcode.cn/1698026966-JDYPDU-image.png\" style=\"width: 354px; height: 291px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,2,3,4,4,3]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://pic.leetcode.cn/1698027008-nPFLbM-image.png\" style=\"width: 308px; height: 258px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,2,null,3,null,3]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以运用递归和迭代两种方法解决这个问题吗？</p>\n", "en": "<p>Given the <code>root</code> of a binary tree, <em>check whether it is a mirror of itself</em> (i.e., symmetric around its center).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg\" style=\"width: 354px; height: 291px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,2,3,4,4,3]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg\" style=\"width: 308px; height: 258px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,2,null,3,null,3]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it both recursively and iteratively?"}}, "102": {"__typename": "QuestionLightNode", "acRate": 0.6708587453179848, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "102", "isFavor": false, "solutionNum": 5154, "title": "Binary Tree Level Order Traversal", "titleCn": "二叉树的层序遍历", "titleSlug": "binary-tree-level-order-traversal", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 136, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [3,9,20,null,null,15,7]\n<strong>输出：</strong>[[3],[9,20],[15,7]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes&#39; values</em>. (i.e., from left to right, level by level).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> [[3],[9,20],[15,7]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n"}}, "103": {"__typename": "QuestionLightNode", "acRate": 0.5881405496245773, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "103", "isFavor": false, "solutionNum": 2760, "title": "Binary Tree Zigzag Level Order Traversal", "titleCn": "二叉树的锯齿形层序遍历", "titleSlug": "binary-tree-zigzag-level-order-traversal", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 79, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [3,9,20,null,null,15,7]\n<strong>输出：</strong>[[3],[20,9],[15,7]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes&#39; values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> [[3],[20,9],[15,7]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n"}}, "104": {"__typename": "QuestionLightNode", "acRate": 0.7747496603796855, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "104", "isFavor": false, "solutionNum": 5907, "title": "Maximum Depth of Binary Tree", "titleCn": "二叉树的最大深度", "titleSlug": "maximum-depth-of-binary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 103, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p>\n\n<p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg\" style=\"width: 400px; height: 277px;\" /></p>\n\n<p>&nbsp;</p>\n\n<pre>\n<b>输入：</b>root = [3,9,20,null,null,15,7]\n<b>输出：</b>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>root = [1,null,2]\n<b>输出：</b>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数量在&nbsp;<code>[0, 10<sup>4</sup>]</code>&nbsp;区间内。</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>\n\n<p>A binary tree&#39;s <strong>maximum depth</strong>&nbsp;is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg\" style=\"width: 400px; height: 277px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,2]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n"}}, "105": {"__typename": "QuestionLightNode", "acRate": 0.7155950447869808, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "105", "isFavor": false, "solutionNum": 3078, "title": "Construct Binary Tree from Preorder and Inorder Traversal", "titleCn": "从前序与中序遍历序列构造二叉树", "titleSlug": "construct-binary-tree-from-preorder-and-inorder-traversal", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 75, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个整数数组&nbsp;<code>preorder</code> 和 <code>inorder</code>&nbsp;，其中&nbsp;<code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code>&nbsp;是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" style=\"height: 302px; width: 277px;\" />\n<pre>\n<strong>输入</strong><strong>:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n<strong>输出:</strong> [3,9,20,null,null,15,7]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> preorder = [-1], inorder = [-1]\n<strong>输出:</strong> [-1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>\n\t<li><code>inorder.length == preorder.length</code></li>\n\t<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>\n\t<li><code>preorder</code>&nbsp;和&nbsp;<code>inorder</code>&nbsp;均 <strong>无重复</strong> 元素</li>\n\t<li><code>inorder</code>&nbsp;均出现在&nbsp;<code>preorder</code></li>\n\t<li><code>preorder</code>&nbsp;<strong>保证</strong> 为二叉树的前序遍历序列</li>\n\t<li><code>inorder</code>&nbsp;<strong>保证</strong> 为二叉树的中序遍历序列</li>\n</ul>\n", "en": "<p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n<strong>Output:</strong> [3,9,20,null,null,15,7]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> preorder = [-1], inorder = [-1]\n<strong>Output:</strong> [-1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>\n\t<li><code>inorder.length == preorder.length</code></li>\n\t<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>\n\t<li><code>preorder</code> and <code>inorder</code> consist of <strong>unique</strong> values.</li>\n\t<li>Each value of <code>inorder</code> also appears in <code>preorder</code>.</li>\n\t<li><code>preorder</code> is <strong>guaranteed</strong> to be the preorder traversal of the tree.</li>\n\t<li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li>\n</ul>\n"}}, "106": {"__typename": "QuestionLightNode", "acRate": 0.7222146050382844, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "106", "isFavor": false, "solutionNum": 2098, "title": "Construct Binary Tree from Inorder and Postorder Traversal", "titleCn": "从中序与后序遍历序列构造二叉树", "titleSlug": "construct-binary-tree-from-inorder-and-postorder-traversal", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 54, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗&nbsp;<em>二叉树</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" />\n<pre>\n<b>输入：</b>inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n<b>输出：</b>[3,9,20,null,null,15,7]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>inorder = [-1], postorder = [-1]\n<b>输出：</b>[-1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= inorder.length &lt;= 3000</code></li>\n\t<li><code>postorder.length == inorder.length</code></li>\n\t<li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>\n\t<li><code>inorder</code>&nbsp;和&nbsp;<code>postorder</code>&nbsp;都由 <strong>不同</strong> 的值组成</li>\n\t<li><code>postorder</code>&nbsp;中每一个值都在&nbsp;<code>inorder</code>&nbsp;中</li>\n\t<li><code>inorder</code>&nbsp;<strong>保证</strong>是树的中序遍历</li>\n\t<li><code>postorder</code>&nbsp;<strong>保证</strong>是树的后序遍历</li>\n</ul>\n", "en": "<p>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n<strong>Output:</strong> [3,9,20,null,null,15,7]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> inorder = [-1], postorder = [-1]\n<strong>Output:</strong> [-1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= inorder.length &lt;= 3000</code></li>\n\t<li><code>postorder.length == inorder.length</code></li>\n\t<li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>\n\t<li><code>inorder</code> and <code>postorder</code> consist of <strong>unique</strong> values.</li>\n\t<li>Each value of <code>postorder</code> also appears in <code>inorder</code>.</li>\n\t<li><code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree.</li>\n\t<li><code>postorder</code> is <strong>guaranteed</strong> to be the postorder traversal of the tree.</li>\n</ul>\n"}}, "107": {"__typename": "QuestionLightNode", "acRate": 0.7390942501797652, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "107", "isFavor": false, "solutionNum": 2204, "title": "Binary Tree Level Order Traversal II", "titleCn": "二叉树的层序遍历 II", "titleSlug": "binary-tree-level-order-traversal-ii", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 52, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [3,9,20,null,null,15,7]\n<strong>输出：</strong>[[15,7],[9,20],[3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[[1]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree, return <em>the bottom-up level order traversal of its nodes&#39; values</em>. (i.e., from left to right, level by level from leaf to root).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> [[15,7],[9,20],[3]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n"}}, "108": {"__typename": "QuestionLightNode", "acRate": 0.7833115008242195, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "108", "isFavor": false, "solutionNum": 2421, "title": "Convert Sorted Array to Binary Search Tree", "titleCn": "将有序数组转换为二叉搜索树", "titleSlug": "convert-sorted-array-to-binary-search-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 63, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <span data-keyword=\"height-balanced\">平衡</span> 二叉搜索树。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg\" style=\"width: 302px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>nums = [-10,-3,0,5,9]\n<strong>输出：</strong>[0,-3,9,-10,null,5]\n<strong>解释：</strong>[0,-10,5,null,-3,null,9] 也将被视为正确答案：\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg\" style=\"width: 302px; height: 222px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/btree.jpg\" style=\"width: 342px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>nums = [1,3]\n<strong>输出：</strong>[3,1]\n<strong>解释：</strong>[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a </em><span data-keyword=\"height-balanced\"><strong><em>height-balanced</em></strong></span> <em>binary search tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg\" style=\"width: 302px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> nums = [-10,-3,0,5,9]\n<strong>Output:</strong> [0,-3,9,-10,null,5]\n<strong>Explanation:</strong> [0,-10,5,null,-3,null,9] is also accepted:\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg\" style=\"width: 302px; height: 222px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/18/btree.jpg\" style=\"width: 342px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> nums = [1,3]\n<strong>Output:</strong> [3,1]\n<strong>Explanation:</strong> [1,null,3] and [3,1] are both height-balanced BSTs.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is sorted in a <strong>strictly increasing</strong> order.</li>\n</ul>\n"}}, "109": {"__typename": "QuestionLightNode", "acRate": 0.7656678996339231, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "109", "isFavor": false, "solutionNum": 1195, "title": "Convert Sorted List to Binary Search Tree", "titleCn": "有序链表转换二叉搜索树", "titleSlug": "convert-sorted-list-to-binary-search-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 51, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个单链表的头节点 &nbsp;<code>head</code>&nbsp;，其中的元素 <strong>按升序排序</strong> ，将其转换为 <span data-keyword=\"height-balanced\">平衡</span> 二叉搜索树。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/08/17/linked.jpg\" style=\"height: 388px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> head = [-10,-3,0,5,9]\n<strong>输出:</strong> [0,-3,9,-10,null,5]\n<strong>解释:</strong> 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> head = []\n<strong>输出:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>head</code>&nbsp;中的节点数在<code>[0, 2 * 10<sup>4</sup>]</code>&nbsp;范围内</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>Given the <code>head</code> of a singly linked list where elements are sorted in <strong>ascending order</strong>, convert <em>it to a </em><span data-keyword=\"height-balanced\"><strong><em>height-balanced</em></strong></span> <em>binary search tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/17/linked.jpg\" style=\"width: 500px; height: 388px;\" />\n<pre>\n<strong>Input:</strong> head = [-10,-3,0,5,9]\n<strong>Output:</strong> [0,-3,9,-10,null,5]\n<strong>Explanation:</strong> One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in <code>head</code> is in the range <code>[0, 2 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "110": {"__typename": "QuestionLightNode", "acRate": 0.5832306297088643, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "110", "isFavor": false, "solutionNum": 2918, "title": "Balanced Binary Tree", "titleCn": "平衡二叉树", "titleSlug": "balanced-binary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 73, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二叉树，判断它是否是 <span data-keyword=\"height-balanced\">平衡二叉树</span> &nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg\" style=\"width: 342px; height: 221px;\" />\n<pre>\n<strong>输入：</strong>root = [3,9,20,null,null,15,7]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg\" style=\"width: 452px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,2,3,3,null,null,4,4]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given a binary tree, determine if it is <span data-keyword=\"height-balanced\"><strong>height-balanced</strong></span>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg\" style=\"width: 342px; height: 221px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg\" style=\"width: 452px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,2,3,3,null,null,4,4]\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "111": {"__typename": "QuestionLightNode", "acRate": 0.5385512615177995, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "111", "isFavor": false, "solutionNum": 4291, "title": "Minimum Depth of Binary Tree", "titleCn": "二叉树的最小深度", "titleSlug": "minimum-depth-of-binary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 38, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二叉树，找出其最小深度。</p>\n\n<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>\n\n<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg\" style=\"width: 432px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [3,9,20,null,null,15,7]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [2,null,3,null,4,null,5,null,6]\n<strong>输出：</strong>5\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数的范围在 <code>[0, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>-1000 <= Node.val <= 1000</code></li>\n</ul>\n", "en": "<p>Given a binary tree, find its minimum depth.</p>\n\n<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>\n\n<p><strong>Note:</strong>&nbsp;A leaf is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg\" style=\"width: 432px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [2,null,3,null,4,null,5,null,6]\n<strong>Output:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>5</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n"}}, "112": {"__typename": "QuestionLightNode", "acRate": 0.5418543163698815, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "112", "isFavor": false, "solutionNum": 3561, "title": "Path Sum", "titleCn": "路径总和", "titleSlug": "path-sum", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 68, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你二叉树的根节点&nbsp;<code>root</code> 和一个表示目标和的整数&nbsp;<code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和&nbsp;<code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg\" style=\"width: 500px; height: 356px;\" />\n<pre>\n<strong>输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n<strong>输出：</strong>true\n<strong>解释：</strong>等于目标和的根节点到叶节点路径如上图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3], targetSum = 5\n<strong>输出：</strong>false\n<strong>解释：</strong>树中存在两条根节点到叶子节点的路径：\n(1 --&gt; 2): 和为 3\n(1 --&gt; 3): 和为 4\n不存在 sum = 5 的根节点到叶子节点的路径。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [], targetSum = 0\n<strong>输出：</strong>false\n<strong>解释：</strong>由于树是空的，所以不存在根节点到叶子节点的路径。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals <code>targetSum</code>.</p>\n\n<p>A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg\" style=\"width: 500px; height: 356px;\" />\n<pre>\n<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The root-to-leaf path with the target sum is shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3], targetSum = 5\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There two root-to-leaf paths in the tree:\n(1 --&gt; 2): The sum is 3.\n(1 --&gt; 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [], targetSum = 0\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Since the tree is empty, there are no root-to-leaf paths.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n"}}, "113": {"__typename": "QuestionLightNode", "acRate": 0.6324925243409968, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "113", "isFavor": false, "solutionNum": 2431, "title": "Path Sum II", "titleCn": "路径总和 II", "titleSlug": "path-sum-ii", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 52, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>\n\n<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg\" style=\"width: 500px; height: 356px;\" />\n<pre>\n<strong>输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n<strong>输出：</strong>[[5,4,11,2],[5,8,4,5]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" style=\"width: 212px; height: 181px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3], targetSum = 5\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2], targetSum = 0\n<strong>输出：</strong>[]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点总数在范围 <code>[0, 5000]</code> 内</li>\n\t<li><code>-1000 <= Node.val <= 1000</code></li>\n\t<li><code>-1000 <= targetSum <= 1000</code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>all <strong>root-to-leaf</strong> paths where the sum of the node values in the path equals </em><code>targetSum</code><em>. Each path should be returned as a list of the node <strong>values</strong>, not node references</em>.</p>\n\n<p>A <strong>root-to-leaf</strong> path is a path starting from the root and ending at any leaf node. A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg\" style=\"width: 500px; height: 356px;\" />\n<pre>\n<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n<strong>Output:</strong> [[5,4,11,2],[5,8,4,5]]\n<strong>Explanation:</strong> There are two paths whose sum equals targetSum:\n5 + 4 + 11 + 2 = 22\n5 + 8 + 4 + 5 = 22\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" style=\"width: 212px; height: 181px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3], targetSum = 5\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,2], targetSum = 0\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n"}}, "114": {"__typename": "QuestionLightNode", "acRate": 0.7358393067933541, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "114", "isFavor": false, "solutionNum": 3370, "title": "Flatten Binary Tree to Linked List", "titleCn": "二叉树展开为链表", "titleSlug": "flatten-binary-tree-to-linked-list", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 55, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>\n\n<ul>\n\t<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>\n\t<li>展开后的单链表应该与二叉树 <a href=\"https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin\" target=\"_blank\"><strong>先序遍历</strong></a> 顺序相同。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg\" style=\"width: 500px; height: 226px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,5,3,4,null,6]\n<strong>输出：</strong>[1,null,2,null,3,null,4,null,5,null,6]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中结点数在范围 <code>[0, 2000]</code> 内</li>\n\t<li><code>-100 <= Node.val <= 100</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p>\n", "en": "<p>Given the <code>root</code> of a binary tree, flatten the tree into a &quot;linked list&quot;:</p>\n\n<ul>\n\t<li>The &quot;linked list&quot; should use the same <code>TreeNode</code> class where the <code>right</code> child pointer points to the next node in the list and the <code>left</code> child pointer is always <code>null</code>.</li>\n\t<li>The &quot;linked list&quot; should be in the same order as a <a href=\"https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR\" target=\"_blank\"><strong>pre-order</strong><strong> traversal</strong></a> of the binary tree.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg\" style=\"width: 500px; height: 226px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,5,3,4,null,6]\n<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Can you flatten the tree in-place (with <code>O(1)</code> extra space)?"}}, "115": {"__typename": "QuestionLightNode", "acRate": 0.5188160676532769, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "115", "isFavor": false, "solutionNum": 1426, "title": "Distinct Subsequences", "titleCn": "不同的子序列", "titleSlug": "distinct-subsequences", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 50, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/e180e3e5553f722e5895940d0617f54e988e54e1e530b27e88e76576aedc553d-qw90wxxo_400x400.jpg", "slug": "mathworks", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个字符串 <code>s</code><strong> </strong>和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数，结果需要对&nbsp;10<sup>9</sup> + 7 取模。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"rabbbit\", t = \"rabbit\"<code>\n<strong>输出</strong></code><strong>：</strong><code>3\n</code><strong>解释：</strong>\n如下所示, 有 3 种可以从 s 中得到 <code>\"rabbit\" 的方案</code>。\n<code><strong><u>rabb</u></strong>b<strong><u>it</u></strong></code>\n<code><strong><u>ra</u></strong>b<strong><u>bbit</u></strong></code>\n<code><strong><u>rab</u></strong>b<strong><u>bit</u></strong></code></pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"babgbag\", t = \"bag\"\n<code><strong>输出</strong></code><strong>：</strong><code>5\n</code><strong>解释：</strong>\n如下所示, 有 5 种可以从 s 中得到 <code>\"bag\" 的方案</code>。 \n<code><strong><u>ba</u></strong>b<u><strong>g</strong></u>bag</code>\n<code><strong><u>ba</u></strong>bgba<strong><u>g</u></strong></code>\n<code><u><strong>b</strong></u>abgb<strong><u>ag</u></strong></code>\n<code>ba<u><strong>b</strong></u>gb<u><strong>ag</strong></u></code>\n<code>babg<strong><u>bag</u></strong></code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 1000</code></li>\n\t<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>\n</ul>\n", "en": "<p>Given two strings s and t, return <i>the number of distinct</i> <b><i>subsequences</i></b><i> of </i>s<i> which equals </i>t.</p>\n\n<p>The test cases are generated so that the answer fits on a 32-bit signed integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\nAs shown below, there are 3 ways you can generate &quot;rabbit&quot; from s.\n<code><strong><u>rabb</u></strong>b<strong><u>it</u></strong></code>\n<code><strong><u>ra</u></strong>b<strong><u>bbit</u></strong></code>\n<code><strong><u>rab</u></strong>b<strong><u>bit</u></strong></code>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;babgbag&quot;, t = &quot;bag&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\nAs shown below, there are 5 ways you can generate &quot;bag&quot; from s.\n<code><strong><u>ba</u></strong>b<u><strong>g</strong></u>bag</code>\n<code><strong><u>ba</u></strong>bgba<strong><u>g</u></strong></code>\n<code><u><strong>b</strong></u>abgb<strong><u>ag</u></strong></code>\n<code>ba<u><strong>b</strong></u>gb<u><strong>ag</strong></u></code>\n<code>babg<strong><u>bag</u></strong></code></pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 1000</code></li>\n\t<li><code>s</code> and <code>t</code> consist of English letters.</li>\n</ul>\n"}}, "116": {"__typename": "QuestionLightNode", "acRate": 0.7327824292110007, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "116", "isFavor": false, "solutionNum": 2873, "title": "Populating Next Right Pointers in Each Node", "titleCn": "填充每个节点的下一个右侧节点指针", "titleSlug": "populating-next-right-pointers-in-each-node", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 47, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个&nbsp;<strong>完美二叉树&nbsp;</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>\n\n<pre>\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}</pre>\n\n<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>\n\n<p>初始状态下，所有&nbsp;next 指针都被设置为 <code>NULL</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/14/116_sample.png\" style=\"height: 171px; width: 500px;\" /></p>\n\n<pre>\n<b>输入：</b>root = [1,2,3,4,5,6,7]\n<b>输出：</b>[1,#,2,3,#,4,5,6,7,#]\n<b>解释：</b>给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。\n</pre>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>root = []\n<b>输出：</b>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数量在<meta charset=\"UTF-8\" />&nbsp;<code>[0, 2<sup>12</sup>&nbsp;- 1]</code>&nbsp;范围内</li>\n\t<li><code>-1000 &lt;= node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你只能使用常量级额外空间。</li>\n\t<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>\n</ul>\n", "en": "<p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>\n\n<pre>\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n</pre>\n\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\n\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/14/116_sample.png\" style=\"width: 500px; height: 171px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6,7]\n<strong>Output:</strong> [1,#,2,3,#,4,5,6,7,#]\n<strong>Explanation: </strong>Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2<sup>12</sup> - 1]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong></p>\n\n<ul>\n\t<li>You may only use constant extra space.</li>\n\t<li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li>\n</ul>\n"}}, "117": {"__typename": "QuestionLightNode", "acRate": 0.6900373558016687, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "117", "isFavor": false, "solutionNum": 1665, "title": "Populating Next Right Pointers in Each Node II", "titleCn": "填充每个节点的下一个右侧节点指针 II", "titleSlug": "populating-next-right-pointers-in-each-node-ii", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 39, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二叉树：</p>\n\n<pre>\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}</pre>\n\n<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code> 。</p>\n\n<p>初始状态下，所有&nbsp;next 指针都被设置为 <code>NULL</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/15/117_sample.png\" style=\"width: 500px; height: 171px;\" />\n<pre>\n<strong>输入</strong>：root = [1,2,3,4,5,null,7]\n<strong>输出：</strong>[1,#,2,3,#,4,5,7,#]\n<strong>解释：</strong>给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数在范围 <code>[0, 6000]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你只能使用常量级额外空间。</li>\n\t<li>使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。</li>\n</ul>\n\n<ul>\n</ul>\n", "en": "<p>Given a binary tree</p>\n\n<pre>\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n</pre>\n\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\n\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/15/117_sample.png\" style=\"width: 500px; height: 171px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,null,7]\n<strong>Output:</strong> [1,#,2,3,#,4,5,7,#]\n<strong>Explanation: </strong>Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 6000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong></p>\n\n<ul>\n\t<li>You may only use constant extra space.</li>\n\t<li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li>\n</ul>\n"}}, "118": {"__typename": "QuestionLightNode", "acRate": 0.7582739608695782, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "118", "isFavor": false, "solutionNum": 3614, "title": "Pascal's Triangle", "titleCn": "杨辉三角", "titleSlug": "pascals-triangle", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 75, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code> </em>行。</p>\n\n<p><small>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</small></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif\" /></p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> numRows = 5\n<strong>输出:</strong> [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> numRows = 1\n<strong>输出:</strong> [[1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 <= numRows <= 30</code></li>\n</ul>\n", "en": "<p>Given an integer <code>numRows</code>, return the first numRows of <strong>Pascal&#39;s triangle</strong>.</p>\n\n<p>In <strong>Pascal&#39;s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>\n<img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\" style=\"height:240px; width:260px\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> numRows = 5\n<strong>Output:</strong> [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> numRows = 1\n<strong>Output:</strong> [[1]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numRows &lt;= 30</code></li>\n</ul>\n"}}, "119": {"__typename": "QuestionLightNode", "acRate": 0.6897439542561089, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "119", "isFavor": false, "solutionNum": 2231, "title": "Pascal's Triangle II", "titleCn": "杨辉三角 II", "titleSlug": "pascals-triangle-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 38, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code><em> </em>行。</p>\n\n<p><small>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</small></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif\" /></p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> rowIndex = 3\n<strong>输出:</strong> [1,3,3,1]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> rowIndex = 0\n<strong>输出:</strong> [1]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> rowIndex = 1\n<strong>输出:</strong> [1,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 <= rowIndex <= 33</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong></p>\n\n<p>你可以优化你的算法到 <code><em>O</em>(<i>rowIndex</i>)</code> 空间复杂度吗？</p>\n", "en": "<p>Given an integer <code>rowIndex</code>, return the <code>rowIndex<sup>th</sup></code> (<strong>0-indexed</strong>) row of the <strong>Pascal&#39;s triangle</strong>.</p>\n\n<p>In <strong>Pascal&#39;s triangle</strong>, each number is the sum of the two numbers directly above it as shown:</p>\n<img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\" style=\"height:240px; width:260px\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 3\n<strong>Output:</strong> [1,3,3,1]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 0\n<strong>Output:</strong> [1]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> rowIndex = 1\n<strong>Output:</strong> [1,1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= rowIndex &lt;= 33</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you optimize your algorithm to use only <code>O(rowIndex)</code> extra space?</p>\n"}}, "120": {"__typename": "QuestionLightNode", "acRate": 0.6868423677752729, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "120", "isFavor": false, "solutionNum": 2677, "title": "Triangle", "titleCn": "三角形最小路径和", "titleSlug": "triangle", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 59, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p>\n\n<p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点 </strong>在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n<strong>输出：</strong>11\n<strong>解释：</strong>如下面简图所示：\n   <strong>2</strong>\n  <strong>3</strong> 4\n 6 <strong>5</strong> 7\n4 <strong>1</strong> 8 3\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>triangle = [[-10]]\n<strong>输出：</strong>-10\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= triangle.length <= 200</code></li>\n\t<li><code>triangle[0].length == 1</code></li>\n\t<li><code>triangle[i].length == triangle[i - 1].length + 1</code></li>\n\t<li><code>-10<sup>4</sup> <= triangle[i][j] <= 10<sup>4</sup></code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以只使用 <code>O(n)</code> 的额外空间（<code>n</code> 为三角形的总行数）来解决这个问题吗？</li>\n</ul>\n", "en": "<p>Given a <code>triangle</code> array, return <em>the minimum path sum from top to bottom</em>.</p>\n\n<p>For each step, you may move to an adjacent number of the row below. More formally, if you are on index <code>i</code> on the current row, you may move to either index <code>i</code> or index <code>i + 1</code> on the next row.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> The triangle looks like:\n   <u>2</u>\n  <u>3</u> 4\n 6 <u>5</u> 7\n4 <u>1</u> 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> triangle = [[-10]]\n<strong>Output:</strong> -10\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= triangle.length &lt;= 200</code></li>\n\t<li><code>triangle[0].length == 1</code></li>\n\t<li><code>triangle[i].length == triangle[i - 1].length + 1</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= triangle[i][j] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you&nbsp;do this using only <code>O(n)</code> extra space, where <code>n</code> is the total number of rows in the triangle?"}}, "121": {"__typename": "QuestionLightNode", "acRate": 0.5771665515431734, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "121", "isFavor": false, "solutionNum": 7289, "title": "Best Time to Buy and Sell Stock", "titleCn": "买卖股票的最佳时机", "titleSlug": "best-time-to-buy-and-sell-stock", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 184, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>\n\n<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>\n\n<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[7,1,5,3,6,4]\n<strong>输出：</strong>5\n<strong>解释：</strong>在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [7,6,4,3,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>在这种情况下, 没有交易完成, 所以最大利润为 0。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= prices.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= prices[i] <= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>\n\n<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,1,5,3,6,4]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,6,4,3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> In this case, no transactions are done and the max profit = 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "122": {"__typename": "QuestionLightNode", "acRate": 0.7340932535033357, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "122", "isFavor": false, "solutionNum": 5703, "title": "Best Time to Buy and Sell Stock II", "titleCn": "买卖股票的最佳时机 II", "titleSlug": "best-time-to-buy-and-sell-stock-ii", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 110, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>prices</code> ，其中&nbsp;<code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>\n\n<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候&nbsp;<strong>最多</strong>&nbsp;只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>\n\n<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [7,1,5,3,6,4]\n<strong>输出：</strong>7\n<strong>解释：</strong>在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。\n&nbsp;    随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。\n     总利润为 4 + 3 = 7 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [1,2,3,4,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。\n&nbsp;    总利润为 4 。</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [7,6,4,3,1]\n<strong>输出：</strong>0\n<strong>解释：</strong>在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>On each day, you may decide to buy and/or sell the stock. You can only hold <strong>at most one</strong> share of the stock at any time. However, you can buy it then immediately sell it on the <strong>same day</strong>.</p>\n\n<p>Find and return <em>the <strong>maximum</strong> profit you can achieve</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,1,5,3,6,4]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,3,4,5]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,6,4,3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "123": {"__typename": "QuestionLightNode", "acRate": 0.6049228567464751, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "123", "isFavor": false, "solutionNum": 1747, "title": "Best Time to Buy and Sell Stock III", "titleCn": "买卖股票的最佳时机 III", "titleSlug": "best-time-to-buy-and-sell-stock-iii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 68, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个数组，它的第<em> </em><code>i</code> 个元素是一支给定的股票在第 <code>i</code><em> </em>天的价格。</p>\n\n<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔 </strong>交易。</p>\n\n<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [3,3,5,0,0,3,1,4]\n<strong>输出：</strong>6\n<strong>解释：</strong>在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\n     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [1,2,3,4,5]\n<strong>输出：</strong>4\n<strong>解释：</strong>在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   \n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   \n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [7,6,4,3,1] \n<strong>输出：</strong>0 \n<strong>解释：</strong>在这个情况下, 没有交易完成, 所以最大利润为 0。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [1]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= prices.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= prices[i] <= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>Find the maximum profit you can achieve. You may complete <strong>at most two transactions</strong>.</p>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [3,3,5,0,0,3,1,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,3,4,5]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,6,4,3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> In this case, no transaction is done, i.e. max profit = 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "124": {"__typename": "QuestionLightNode", "acRate": 0.4546920998965032, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "124", "isFavor": false, "solutionNum": 2263, "title": "Binary Tree Maximum Path Sum", "titleCn": "二叉树中的最大路径和", "titleSlug": "binary-tree-maximum-path-sum", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 98, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>二叉树中的<strong> 路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径<strong> 至少包含一个 </strong>节点，且不一定经过根节点。</p>\n\n<p><strong>路径和</strong> 是路径中各节点值的总和。</p>\n\n<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\" style=\"width: 322px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>6\n<strong>解释：</strong>最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\" />\n<pre>\n<strong>输入：</strong>root = [-10,9,20,null,null,15,7]\n<strong>输出：</strong>42\n<strong>解释：</strong>最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目范围是 <code>[1, 3 * 10<sup>4</sup>]</code></li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n", "en": "<p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p>\n\n<p>The <strong>path sum</strong> of a path is the sum of the node&#39;s values in the path.</p>\n\n<p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg\" style=\"width: 322px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 = 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg\" />\n<pre>\n<strong>Input:</strong> root = [-10,9,20,null,null,15,7]\n<strong>Output:</strong> 42\n<strong>Explanation:</strong> The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 = 42.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 3 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n"}}, "125": {"__typename": "QuestionLightNode", "acRate": 0.4698764042130632, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "125", "isFavor": false, "solutionNum": 3436, "title": "Valid Palindrome", "titleCn": "验证回文串", "titleSlug": "valid-palindrome", "topicTags": [{"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 88, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 <strong>回文串</strong> 。</p>\n\n<p>字母和数字都属于字母数字字符。</p>\n\n<p>给你一个字符串 <code>s</code>，如果它是 <strong>回文串</strong> ，返回 <code>true</code><em> </em>；否则，返回<em> </em><code>false</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"A man, a plan, a canal: Panama\"\n<strong>输出：</strong>true\n<strong>解释：</strong>\"amanaplanacanalpanama\" 是回文串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"race a car\"\n<strong>输出：</strong>false\n<strong>解释：</strong>\"raceacar\" 不是回文串。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \" \"\n<strong>输出：</strong>true\n<strong>解释：</strong>在移除非字母数字字符之后，s 是一个空字符串 \"\" 。\n由于空字符串正着反着读都一样，所以是回文串。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由可打印的 ASCII 字符组成</li>\n</ul>\n", "en": "<p>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p>\n\n<p>Given a string <code>s</code>, return <code>true</code><em> if it is a <strong>palindrome</strong>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;A man, a plan, a canal: Panama&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &quot;amanaplanacanalpanama&quot; is a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;race a car&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;raceacar&quot; is not a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot; &quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> s is an empty string &quot;&quot; after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists only of printable ASCII characters.</li>\n</ul>\n"}}, "126": {"__typename": "QuestionLightNode", "acRate": 0.3699137410723267, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "126", "isFavor": false, "solutionNum": 518, "title": "Word Ladder II", "titleCn": "单词接龙 II", "titleSlug": "word-ladder-ii", "topicTags": [{"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 49, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>按字典&nbsp;<code>wordList</code> 完成从单词 <code>beginWord</code> 到单词 <code>endWord</code> 转化，一个表示此过程的 <strong>转换序列</strong> 是形式上像 <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> 这样的单词序列，并满足：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li>每对相邻的单词之间仅有单个字母不同。</li>\n\t<li>转换过程中的每个单词 <code>s<sub>i</sub></code>（<code>1 &lt;= i &lt;= k</code>）必须是字典&nbsp;<code>wordList</code> 中的单词。注意，<code>beginWord</code> 不必是字典 <code>wordList</code> 中的单词。</li>\n\t<li><code>s<sub>k</sub> == endWord</code></li>\n</ul>\n\n<p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> ，以及一个字典 <code>wordList</code> 。请你找出并返回所有从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表<em> </em><code>[beginWord, s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>]</code> 的形式返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n<strong>输出：</strong>[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\n<strong>解释：</strong>存在 2 种最短的转换序列：\n\"hit\" -&gt; \"hot\" -&gt; \"dot\" -&gt; \"dog\" -&gt; \"cog\"\n\"hit\" -&gt; \"hot\" -&gt; \"lot\" -&gt; \"log\" -&gt; \"cog\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n<strong>输出：</strong>[]\n<strong>解释：</strong>endWord \"cog\" 不在字典 wordList 中，所以不存在符合要求的转换序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 5</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 500</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li><code>wordList</code> 中的所有单词 <strong>互不相同</strong></li>\n</ul>\n</div>\n</div>\n", "en": "<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>\n\n<ul>\n\t<li>Every adjacent pair of words differs by a single letter.</li>\n\t<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>\n\t<li><code>s<sub>k</sub> == endWord</code></li>\n</ul>\n\n<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>all the <strong>shortest transformation sequences</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words </em><code>[beginWord, s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub>]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>Output:</strong> [[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]\n<strong>Explanation:</strong>&nbsp;There are 2 shortest transformation sequences:\n&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;\n&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;lot&quot; -&gt; &quot;log&quot; -&gt; &quot;cog&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>Output:</strong> []\n<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 5</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 500</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>\n\t<li>The <strong>sum</strong> of all shortest transformation sequences does not exceed <code>10<sup>5</sup></code>.</li>\n</ul>\n"}}, "127": {"__typename": "QuestionLightNode", "acRate": 0.4867393301729214, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "127", "isFavor": false, "solutionNum": 1140, "title": "Word Ladder", "titleCn": "单词接龙", "titleSlug": "word-ladder", "topicTags": [{"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 80, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>字典&nbsp;<code>wordList</code> 中从单词 <code>beginWord</code><em>&nbsp;</em>和 <code>endWord</code> 的 <strong>转换序列 </strong>是一个按下述规格形成的序列<meta charset=\"UTF-8\" />&nbsp;<code>beginWord -&gt; s<sub>1</sub>&nbsp;-&gt; s<sub>2</sub>&nbsp;-&gt; ... -&gt; s<sub>k</sub></code>：</p>\n\n<ul>\n\t<li>每一对相邻的单词只差一个字母。</li>\n\t<li><meta charset=\"UTF-8\" />&nbsp;对于&nbsp;<code>1 &lt;= i &lt;= k</code>&nbsp;时，每个<meta charset=\"UTF-8\" />&nbsp;<code>s<sub>i</sub></code>&nbsp;都在<meta charset=\"UTF-8\" />&nbsp;<code>wordList</code>&nbsp;中。注意， <code>beginWord</code><em>&nbsp;</em>不需要在<meta charset=\"UTF-8\" />&nbsp;<code>wordList</code>&nbsp;中。<meta charset=\"UTF-8\" /></li>\n\t<li><code>s<sub>k</sub>&nbsp;== endWord</code></li>\n</ul>\n\n<p>给你两个单词<em> </em><code>beginWord</code><em>&nbsp;</em>和 <code>endWord</code> 和一个字典 <code>wordList</code> ，返回 <em>从&nbsp;<code>beginWord</code> 到&nbsp;<code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回 <code>0</code> 。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n<strong>输出：</strong>5\n<strong>解释：</strong>一个最短转换序列是 \"hit\" -&gt; \"hot\" -&gt; \"dot\" -&gt; \"dog\" -&gt; \"cog\", 返回它的长度 5。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n<strong>输出：</strong>0\n<strong>解释：</strong>endWord \"cog\" 不在字典中，所以无法进行转换。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li><code>wordList</code> 中的所有字符串 <strong>互不相同</strong></li>\n</ul>\n", "en": "<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:</p>\n\n<ul>\n\t<li>Every adjacent pair of words differs by a single letter.</li>\n\t<li>Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li>\n\t<li><code>s<sub>k</sub> == endWord</code></li>\n</ul>\n\n<p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>number of words</strong> in the <strong>shortest transformation sequence</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code><em>, or </em><code>0</code><em> if no such sequence exists.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>\n\t<li><code>endWord.length == beginWord.length</code></li>\n\t<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>\n\t<li><code>wordList[i].length == beginWord.length</code></li>\n\t<li><code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.</li>\n\t<li><code>beginWord != endWord</code></li>\n\t<li>All the words in <code>wordList</code> are <strong>unique</strong>.</li>\n</ul>\n"}}, "128": {"__typename": "QuestionLightNode", "acRate": 0.5189619826968832, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "128", "isFavor": false, "solutionNum": 3463, "title": "Longest Consecutive Sequence", "titleCn": "最长连续序列", "titleSlug": "longest-consecutive-sequence", "topicTags": [{"id": "n6a2i", "name": "Union Find", "slug": "union-find", "nameTranslated": "并查集", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 92, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>\n\n<p>请你设计并实现时间复杂度为 <code>O(n)</code><em> </em>的算法解决此问题。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [100,4,200,1,3,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>最长数字连续序列是 <code>[1, 2, 3, 4]。它的长度为 4。</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,3,7,2,5,8,4,6,0,1]\n<strong>输出：</strong>9\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest consecutive elements sequence.</em></p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [100,4,200,1,3,2]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Therefore its length is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,3,7,2,5,8,4,6,0,1]\n<strong>Output:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "129": {"__typename": "QuestionLightNode", "acRate": 0.7048056094253904, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "129", "isFavor": false, "solutionNum": 1993, "title": "Sum Root to Leaf Numbers", "titleCn": "求根节点到叶节点数字之和", "titleSlug": "sum-root-to-leaf-numbers", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 35, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。\n<div class=\"original__bRMd\">\n<div>\n<p>每条从根节点到叶节点的路径都代表一个数字：</p>\n\n<ul>\n\t<li>例如，从根节点到叶节点的路径 <code>1 -> 2 -> 3</code> 表示数字 <code>123</code> 。</li>\n</ul>\n\n<p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p>\n\n<p><strong>叶节点</strong> 是指没有子节点的节点。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg\" style=\"width: 212px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>25\n<strong>解释：</strong>\n从根到叶子节点路径 <code>1->2</code> 代表数字 <code>12</code>\n从根到叶子节点路径 <code>1->3</code> 代表数字 <code>13</code>\n因此，数字总和 = 12 + 13 = <code>25</code></pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [4,9,0,5,1]\n<strong>输出：</strong>1026\n<strong>解释：</strong>\n从根到叶子节点路径 <code>4->9->5</code> 代表数字 495\n从根到叶子节点路径 <code>4->9->1</code> 代表数字 491\n从根到叶子节点路径 <code>4->0</code> 代表数字 40\n因此，数字总和 = 495 + 491 + 40 = <code>1026</code>\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 1000]</code> 内</li>\n\t<li><code>0 <= Node.val <= 9</code></li>\n\t<li>树的深度不超过 <code>10</code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.</p>\n\n<p>Each root-to-leaf path in the tree represents a number.</p>\n\n<ul>\n\t<li>For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.</li>\n</ul>\n\n<p>Return <em>the total sum of all root-to-leaf numbers</em>. Test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p>\n\n<p>A <strong>leaf</strong> node is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg\" style=\"width: 212px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3]\n<strong>Output:</strong> 25\n<strong>Explanation:</strong>\nThe root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.\nThe root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.\nTherefore, sum = 12 + 13 = <code>25</code>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [4,9,0,5,1]\n<strong>Output:</strong> 1026\n<strong>Explanation:</strong>\nThe root-to-leaf path <code>4-&gt;9-&gt;5</code> represents the number 495.\nThe root-to-leaf path <code>4-&gt;9-&gt;1</code> represents the number 491.\nThe root-to-leaf path <code>4-&gt;0</code> represents the number 40.\nTherefore, sum = 495 + 491 + 40 = <code>1026</code>.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n\t<li>The depth of the tree will not exceed <code>10</code>.</li>\n</ul>\n"}}, "130": {"__typename": "QuestionLightNode", "acRate": 0.4642893248771677, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "130", "isFavor": false, "solutionNum": 2443, "title": "Surrounded Regions", "titleCn": "被围绕的区域", "titleSlug": "surrounded-regions", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "n6a2i", "name": "Union Find", "slug": "union-find", "nameTranslated": "并查集", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 48, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>'X'</code> 和 <code>'O'</code> ，找到所有被 <code>'X'</code> 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。\n<div class=\"original__bRMd\">\n<div>\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg\" style=\"width: 550px; height: 237px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n<strong>输出：</strong>[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n<strong>解释：</strong>被围绕的区间不会存在于边界上，换句话说，任何边界上的 <code>'O'</code> 都不会被填充为 <code>'X'</code>。 任何不在边界上，或不与边界上的 <code>'O'</code> 相连的 <code>'O'</code> 最终都会被填充为 <code>'X'</code>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [[\"X\"]]\n<strong>输出：</strong>[[\"X\"]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 <= m, n <= 200</code></li>\n\t<li><code>board[i][j]</code> 为 <code>'X'</code> 或 <code>'O'</code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>Given an <code>m x n</code> matrix <code>board</code> containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>, <em>capture all regions that are 4-directionally&nbsp;surrounded by</em> <code>&#39;X&#39;</code>.</p>\n\n<p>A region is <strong>captured</strong> by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg\" style=\"width: 550px; height: 237px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]\n<strong>Output:</strong> [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]\n<strong>Explanation:</strong> Notice that an &#39;O&#39; should not be flipped if:\n- It is on the border, or\n- It is adjacent to an &#39;O&#39; that should not be flipped.\nThe bottom &#39;O&#39; is on the border, so it is not flipped.\nThe other three &#39;O&#39; form a surrounded region, so they are flipped.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> board = [[&quot;X&quot;]]\n<strong>Output:</strong> [[&quot;X&quot;]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>board[i][j]</code> is <code>&#39;X&#39;</code> or <code>&#39;O&#39;</code>.</li>\n</ul>\n"}}, "131": {"__typename": "QuestionLightNode", "acRate": 0.7347295695388576, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "131", "isFavor": false, "solutionNum": 2063, "title": "Palindrome Partitioning", "titleCn": "分割回文串", "titleSlug": "palindrome-partitioning", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 55, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code>，请你将<em> </em><code>s</code><em> </em>分割成一些子串，使每个子串都是 <strong><span data-keyword=\"palindrome-string\">回文串</span></strong> 。返回 <code>s</code> 所有可能的分割方案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aab\"\n<strong>输出：</strong>[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a\"\n<strong>输出：</strong>[[\"a\"]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 16</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n", "en": "<p>Given a string <code>s</code>, partition <code>s</code> such that every <span data-keyword=\"substring-nonempty\">substring</span> of the partition is a <span data-keyword=\"palindrome-string\"><strong>palindrome</strong></span>. Return <em>all possible palindrome partitioning of </em><code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"aab\"\n<strong>Output:</strong> [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"a\"\n<strong>Output:</strong> [[\"a\"]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 16</code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n</ul>\n"}}, "132": {"__typename": "QuestionLightNode", "acRate": 0.4978003054972339, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "132", "isFavor": false, "solutionNum": 661, "title": "Palindrome Partitioning II", "titleCn": "分割回文串 II", "titleSlug": "palindrome-partitioning-ii", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 34, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是<span data-keyword=\"palindrome-string\">回文串</span>。</p>\n\n<p>返回符合要求的 <strong>最少分割次数</strong> 。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aab\"\n<strong>输出：</strong>1\n<strong>解释：</strong>只需一次分割就可将&nbsp;<em>s </em>分割成 [\"aa\",\"b\"] 这样两个回文子串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a\"\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ab\"\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n</div>\n</div>\n", "en": "<p>Given a string <code>s</code>, partition <code>s</code> such that every <span data-keyword=\"substring-nonempty\">substring</span> of the partition is a <span data-keyword=\"palindrome-string\">palindrome</span>.</p>\n\n<p>Return <em>the <strong>minimum</strong> cuts needed for a palindrome partitioning of</em> <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aab&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ab&quot;\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> consists of lowercase English letters only.</li>\n</ul>\n"}}, "133": {"__typename": "QuestionLightNode", "acRate": 0.7046352233361912, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "133", "isFavor": false, "solutionNum": 909, "title": "Clone Graph", "titleCn": "克隆图", "titleSlug": "clone-graph", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 53, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你无向&nbsp;<strong><a href=\"https://baike.baidu.com/item/连通图/6460995?fr=aladdin\" target=\"_blank\">连通</a>&nbsp;</strong>图中一个节点的引用，请你返回该图的&nbsp;<a href=\"https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin\" target=\"_blank\"><strong>深拷贝</strong></a>（克隆）。</p>\n\n<p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p>\n\n<pre>class Node {\n    public int val;\n    public List&lt;Node&gt; neighbors;\n}</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>测试用例格式：</strong></p>\n\n<p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p>\n\n<p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p>\n\n<p>给定节点将始终是图中的第一个节点（值为 1）。你必须将&nbsp;<strong>给定节点的拷贝&nbsp;</strong>作为对克隆图的引用返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png\" style=\"height: 500px; width: 500px;\"></p>\n\n<pre><strong>输入：</strong>adjList = [[2,4],[1,3],[2,4],[1,3]]\n<strong>输出：</strong>[[2,4],[1,3],[2,4],[1,3]]\n<strong>解释：\n</strong>图中有 4 个节点。\n节点 1 的值是 1，它有两个邻居：节点 2 和 4 。\n节点 2 的值是 2，它有两个邻居：节点 1 和 3 。\n节点 3 的值是 3，它有两个邻居：节点 2 和 4 。\n节点 4 的值是 4，它有两个邻居：节点 1 和 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph.png\" style=\"height: 148px; width: 163px;\"></p>\n\n<pre><strong>输入：</strong>adjList = [[]]\n<strong>输出：</strong>[[]]\n<strong>解释：</strong>输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>adjList = []\n<strong>输出：</strong>[]\n<strong>解释：</strong>这个图是空的，它不含任何节点。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/graph-1.png\" style=\"height: 133px; width: 272px;\"></p>\n\n<pre><strong>输入：</strong>adjList = [[2],[1]]\n<strong>输出：</strong>[[2],[1]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>节点数不超过 100 。</li>\n\t<li>每个节点值&nbsp;<code>Node.val</code> 都是唯一的，<code>1 &lt;= Node.val &lt;= 100</code>。</li>\n\t<li>无向图是一个<a href=\"https://baike.baidu.com/item/简单图/1680528?fr=aladdin\" target=\"_blank\">简单图</a>，这意味着图中没有重复的边，也没有自环。</li>\n\t<li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em> 的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em>&nbsp;的邻居。</li>\n\t<li>图是连通图，你可以从给定节点访问到所有节点。</li>\n</ol>\n", "en": "<p>Given a reference of a node in a <strong><a href=\"https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph\" target=\"_blank\">connected</a></strong> undirected graph.</p>\n\n<p>Return a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\"><strong>deep copy</strong></a> (clone) of the graph.</p>\n\n<p>Each node in the graph contains a value (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p>\n\n<pre>\nclass Node {\n    public int val;\n    public List&lt;Node&gt; neighbors;\n}\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Test case format:</strong></p>\n\n<p>For simplicity, each node&#39;s value is the same as the node&#39;s index (1-indexed). For example, the first node with <code>val == 1</code>, the second node with <code>val == 2</code>, and so on. The graph is represented in the test case using an adjacency list.</p>\n\n<p><b>An adjacency list</b> is a collection of unordered <b>lists</b> used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p>\n\n<p>The given node will always be the first node with <code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png\" style=\"width: 454px; height: 500px;\" />\n<pre>\n<strong>Input:</strong> adjList = [[2,4],[1,3],[2,4],[1,3]]\n<strong>Output:</strong> [[2,4],[1,3],[2,4],[1,3]]\n<strong>Explanation:</strong> There are 4 nodes in the graph.\n1st node (val = 1)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/07/graph.png\" style=\"width: 163px; height: 148px;\" />\n<pre>\n<strong>Input:</strong> adjList = [[]]\n<strong>Output:</strong> [[]]\n<strong>Explanation:</strong> Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> adjList = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> This an empty graph, it does not have any nodes.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the graph is in the range <code>[0, 100]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>Node.val</code> is unique for each node.</li>\n\t<li>There are no repeated edges and no self-loops in the graph.</li>\n\t<li>The Graph is connected and all nodes can be visited starting from the given node.</li>\n</ul>\n"}}, "134": {"__typename": "QuestionLightNode", "acRate": 0.4793841364521993, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "134", "isFavor": false, "solutionNum": 2179, "title": "Gas Station", "titleCn": "加油站", "titleSlug": "gas-station", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 57, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>在一条环路上有 <code>n</code>&nbsp;个加油站，其中第 <code>i</code>&nbsp;个加油站有汽油&nbsp;<code>gas[i]</code><em>&nbsp;</em>升。</p>\n\n<p>你有一辆油箱容量无限的的汽车，从第<em> </em><code>i</code><em> </em>个加油站开往第<em> </em><code>i+1</code><em>&nbsp;</em>个加油站需要消耗汽油&nbsp;<code>cost[i]</code><em>&nbsp;</em>升。你从其中的一个加油站出发，开始时油箱为空。</p>\n\n<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n<strong>输出:</strong> 3\n<strong>解释:\n</strong>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n因此，3 可为起始索引。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> gas = [2,3,4], cost = [3,4,3]\n<strong>输出:</strong> -1\n<strong>解释:\n</strong>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。\n我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油\n开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油\n开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油\n你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。\n因此，无论怎样，你都不可能绕环路行驶一周。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>gas.length == n</code></li>\n\t<li><code>cost.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= gas[i], cost[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>i<sup>th</sup></code> station is <code>gas[i]</code>.</p>\n\n<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>i<sup>th</sup></code> station to its next <code>(i + 1)<sup>th</sup></code> station. You begin the journey with an empty tank at one of the gas stations.</p>\n\n<p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station&#39;s index if you can travel around the circuit once in the clockwise direction, otherwise return</em> <code>-1</code>. If there exists a solution, it is <strong>guaranteed</strong> to be <strong>unique</strong></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> gas = [2,3,4], cost = [3,4,3]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong>\nYou can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet&#39;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can&#39;t travel around the circuit once no matter where you start.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == gas.length == cost.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= gas[i], cost[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "135": {"__typename": "QuestionLightNode", "acRate": 0.4899455071013914, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "135", "isFavor": false, "solutionNum": 1955, "title": "Candy", "titleCn": "分发糖果", "titleSlug": "candy", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 67, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p>\n\n<p>你需要按照以下要求，给这些孩子分发糖果：</p>\n\n<ul>\n\t<li>每个孩子至少分配到 <code>1</code> 个糖果。</li>\n\t<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>\n</ul>\n\n<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>ratings = [1,0,2]\n<strong>输出：</strong>5\n<strong>解释：</strong>你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>ratings = [1,2,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。\n     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == ratings.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= ratings[i] &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>There are <code>n</code> children standing in a line. Each child is assigned a rating value given in the integer array <code>ratings</code>.</p>\n\n<p>You are giving candies to these children subjected to the following requirements:</p>\n\n<ul>\n\t<li>Each child must have at least one candy.</li>\n\t<li>Children with a higher rating get more candies than their neighbors.</li>\n</ul>\n\n<p>Return <em>the minimum number of candies you need to have to distribute the candies to the children</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> ratings = [1,0,2]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> ratings = [1,2,2]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == ratings.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= ratings[i] &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n"}}, "136": {"__typename": "QuestionLightNode", "acRate": 0.7351976240759202, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "136", "isFavor": false, "solutionNum": 4650, "title": "Single Number", "titleCn": "只出现一次的数字", "titleSlug": "single-number", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 106, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>\n\n<p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,1]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong class=\"example\">示例 2 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,1,2,1,2]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong class=\"example\">示例 3 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-3 * 10<sup>4</sup> &lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li>除了某个元素只出现一次以外，其余每个元素均出现两次。</li>\n</ul>\n</div>\n</div>\n", "en": "<p>Given a <strong>non-empty</strong>&nbsp;array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.</p>\n\n<p>You must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,1]\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [4,1,2,1,2]\n<strong>Output:</strong> 4\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1]\n<strong>Output:</strong> 1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-3 * 10<sup>4</sup> &lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li>Each element in the array appears twice except for one element which appears only once.</li>\n</ul>\n"}}, "137": {"__typename": "QuestionLightNode", "acRate": 0.7226844428429872, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "137", "isFavor": false, "solutionNum": 1327, "title": "Single Number II", "titleCn": "只出现一次的数字 II", "titleSlug": "single-number-ii", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 48, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组&nbsp;<code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p>\n\n<p>你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,3,2]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,0,1,0,1,99]\n<strong>输出：</strong>99\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>nums</code> 中，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次</strong></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> where&nbsp;every element appears <strong>three times</strong> except for one, which appears <strong>exactly once</strong>. <em>Find the single element and return it</em>.</p>\n\n<p>You must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,3,2]\n<strong>Output:</strong> 3\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0,1,0,1,0,1,99]\n<strong>Output:</strong> 99\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Each element in <code>nums</code> appears exactly <strong>three times</strong> except for one element which appears <strong>once</strong>.</li>\n</ul>\n"}}, "138": {"__typename": "QuestionLightNode", "acRate": 0.667548701928674, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "138", "isFavor": false, "solutionNum": 1759, "title": "Copy List with Random Pointer", "titleCn": "随机链表的复制", "titleSlug": "copy-list-with-random-pointer", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 79, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>\n\n<p>构造这个链表的&nbsp;<strong><a href=\"https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin\" target=\"_blank\">深拷贝</a></strong>。&nbsp;深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点 </strong>。</p>\n\n<p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>\n\n<p>返回复制链表的头节点。</p>\n\n<p>用一个由&nbsp;<code>n</code>&nbsp;个节点组成的链表来表示输入/输出中的链表。每个节点用一个&nbsp;<code>[val, random_index]</code>&nbsp;表示：</p>\n\n<ul>\n\t<li><code>val</code>：一个表示&nbsp;<code>Node.val</code>&nbsp;的整数。</li>\n\t<li><code>random_index</code>：随机指针指向的节点索引（范围从&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n-1</code>）；如果不指向任何节点，则为&nbsp;&nbsp;<code>null</code>&nbsp;。</li>\n</ul>\n\n<p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png\" style=\"height: 142px; width: 700px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n<strong>输出：</strong>[[7,null],[13,0],[11,4],[10,2],[1,0]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png\" style=\"height: 114px; width: 700px;\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [[1,1],[2,1]]\n<strong>输出：</strong>[[1,1],[2,1]]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png\" style=\"height: 122px; width: 700px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>head = [[3,null],[3,0],[3,null]]\n<strong>输出：</strong>[[3,null],[3,0],[3,null]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 1000</code><meta charset=\"UTF-8\" /></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li><code>Node.random</code>&nbsp;为&nbsp;<code>null</code> 或指向链表中的节点。</li>\n</ul>\n\n<p>&nbsp;</p>\n", "en": "<p>A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p>\n\n<p>Construct a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p>\n\n<p>For example, if there are two nodes <code>X</code> and <code>Y</code> in the original list, where <code>X.random --&gt; Y</code>, then for the corresponding two nodes <code>x</code> and <code>y</code> in the copied list, <code>x.random --&gt; y</code>.</p>\n\n<p>Return <em>the head of the copied linked list</em>.</p>\n\n<p>The linked list is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>\n\n<ul>\n\t<li><code>val</code>: an integer representing <code>Node.val</code></li>\n\t<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) that the <code>random</code> pointer points to, or <code>null</code> if it does not point to any node.</li>\n</ul>\n\n<p>Your code will <strong>only</strong> be given the <code>head</code> of the original linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e1.png\" style=\"width: 700px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n<strong>Output:</strong> [[7,null],[13,0],[11,4],[10,2],[1,0]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e2.png\" style=\"width: 700px; height: 114px;\" />\n<pre>\n<strong>Input:</strong> head = [[1,1],[2,1]]\n<strong>Output:</strong> [[1,1],[2,1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e3.png\" style=\"width: 700px; height: 122px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> head = [[3,null],[3,0],[3,null]]\n<strong>Output:</strong> [[3,null],[3,0],[3,null]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li><code>Node.random</code> is <code>null</code> or is pointing to some node in the linked list.</li>\n</ul>\n"}}, "139": {"__typename": "QuestionLightNode", "acRate": 0.5532935169534433, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "139", "isFavor": false, "solutionNum": 2897, "title": "Word Break", "titleCn": "单词拆分", "titleSlug": "word-break", "topicTags": [{"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "vhos7", "name": "Memoization", "slug": "memoization", "nameTranslated": "记忆化搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 99, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code>&nbsp;则返回 <code>true</code>。</p>\n\n<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n<strong>输出:</strong> true\n<strong>解释:</strong> 返回 true 因为 \"leetcode\" 可以由 \"leet\" 和 \"code\" 拼接成。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n<strong>输出:</strong> true\n<strong>解释:</strong> 返回 true 因为 \"applepenapple\" 可以由 \"apple\" \"pen\" \"apple\" 拼接成。\n&nbsp;    注意，你可以重复使用字典中的单词。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>\n\t<li><code>s</code> 和 <code>wordDict[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li>\n</ul>\n", "en": "<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.\nNote that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n</ul>\n"}}, "140": {"__typename": "QuestionLightNode", "acRate": 0.5879172877185511, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "140", "isFavor": false, "solutionNum": 1067, "title": "Word Break II", "titleCn": "单词拆分 II", "titleSlug": "word-break-ii", "topicTags": [{"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "vhos7", "name": "Memoization", "slug": "memoization", "nameTranslated": "记忆化搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 57, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个字符串 <code>s</code> 和一个字符串字典<meta charset=\"UTF-8\" />&nbsp;<code>wordDict</code>&nbsp;，在字符串<meta charset=\"UTF-8\" />&nbsp;<code>s</code>&nbsp;中增加空格来构建一个句子，使得句子中所有的单词都在词典中。<strong>以任意顺序</strong> 返回所有这些可能的句子。</p>\n\n<p><strong>注意：</strong>词典中的同一个单词可能在分段中被重复使用多次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong>s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\n<strong>输出:</strong>[\"cats and dog\",\"cat sand dog\"]\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong>s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]\n<strong>输出:</strong>[\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]\n<strong>解释:</strong> 注意你可以重复使用字典中的单词。\n</pre>\n\n<p><strong class=\"example\">示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入:</strong>s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n<strong>输出:</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>\n\t<li><code>s</code>&nbsp;和&nbsp;<code>wordDict[i]</code>&nbsp;仅有小写英文字母组成</li>\n\t<li><code>wordDict</code>&nbsp;中所有字符串都 <strong>不同</strong></li>\n</ul>\n", "en": "<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsanddog&quot;, wordDict = [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]\n<strong>Output:</strong> [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pineapplepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]\n<strong>Output:</strong> [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]\n<strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n\t<li>Input is generated in a way that the length of the answer doesn&#39;t exceed&nbsp;10<sup>5</sup>.</li>\n</ul>\n"}}, "141": {"__typename": "QuestionLightNode", "acRate": 0.522903092332728, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "141", "isFavor": false, "solutionNum": 5779, "title": "Linked List Cycle", "titleCn": "环形链表", "titleSlug": "linked-list-cycle", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 132, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>\n\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递&nbsp;</strong>。仅仅是为了标识链表的实际情况。</p>\n\n<p><em>如果链表中存在环</em>&nbsp;，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [3,2,0,-4], pos = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], pos = 0\n<strong>输出：</strong>true\n<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1], pos = -1\n<strong>输出：</strong>false\n<strong>解释：</strong>链表中没有环。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围是 <code>[0, 10<sup>4</sup>]</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>\n", "en": "<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p>\n\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the&nbsp;<code>next</code>&nbsp;pointer. Internally, <code>pos</code>&nbsp;is used to denote the index of the node that&nbsp;tail&#39;s&nbsp;<code>next</code>&nbsp;pointer is connected to.&nbsp;<strong>Note that&nbsp;<code>pos</code>&nbsp;is not passed as a parameter</strong>.</p>\n\n<p>Return&nbsp;<code>true</code><em> if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" style=\"width: 300px; height: 97px; margin-top: 8px; margin-bottom: 8px;\" />\n<pre>\n<strong>Input:</strong> head = [3,2,0,-4], pos = 1\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"width: 141px; height: 74px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2], pos = 0\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 0th node.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"width: 45px; height: 45px;\" />\n<pre>\n<strong>Input:</strong> head = [1], pos = -1\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no cycle in the linked list.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>\n"}}, "142": {"__typename": "QuestionLightNode", "acRate": 0.5874129960000323, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "142", "isFavor": false, "solutionNum": 4581, "title": "Linked List Cycle II", "titleCn": "环形链表 II", "titleSlug": "linked-list-cycle-ii", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 84, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个链表的头节点 &nbsp;<code>head</code>&nbsp;，返回链表开始入环的第一个节点。&nbsp;<em>如果链表无环，则返回&nbsp;<code>null</code>。</em></p>\n\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>\n\n<p><strong>不允许修改 </strong>链表。</p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [3,2,0,-4], pos = 1\n<strong>输出：</strong>返回索引为 1 的链表节点\n<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2], pos = 0\n<strong>输出：</strong>返回索引为 0 的链表节点\n<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1], pos = -1\n<strong>输出：</strong>返回 null\n<strong>解释：</strong>链表中没有环。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p>\n", "en": "<p>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return </em><code>null</code>.</p>\n\n<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail&#39;s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p>\n\n<p><strong>Do not modify</strong> the linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png\" style=\"height: 145px; width: 450px;\" />\n<pre>\n<strong>Input:</strong> head = [3,2,0,-4], pos = 1\n<strong>Output:</strong> tail connects to node index 1\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the second node.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png\" style=\"height: 105px; width: 201px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2], pos = 0\n<strong>Output:</strong> tail connects to node index 0\n<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the first node.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png\" style=\"height: 65px; width: 65px;\" />\n<pre>\n<strong>Input:</strong> head = [1], pos = -1\n<strong>Output:</strong> no cycle\n<strong>Explanation:</strong> There is no cycle in the linked list.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you solve it using <code>O(1)</code> (i.e. constant) memory?</p>\n"}}, "143": {"__typename": "QuestionLightNode", "acRate": 0.6616028781416298, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "143", "isFavor": false, "solutionNum": 2155, "title": "Reorder List", "titleCn": "重排链表", "titleSlug": "reorder-list", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 75, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个单链表 <code>L</code><em> </em>的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>\n\n<pre>\nL<sub>0</sub> → L<sub>1</sub> → … → L<sub>n - 1</sub> → L<sub>n</sub>\n</pre>\n\n<p>请将其重新排列后变为：</p>\n\n<pre>\nL<sub>0</sub> → L<sub>n</sub> → L<sub>1</sub> → L<sub>n - 1</sub> → L<sub>2</sub> → L<sub>n - 2</sub> → …</pre>\n\n<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png\" style=\"width: 240px; \" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4]\n<strong>输出：</strong>[1,4,2,3]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626420320-YUiulT-image.png\" style=\"width: 320px; \" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5]\n<strong>输出：</strong>[1,5,2,4,3]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的长度范围为 <code>[1, 5 * 10<sup>4</sup>]</code></li>\n\t<li><code>1 &lt;= node.val &lt;= 1000</code></li>\n</ul>\n", "en": "<p>You are given the head of a singly linked-list. The list can be represented as:</p>\n\n<pre>\nL<sub>0</sub> &rarr; L<sub>1</sub> &rarr; &hellip; &rarr; L<sub>n - 1</sub> &rarr; L<sub>n</sub>\n</pre>\n\n<p><em>Reorder the list to be on the following form:</em></p>\n\n<pre>\nL<sub>0</sub> &rarr; L<sub>n</sub> &rarr; L<sub>1</sub> &rarr; L<sub>n - 1</sub> &rarr; L<sub>2</sub> &rarr; L<sub>n - 2</sub> &rarr; &hellip;\n</pre>\n\n<p>You may not modify the values in the list&#39;s nodes. Only nodes themselves may be changed.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg\" style=\"width: 422px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4]\n<strong>Output:</strong> [1,4,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/reorder2-linked-list.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5]\n<strong>Output:</strong> [1,5,2,4,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n"}}, "144": {"__typename": "QuestionLightNode", "acRate": 0.7181608106673635, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "144", "isFavor": false, "solutionNum": 4035, "title": "Binary Tree Preorder Traversal", "titleCn": "二叉树的前序遍历", "titleSlug": "binary-tree-preorder-traversal", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 55, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong><em> </em>遍历。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" style=\"width: 202px; height: 324px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,2,3]\n<strong>输出：</strong>[1,2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg\" style=\"width: 202px; height: 202px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg\" style=\"width: 202px; height: 202px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n\t<li><code>-100 <= Node.val <= 100</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p>\n", "en": "<p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" style=\"width: 125px; height: 200px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [1,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\n"}}, "145": {"__typename": "QuestionLightNode", "acRate": 0.7658170348138176, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "145", "isFavor": false, "solutionNum": 3066, "title": "Binary Tree Postorder Traversal", "titleCn": "二叉树的后序遍历", "titleSlug": "binary-tree-postorder-traversal", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 51, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历 </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg\" style=\"width: 127px; height: 200px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,2,3]\n<strong>输出：</strong>[3,2,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[0, 100]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p>\n", "en": "<p>Given the <code>root</code> of a&nbsp;binary tree, return <em>the postorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg\" style=\"width: 127px; height: 200px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [3,2,1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?"}}, "146": {"__typename": "QuestionLightNode", "acRate": 0.5359019023765105, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "146", "isFavor": false, "solutionNum": 4115, "title": "LRU Cache", "titleCn": "LRU 缓存", "titleSlug": "lru-cache", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "arqq05", "name": "Doubly-Linked List", "slug": "doubly-linked-list", "nameTranslated": "双向链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 177, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<div class=\"title__3Vvk\">请你设计并实现一个满足&nbsp; <a href=\"https://baike.baidu.com/item/LRU\" target=\"_blank\">LRU (最近最少使用) 缓存</a> 约束的数据结构。</div>\n\n<div class=\"title__3Vvk\">实现 <code>LRUCache</code> 类：</div>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量&nbsp;<code>capacity</code> 初始化 LRU 缓存</li>\n\t<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>\n\t<li><code>void put(int key, int value)</code>&nbsp;如果关键字&nbsp;<code>key</code> 已经存在，则变更其数据值&nbsp;<code>value</code> ；如果不存在，则向缓存中插入该组&nbsp;<code>key-value</code> 。如果插入操作导致关键字数量超过&nbsp;<code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>\n</ul>\n\n<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n<strong>输出</strong>\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n<strong>解释</strong>\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= capacity &lt;= 3000</code></li>\n\t<li><code>0 &lt;= key &lt;= 10000</code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>\n\t<li>最多调用 <code>2 * 10<sup>5</sup></code> 次 <code>get</code> 和 <code>put</code></li>\n</ul>\n", "en": "<p>Design a data structure that follows the constraints of a <strong><a href=\"https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\" target=\"_blank\">Least Recently Used (LRU) cache</a></strong>.</p>\n\n<p>Implement the <code>LRUCache</code> class:</p>\n\n<ul>\n\t<li><code>LRUCache(int capacity)</code> Initialize the LRU cache with <strong>positive</strong> size <code>capacity</code>.</li>\n\t<li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li>\n\t<li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, <strong>evict</strong> the least recently used key.</li>\n</ul>\n\n<p>The functions <code>get</code> and <code>put</code> must each run in <code>O(1)</code> average time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n<strong>Output</strong>\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n<strong>Explanation</strong>\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= capacity &lt;= 3000</code></li>\n\t<li><code>0 &lt;= key &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>5</sup></code></li>\n\t<li>At most <code>2 * 10<sup>5</sup></code> calls will be made to <code>get</code> and <code>put</code>.</li>\n</ul>\n"}}, "147": {"__typename": "QuestionLightNode", "acRate": 0.6966538325143118, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "147", "isFavor": false, "solutionNum": 1184, "title": "Insertion Sort List", "titleCn": "对链表进行插入排序", "titleSlug": "insertion-sort-list", "topicTags": [{"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 35, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定单个链表的头<meta charset=\"UTF-8\" />&nbsp;<code>head</code>&nbsp;，使用 <strong>插入排序</strong> 对链表进行排序，并返回&nbsp;<em>排序后链表的头</em>&nbsp;。</p>\n\n<p><strong>插入排序</strong>&nbsp;算法的步骤:</p>\n\n<ol>\n\t<li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li>\n\t<li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li>\n\t<li>重复直到所有输入数据插入完为止。</li>\n</ol>\n\n<p>下面是插入排序算法的一个图形示例。部分排序的列表(黑色)最初只包含列表中的第一个元素。每次迭代时，从输入数据中删除一个元素(红色)，并就地插入已排序的列表中。</p>\n\n<p>对链表进行插入排序。</p>\n\n<p><img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif\" /></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> head = [4,2,1,3]\n<strong>输出:</strong> [1,2,3,4]</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> head = [-1,5,3,4,0]\n<strong>输出:</strong> [-1,0,3,4,5]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li>列表中的节点数在&nbsp;<code>[1, 5000]</code>范围内</li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n", "en": "<p>Given the <code>head</code> of a singly linked list, sort the list using <strong>insertion sort</strong>, and return <em>the sorted list&#39;s head</em>.</p>\n\n<p>The steps of the <strong>insertion sort</strong> algorithm:</p>\n\n<ol>\n\t<li>Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.</li>\n\t<li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.</li>\n\t<li>It repeats until no input elements remain.</li>\n</ol>\n\n<p>The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.</p>\n<img alt=\"\" src=\"https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif\" style=\"height:180px; width:300px\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg\" style=\"width: 422px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [4,2,1,3]\n<strong>Output:</strong> [1,2,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [-1,5,3,4,0]\n<strong>Output:</strong> [-1,0,3,4,5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 5000]</code>.</li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n"}}, "148": {"__typename": "QuestionLightNode", "acRate": 0.6556053917797844, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "148", "isFavor": false, "solutionNum": 2560, "title": "Sort List", "titleCn": "排序链表", "titleSlug": "sort-list", "topicTags": [{"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "xp2r1vv", "name": "Merge Sort", "slug": "merge-sort", "nameTranslated": "归并排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 90, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你链表的头结点&nbsp;<code>head</code>&nbsp;，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg\" style=\"width: 450px;\" />\n<pre>\n<b>输入：</b>head = [4,2,1,3]\n<b>输出：</b>[1,2,3,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg\" style=\"width: 550px;\" />\n<pre>\n<b>输入：</b>head = [-1,5,3,4,0]\n<b>输出：</b>[-1,0,3,4,5]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<b>输入：</b>head = []\n<b>输出：</b>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li>链表中节点的数目在范围&nbsp;<code>[0, 5 * 10<sup>4</sup>]</code>&nbsp;内</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>进阶：</b>你可以在&nbsp;<code>O(n&nbsp;log&nbsp;n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>\n", "en": "<p>Given the <code>head</code> of a linked list, return <em>the list after sorting it in <strong>ascending order</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg\" style=\"width: 450px; height: 194px;\" />\n<pre>\n<strong>Input:</strong> head = [4,2,1,3]\n<strong>Output:</strong> [1,2,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg\" style=\"width: 550px; height: 184px;\" />\n<pre>\n<strong>Input:</strong> head = [-1,5,3,4,0]\n<strong>Output:</strong> [-1,0,3,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?</p>\n"}}, "149": {"__typename": "QuestionLightNode", "acRate": 0.40313981694673495, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "149", "isFavor": false, "solutionNum": 853, "title": "Max Points on a Line", "titleCn": "直线上最多的点数", "titleSlug": "max-points-on-a-line", "topicTags": [{"id": "vlt55", "name": "Geometry", "slug": "geometry", "nameTranslated": "几何", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 65, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示 <strong>X-Y</strong> 平面上的一个点。求最多有多少个点在同一条直线上。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg\" style=\"width: 300px; height: 294px;\" />\n<pre>\n<strong>输入：</strong>points = [[1,1],[2,2],[3,3]]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg\" style=\"width: 300px; height: 294px;\" />\n<pre>\n<strong>输入：</strong>points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n<strong>输出：</strong>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= points.length <= 300</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-10<sup>4</sup> <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>4</sup></code></li>\n\t<li><code>points</code> 中的所有点 <strong>互不相同</strong></li>\n</ul>\n", "en": "<p>Given an array of <code>points</code> where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents a point on the <strong>X-Y</strong> plane, return <em>the maximum number of points that lie on the same straight line</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg\" style=\"width: 300px; height: 294px;\" />\n<pre>\n<strong>Input:</strong> points = [[1,1],[2,2],[3,3]]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg\" style=\"width: 300px; height: 294px;\" />\n<pre>\n<strong>Input:</strong> points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 300</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>All the <code>points</code> are <strong>unique</strong>.</li>\n</ul>\n"}}, "150": {"__typename": "QuestionLightNode", "acRate": 0.5416221706888051, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "150", "isFavor": false, "solutionNum": 2331, "title": "Evaluate Reverse Polish Notation", "titleCn": "逆波兰表达式求值", "titleSlug": "evaluate-reverse-polish-notation", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 62, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串数组 <code>tokens</code> ，表示一个根据&nbsp;<a href=\"https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437\" target=\"_blank\">逆波兰表示法</a> 表示的算术表达式。</p>\n\n<p>请你计算该表达式。返回一个表示表达式值的整数。</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>有效的算符为 <code>'+'</code>、<code>'-'</code>、<code>'*'</code> 和 <code>'/'</code> 。</li>\n\t<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>\n\t<li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li>\n\t<li>表达式中不含除零运算。</li>\n\t<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>\n\t<li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n<strong>输出：</strong>9\n<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\n<strong>输出：</strong>6\n<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\n<strong>输出：</strong>22\n<strong>解释：</strong>该算式转化为常见的中缀算术表达式为：\n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tokens.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>tokens[i]</code>&nbsp;是一个算符（<code>\"+\"</code>、<code>\"-\"</code>、<code>\"*\"</code> 或 <code>\"/\"</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>逆波兰表达式：</strong></p>\n\n<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>\n\n<ul>\n\t<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>\n\t<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>\n</ul>\n\n<p>逆波兰表达式主要有以下两个优点：</p>\n\n<ul>\n\t<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>\n\t<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li>\n</ul>\n", "en": "<p>You are given an array of strings <code>tokens</code> that represents an arithmetic expression in a <a href=\"http://en.wikipedia.org/wiki/Reverse_Polish_notation\" target=\"_blank\">Reverse Polish Notation</a>.</p>\n\n<p>Evaluate the expression. Return <em>an integer that represents the value of the expression</em>.</p>\n\n<p><strong>Note</strong> that:</p>\n\n<ul>\n\t<li>The valid operators are <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, and <code>&#39;/&#39;</code>.</li>\n\t<li>Each operand may be an integer or another expression.</li>\n\t<li>The division between two integers always <strong>truncates toward zero</strong>.</li>\n\t<li>There will not be any division by zero.</li>\n\t<li>The input represents a valid arithmetic expression in a reverse polish notation.</li>\n\t<li>The answer and all the intermediate calculations can be represented in a <strong>32-bit</strong> integer.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> ((2 + 1) * 3) = 9\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> (4 + (13 / 5)) = 6\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]\n<strong>Output:</strong> 22\n<strong>Explanation:</strong> ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tokens.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>tokens[i]</code> is either an operator: <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code>, <code>&quot;*&quot;</code>, or <code>&quot;/&quot;</code>, or an integer in the range <code>[-200, 200]</code>.</li>\n</ul>\n"}}, "151": {"__typename": "QuestionLightNode", "acRate": 0.5490705158401555, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "151", "isFavor": false, "solutionNum": 3905, "title": "Reverse Words in a String", "titleCn": "反转字符串中的单词", "titleSlug": "reverse-words-in-a-string", "topicTags": [{"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 82, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p>\n\n<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>\n\n<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p>\n\n<p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"<code>the sky is blue</code>\"\n<strong>输出：</strong>\"<code>blue is sky the</code>\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \" &nbsp;hello world &nbsp;\"\n<strong>输出：</strong>\"world hello\"\n<strong>解释：</strong>反转后的字符串中不能存在前导空格和尾随空格。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a good &nbsp; example\"\n<strong>输出：</strong>\"example good a\"\n<strong>解释：</strong>如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 包含英文大小写字母、数字和空格 <code>' '</code></li>\n\t<li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li>\n</ul>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用&nbsp;<code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p>\n", "en": "<p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>\n\n<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p>\n\n<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>\n\n<p><b>Note</b> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;the sky is blue&quot;\n<strong>Output:</strong> &quot;blue is sky the&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;  hello world  &quot;\n<strong>Output:</strong> &quot;world hello&quot;\n<strong>Explanation:</strong> Your reversed string should not contain leading or trailing spaces.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a good   example&quot;\n<strong>Output:</strong> &quot;example good a&quot;\n<strong>Explanation:</strong> You need to reduce multiple spaces between two words to a single space in the reversed string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> contains English letters (upper-case and lower-case), digits, and spaces <code>&#39; &#39;</code>.</li>\n\t<li>There is <strong>at least one</strong> word in <code>s</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b data-stringify-type=\"bold\">Follow-up:&nbsp;</b>If the string data type is mutable in your language, can&nbsp;you solve it&nbsp;<b data-stringify-type=\"bold\">in-place</b>&nbsp;with&nbsp;<code data-stringify-type=\"code\">O(1)</code>&nbsp;extra space?</p>\n"}}, "152": {"__typename": "QuestionLightNode", "acRate": 0.43168094525142153, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "152", "isFavor": false, "solutionNum": 2364, "title": "Maximum Product Subarray", "titleCn": "乘积最大子数组", "titleSlug": "maximum-product-subarray", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 87, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code>&nbsp;，请你找出数组中乘积最大的非空连续<span data-keyword=\"subarray-nonempty\">子数组</span>（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>\n\n<p>测试用例的答案是一个&nbsp;<strong>32-位</strong> 整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [2,3,-2,4]\n<strong>输出:</strong> <code>6</code>\n<strong>解释:</strong>&nbsp;子数组 [2,3] 有最大乘积 6。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [-2,0,-1]\n<strong>输出:</strong> 0\n<strong>解释:</strong>&nbsp;结果不能为 2, 因为 [-2,-1] 不是子数组。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li><code>nums</code> 的任何前缀或后缀的乘积都 <strong>保证</strong>&nbsp;是一个 <strong>32-位</strong> 整数</li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code>, find a <span data-keyword=\"subarray-nonempty\">subarray</span> that has the largest product, and return <em>the product</em>.</p>\n\n<p>The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,-2,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> [2,3] has the largest product 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-2,0,-1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The result cannot be 2, because [-2,-1] is not a subarray.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n"}}, "153": {"__typename": "QuestionLightNode", "acRate": 0.5747373043505536, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "153", "isFavor": false, "solutionNum": 2808, "title": "Find Minimum in Rotated Sorted Array", "titleCn": "寻找旋转排序数组中的最小值", "titleSlug": "find-minimum-in-rotated-sorted-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 78, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：\n<ul>\n\t<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>\n\t<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>\n</ul>\n\n<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>\n\n<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>\n\n<p>你必须设计一个时间复杂度为&nbsp;<code>O(log n)</code> 的算法解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,4,5,1,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,5,6,7,0,1,2]\n<strong>输出：</strong>0\n<strong>解释：</strong>原数组为 [0,1,2,4,5,6,7] ，旋转 3 次得到输入数组。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [11,13,15,17]\n<strong>输出：</strong>11\n<strong>解释：</strong>原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n\t<li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>\n</ul>\n", "en": "<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:</p>\n\n<ul>\n\t<li><code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.</li>\n\t<li><code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>\n</ul>\n\n<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>\n\n<p>Given the sorted rotated array <code>nums</code> of <strong>unique</strong> elements, return <em>the minimum element of this array</em>.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(log n) time.</code></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,5,1,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The original array was [1,2,3,4,5] rotated 3 times.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,5,6,7,0,1,2]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [11,13,15,17]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> The original array was [11,13,15,17] and it was rotated 4 times. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>\n</ul>\n"}}, "154": {"__typename": "QuestionLightNode", "acRate": 0.5214112945056265, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "154", "isFavor": false, "solutionNum": 1386, "title": "Find Minimum in Rotated Sorted Array II", "titleCn": "寻找旋转排序数组中的最小值 II", "titleSlug": "find-minimum-in-rotated-sorted-array-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 38, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,4,4,5,6,7]</code> 在变化后可能得到：\n<ul>\n\t<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,4]</code></li>\n\t<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,4,4,5,6,7]</code></li>\n</ul>\n\n<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>\n\n<p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>\n\n<p>你必须尽可能减少整个过程的操作步骤。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,5]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2,0,1]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>这道题与 <a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/\">寻找旋转排序数组中的最小值</a> 类似，但 <code>nums</code> 可能包含重复元素。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</p>\n", "en": "<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,4,4,5,6,7]</code> might become:</p>\n\n<ul>\n\t<li><code>[4,5,6,7,0,1,4]</code> if it was rotated <code>4</code> times.</li>\n\t<li><code>[0,1,4,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>\n</ul>\n\n<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>\n\n<p>Given the sorted rotated array <code>nums</code> that may contain <strong>duplicates</strong>, return <em>the minimum element of this array</em>.</p>\n\n<p>You must decrease the overall operation steps as much as possible.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,3,5]\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,2,0,1]\n<strong>Output:</strong> 0\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> This problem is similar to&nbsp;<a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/\" target=\"_blank\">Find Minimum in Rotated Sorted Array</a>, but&nbsp;<code>nums</code> may contain <strong>duplicates</strong>. Would this affect the runtime complexity? How and why?</p>\n\n<p>&nbsp;</p>\n"}}, "155": {"__typename": "QuestionLightNode", "acRate": 0.5967868236412871, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "155", "isFavor": false, "solutionNum": 2872, "title": "Min Stack", "titleCn": "最小栈", "titleSlug": "min-stack", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 105, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>\n\n<p>实现 <code>MinStack</code> 类:</p>\n\n<ul>\n\t<li><code>MinStack()</code> 初始化堆栈对象。</li>\n\t<li><code>void push(int val)</code> 将元素val推入堆栈。</li>\n\t<li><code>void pop()</code> 删除堆栈顶部的元素。</li>\n\t<li><code>int top()</code> 获取堆栈顶部的元素。</li>\n\t<li><code>int getMin()</code> 获取堆栈中的最小元素。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n<strong>输出：</strong>\n[null,null,null,null,-3,null,0,-2]\n\n<strong>解释：</strong>\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --&gt; 返回 -3.\nminStack.pop();\nminStack.top();      --&gt; 返回 0.\nminStack.getMin();   --&gt; 返回 -2.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n\t<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li>\n\t<li><code>push</code>,&nbsp;<code>pop</code>,&nbsp;<code>top</code>, and&nbsp;<code>getMin</code>最多被调用&nbsp;<code>3 * 10<sup>4</sup></code>&nbsp;次</li>\n</ul>\n", "en": "<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>\n\n<p>Implement the <code>MinStack</code> class:</p>\n\n<ul>\n\t<li><code>MinStack()</code> initializes the stack object.</li>\n\t<li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li>\n\t<li><code>void pop()</code> removes the element on the top of the stack.</li>\n\t<li><code>int top()</code> gets the top element of the stack.</li>\n\t<li><code>int getMin()</code> retrieves the minimum element in the stack.</li>\n</ul>\n\n<p>You must implement a solution with <code>O(1)</code> time complexity for each function.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n<strong>Output</strong>\n[null,null,null,null,-3,null,0,-2]\n\n<strong>Explanation</strong>\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <strong>non-empty</strong> stacks.</li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>.</li>\n</ul>\n"}}, "156": {"__typename": "QuestionLightNode", "acRate": 0.7335607795485348, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "156", "isFavor": false, "solutionNum": 254, "title": "Binary Tree Upside Down", "titleCn": "上下翻转二叉树", "titleSlug": "binary-tree-upside-down", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 14, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1675928806-JBDLqI-Twitch.png", "slug": "twitch", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "157": {"__typename": "QuestionLightNode", "acRate": 0.5466261942675159, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "157", "isFavor": false, "solutionNum": 140, "title": "Read N Characters Given Read4", "titleCn": "用 Read4 读取 N 个字符", "titleSlug": "read-n-characters-given-read4", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "0qo9zm", "name": "Interactive", "slug": "interactive", "nameTranslated": "交互", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 22, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "158": {"__typename": "QuestionLightNode", "acRate": 0.6005117365669151, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "158", "isFavor": false, "solutionNum": 110, "title": "Read N Characters Given read4 II - Call Multiple Times", "titleCn": "用 Read4 读取 N 个字符 II - 多次调用", "titleSlug": "read-n-characters-given-read4-ii-call-multiple-times", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "0qo9zm", "name": "Interactive", "slug": "interactive", "nameTranslated": "交互", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 27, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/5bd12e3e40eff4a21834cb14e5ad7979abde52ba3a998e7f1e00e3cbb81a4fca-lyft.jpg", "slug": "lyft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "159": {"__typename": "QuestionLightNode", "acRate": 0.5619492515128994, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "159", "isFavor": false, "solutionNum": 375, "title": "Longest Substring with At Most Two Distinct Characters", "titleCn": "至多包含两个不同字符的最长子串", "titleSlug": "longest-substring-with-at-most-two-distinct-characters", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 32, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "160": {"__typename": "QuestionLightNode", "acRate": 0.648086771020143, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "160", "isFavor": false, "solutionNum": 4376, "title": "Intersection of Two Linked Lists", "titleCn": "相交链表", "titleSlug": "intersection-of-two-linked-lists", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 92, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个单链表的头节点&nbsp;<code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>\n\n<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>\n\n<p><a href=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" style=\"height:130px; width:400px\" /></a></p>\n\n<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>\n\n<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>\n\n<p><strong>自定义评测：</strong></p>\n\n<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>\n\n<ul>\n\t<li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>\n\t<li><code>listA</code> - 第一个链表</li>\n\t<li><code>listB</code> - 第二个链表</li>\n\t<li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>\n\t<li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>\n</ul>\n\n<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png\" style=\"height:130px; width:400px\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n<strong>输出：</strong>Intersected at '8'\n<strong>解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中<font size=\"1\">第三个</font>节点，B 中第四个节点) 在内存中指向相同的位置。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png\" style=\"height:136px; width:350px\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal&nbsp;= 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>输出：</strong>Intersected at '2'\n<strong>解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png\" target=\"_blank\"><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\" style=\"height:126px; width:200px\" /></a></p>\n\n<pre>\n<strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>输出：</strong>null\n<strong>解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>listA</code> 中节点数目为 <code>m</code></li>\n\t<li><code>listB</code> 中节点数目为 <code>n</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= skipA &lt;= m</code></li>\n\t<li><code>0 &lt;= skipB &lt;= n</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>\n\t<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>\n", "en": "<p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p>\n\n<p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_statement.png\" style=\"width: 500px; height: 162px;\" />\n<p>The test cases are generated such that there are no cycles anywhere in the entire linked structure.</p>\n\n<p><strong>Note</strong> that the linked lists must <strong>retain their original structure</strong> after the function returns.</p>\n\n<p><strong>Custom Judge:</strong></p>\n\n<p>The inputs to the <strong>judge</strong> are given as follows (your program is <strong>not</strong> given these inputs):</p>\n\n<ul>\n\t<li><code>intersectVal</code> - The value of the node where the intersection occurs. This is <code>0</code> if there is no intersected node.</li>\n\t<li><code>listA</code> - The first linked list.</li>\n\t<li><code>listB</code> - The second linked list.</li>\n\t<li><code>skipA</code> - The number of nodes to skip ahead in <code>listA</code> (starting from the head) to get to the intersected node.</li>\n\t<li><code>skipB</code> - The number of nodes to skip ahead in <code>listB</code> (starting from the head) to get to the intersected node.</li>\n</ul>\n\n<p>The judge will then create the linked structure based on these inputs and pass the two heads, <code>headA</code> and <code>headB</code> to your program. If you correctly return the intersected node, then your solution will be <strong>accepted</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png\" style=\"width: 500px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n<strong>Output:</strong> Intersected at &#39;8&#39;\n<strong>Explanation:</strong> The intersected node&#39;s value is 8 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n- Note that the intersected node&#39;s value is not 1 because the nodes with value 1 in A and B (2<sup>nd</sup> node in A and 3<sup>rd</sup> node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in A and B (3<sup>rd</sup> node in A and 4<sup>th</sup> node in B) point to the same location in memory.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png\" style=\"width: 500px; height: 194px;\" />\n<pre>\n<strong>Input:</strong> intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n<strong>Output:</strong> Intersected at &#39;2&#39;\n<strong>Explanation:</strong> The intersected node&#39;s value is 2 (note that this must not be 0 if the two lists intersect).\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png\" style=\"width: 300px; height: 189px;\" />\n<pre>\n<strong>Input:</strong> intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n<strong>Output:</strong> No intersection\n<strong>Explanation:</strong> From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\nExplanation: The two lists do not intersect, so return null.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes of <code>listA</code> is in the <code>m</code>.</li>\n\t<li>The number of nodes of <code>listB</code> is in the <code>n</code>.</li>\n\t<li><code>1 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= skipA &lt;&nbsp;m</code></li>\n\t<li><code>0 &lt;= skipB &lt;&nbsp;n</code></li>\n\t<li><code>intersectVal</code> is <code>0</code> if <code>listA</code> and <code>listB</code> do not intersect.</li>\n\t<li><code>intersectVal == listA[skipA] == listB[skipB]</code> if <code>listA</code> and <code>listB</code> intersect.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you write a solution that runs in <code>O(m + n)</code> time and use only <code>O(1)</code> memory?"}}, "161": {"__typename": "QuestionLightNode", "acRate": 0.34018706342002447, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "161", "isFavor": false, "solutionNum": 222, "title": "One Edit Distance", "titleCn": "相隔为 1 的编辑距离", "titleSlug": "one-edit-distance", "topicTags": [{"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 34, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "162": {"__typename": "QuestionLightNode", "acRate": 0.49469409044015844, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "162", "isFavor": false, "solutionNum": 2322, "title": "Find Peak Element", "titleCn": "寻找峰值", "titleSlug": "find-peak-element", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 78, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>峰值元素是指其值严格大于左右相邻值的元素。</p>\n\n<p>给你一个整数数组&nbsp;<code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p>\n\n<p>你可以假设&nbsp;<code>nums[-1] = nums[n] = -∞</code> 。</p>\n\n<p>你必须实现时间复杂度为 <code>O(log n)</code><em> </em>的算法来解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = <code>[1,2,3,1]</code>\n<strong>输出：</strong>2\n<strong>解释：</strong>3 是峰值元素，你的函数应该返回其索引 2。</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = <code>[</code>1,2,1,3,5,6,4]\n<strong>输出：</strong>1 或 5 \n<strong>解释：</strong>你的函数可以返回索引 1，其峰值元素为 2；\n&nbsp;    或者返回索引 5， 其峰值元素为 6。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>对于所有有效的 <code>i</code> 都有 <code>nums[i] != nums[i + 1]</code></li>\n</ul>\n", "en": "<p>A peak element is an element that is strictly greater than its neighbors.</p>\n\n<p>Given a <strong>0-indexed</strong> integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to <strong>any of the peaks</strong>.</p>\n\n<p>You may imagine that <code>nums[-1] = nums[n] = -&infin;</code>. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.</p>\n\n<p>You must write an algorithm that runs in <code>O(log n)</code> time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> 3 is a peak element and your function should return the index number 2.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,3,5,6,4]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>nums[i] != nums[i + 1]</code> for all valid <code>i</code>.</li>\n</ul>\n"}}, "163": {"__typename": "QuestionLightNode", "acRate": 0.35990831214027574, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "163", "isFavor": false, "solutionNum": 295, "title": "Missing Ranges", "titleCn": "缺失的区间", "titleSlug": "missing-ranges", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 26, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "164": {"__typename": "QuestionLightNode", "acRate": 0.5995110269060259, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "164", "isFavor": false, "solutionNum": 706, "title": "Maximum Gap", "titleCn": "最大间距", "titleSlug": "maximum-gap", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "eqnkri", "name": "Bucket Sort", "slug": "bucket-sort", "nameTranslated": "桶排序", "__typename": "CommonTagNode"}, {"id": "gqaly2", "name": "Radix Sort", "slug": "radix-sort", "nameTranslated": "基数排序", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 44, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个无序的数组&nbsp;<code>nums</code>，返回 <em>数组在排序之后，相邻元素之间最大的差值</em> 。如果数组元素个数小于 2，则返回 <code>0</code> 。</p>\n\n<p>您必须编写一个在「线性时间」内运行并使用「线性额外空间」的算法。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [3,6,9,1]\n<strong>输出:</strong> 3\n<strong>解释:</strong> 排序后的数组是 [1,3,6,9]<strong><em>, </em></strong>其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [10]\n<strong>输出:</strong> 0\n<strong>解释:</strong> 数组元素个数小于 2，因此返回 0。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code>, return <em>the maximum difference between two successive elements in its sorted form</em>. If the array contains less than two elements, return <code>0</code>.</p>\n\n<p>You must write an algorithm that runs in linear time and uses linear extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,6,9,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The array contains less than 2 elements, therefore return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "165": {"__typename": "QuestionLightNode", "acRate": 0.5212082979937158, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "165", "isFavor": false, "solutionNum": 1378, "title": "Compare Version Numbers", "titleCn": "比较版本号", "titleSlug": "compare-version-numbers", "topicTags": [{"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 64, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们。</p>\n\n<p>版本号由一个或多个修订号组成，各修订号由一个 <code>'.'</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p>\n\n<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 <code>1</code> 和修订号 <code>001</code> <strong>相等 </strong>。如果版本号没有指定某个下标处的修订号，则该修订号视为 <code>0</code> 。例如，版本 <code>1.0</code> 小于版本 <code>1.1</code> ，因为它们下标为 <code>0</code> 的修订号相同，而下标为 <code>1</code> 的修订号分别为 <code>0</code> 和 <code>1</code> ，<code>0 &lt; 1</code> 。</p>\n\n<p>返回规则如下：</p>\n\n<ul>\n\t<li>如果&nbsp;<code><em>version1&nbsp;</em>&gt;&nbsp;<em>version2</em></code>&nbsp;返回&nbsp;<code>1</code>，</li>\n\t<li>如果&nbsp;<code><em>version1&nbsp;</em>&lt;&nbsp;<em>version2</em></code> 返回 <code>-1</code>，</li>\n\t<li>除此之外返回 <code>0</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = \"1.01\", version2 = \"1.001\"\n<strong>输出：</strong>0\n<strong>解释：</strong>忽略前导零，\"01\" 和 \"001\" 都表示相同的整数 \"1\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = \"1.0\", version2 = \"1.0.0\"\n<strong>输出：</strong>0\n<strong>解释：</strong>version1 没有指定下标为 2 的修订号，即视为 \"0\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>version1 = \"0.1\", version2 = \"1.1\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>version1 中下标为 0 的修订号是 \"0\"，version2 中下标为 0 的修订号是 \"1\" 。0 &lt; 1，所以 version1 &lt; version2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= version1.length, version2.length &lt;= 500</code></li>\n\t<li><code>version1</code> 和 <code>version2</code> 仅包含数字和 <code>'.'</code></li>\n\t<li><code>version1</code> 和 <code>version2</code> 都是 <strong>有效版本号</strong></li>\n\t<li><code>version1</code> 和 <code>version2</code> 的所有修订号都可以存储在 <strong>32 位整数</strong> 中</li>\n</ul>\n", "en": "<p>Given two version numbers,&nbsp;<code>version1</code> and <code>version2</code>, compare them.</p>\n\n<ul>\n</ul>\n\n<p>Version numbers consist of <strong>one or more revisions</strong> joined by a dot&nbsp;<code>&#39;.&#39;</code>. Each revision&nbsp;consists of <strong>digits</strong>&nbsp;and may contain leading <strong>zeros</strong>. Every revision contains <strong>at least one character</strong>. Revisions are <strong>0-indexed from left to right</strong>, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example&nbsp;<code>2.5.33</code>&nbsp;and&nbsp;<code>0.1</code>&nbsp;are valid version numbers.</p>\n\n<p>To compare version numbers, compare their revisions in <strong>left-to-right order</strong>. Revisions are compared using their&nbsp;<strong>integer value ignoring any leading zeros</strong>. This means that revisions&nbsp;<code>1</code>&nbsp;and&nbsp;<code>001</code>&nbsp;are considered&nbsp;<strong>equal</strong>. If a version number does not specify a revision at an index, then&nbsp;<strong>treat the revision as&nbsp;<code>0</code></strong>. For example, version&nbsp;<code>1.0</code> is less than version&nbsp;<code>1.1</code>&nbsp;because their revision 0s are the same, but their revision 1s are&nbsp;<code>0</code>&nbsp;and&nbsp;<code>1</code>&nbsp;respectively, and&nbsp;<code>0 &lt; 1</code>.</p>\n\n<p><em>Return the following:</em></p>\n\n<ul>\n\t<li>If <code>version1 &lt; version2</code>, return <code>-1</code>.</li>\n\t<li>If <code>version1 &gt; version2</code>, return <code>1</code>.</li>\n\t<li>Otherwise, return <code>0</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Ignoring leading zeroes, both &quot;01&quot; and &quot;001&quot; represent the same integer &quot;1&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> version1 does not specify revision 2, which means it is treated as &quot;0&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> version1&#39;s revision 0 is &quot;0&quot;, while version2&#39;s revision 0 is &quot;1&quot;. 0 &lt; 1, so version1 &lt; version2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= version1.length, version2.length &lt;= 500</code></li>\n\t<li><code>version1</code> and <code>version2</code>&nbsp;only contain digits and <code>&#39;.&#39;</code>.</li>\n\t<li><code>version1</code> and <code>version2</code>&nbsp;<strong>are valid version numbers</strong>.</li>\n\t<li>All the given revisions in&nbsp;<code>version1</code> and <code>version2</code>&nbsp;can be stored in&nbsp;a&nbsp;<strong>32-bit integer</strong>.</li>\n</ul>\n"}}, "166": {"__typename": "QuestionLightNode", "acRate": 0.3347070081458756, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "166", "isFavor": false, "solutionNum": 562, "title": "Fraction to Recurring Decimal", "titleCn": "分数到小数", "titleSlug": "fraction-to-recurring-decimal", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 55, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/99a45f957529ef9ac7be507962ccee294f53b3cd87dc8163d18f16c1228e4a70-belo-cn-200x200-9518747d43e25d1834cda4cbe55464c5.png", "slug": "airbnb", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个整数，分别表示分数的分子&nbsp;<code>numerator</code> 和分母 <code>denominator</code>，以 <strong>字符串形式返回小数</strong> 。</p>\n\n<p>如果小数部分为循环小数，则将循环的部分括在括号内。</p>\n\n<p>如果存在多个答案，只需返回 <strong>任意一个</strong> 。</p>\n\n<p>对于所有给定的输入，<strong>保证</strong> 答案字符串的长度小于 <code>10<sup>4</sup></code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>numerator = 1, denominator = 2\n<strong>输出：</strong>\"0.5\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>numerator = 2, denominator = 1\n<strong>输出：</strong>\"2\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>numerator = 4, denominator = 333\n<strong>输出：</strong>\"0.(012)\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;=&nbsp;numerator, denominator &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>denominator != 0</code></li>\n</ul>\n", "en": "<p>Given two integers representing the <code>numerator</code> and <code>denominator</code> of a fraction, return <em>the fraction in string format</em>.</p>\n\n<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>\n\n<p>If multiple answers are possible, return <strong>any of them</strong>.</p>\n\n<p>It is <strong>guaranteed</strong> that the length of the answer string is less than <code>10<sup>4</sup></code> for all the given inputs.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 1, denominator = 2\n<strong>Output:</strong> &quot;0.5&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 2, denominator = 1\n<strong>Output:</strong> &quot;2&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numerator = 4, denominator = 333\n<strong>Output:</strong> &quot;0.(012)&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;=&nbsp;numerator, denominator &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>denominator != 0</code></li>\n</ul>\n"}}, "167": {"__typename": "QuestionLightNode", "acRate": 0.6006771561214169, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "167", "isFavor": false, "solutionNum": 4164, "title": "Two Sum II - Input Array Is Sorted", "titleCn": "两数之和 II - 输入有序数组", "titleSlug": "two-sum-ii-input-array-is-sorted", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 82, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个下标从 <strong>1</strong> 开始的整数数组&nbsp;<code>numbers</code> ，该数组已按<strong><em> </em>非递减顺序排列&nbsp; </strong>，请你从数组中找出满足相加之和等于目标数&nbsp;<code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index<sub>1</sub>]</code> 和 <code>numbers[index<sub>2</sub>]</code> ，则 <code>1 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt;= numbers.length</code> 。</p>\n\n<p>以长度为 2 的整数数组 <code>[index<sub>1</sub>, index<sub>2</sub>]</code> 的形式返回这两个整数的下标 <code>index<sub>1</sub></code><em> </em>和<em> </em><code>index<sub>2</sub></code>。</p>\n\n<p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p>\n\n<p>你所设计的解决方案必须只使用常量级的额外空间。</p>\n&nbsp;\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>numbers = [<strong><em>2</em></strong>,<strong><em>7</em></strong>,11,15], target = 9\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>2 与 7 之和等于目标数 9 。因此 index<sub>1</sub> = 1, index<sub>2</sub> = 2 。返回 [1, 2] 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>numbers = [<strong><em>2</em></strong>,3,<strong><em>4</em></strong>], target = 6\n<strong>输出：</strong>[1,3]\n<strong>解释：</strong>2 与 4 之和等于目标数 6 。因此 index<sub>1</sub> = 1, index<sub>2</sub> = 3 。返回 [1, 3] 。</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>numbers = [<strong><em>-1</em></strong>,<strong><em>0</em></strong>], target = -1\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>-1 与 0 之和等于目标数 -1 。因此 index<sub>1</sub> = 1, index<sub>2</sub> = 2 。返回 [1, 2] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= numbers.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>\n\t<li><code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n\t<li><strong>仅存在一个有效答案</strong></li>\n</ul>\n", "en": "<p>Given a <strong>1-indexed</strong> array of integers <code>numbers</code> that is already <strong><em>sorted in non-decreasing order</em></strong>, find two numbers such that they add up to a specific <code>target</code> number. Let these two numbers be <code>numbers[index<sub>1</sub>]</code> and <code>numbers[index<sub>2</sub>]</code> where <code>1 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt;= numbers.length</code>.</p>\n\n<p>Return<em> the indices of the two numbers, </em><code>index<sub>1</sub></code><em> and </em><code>index<sub>2</sub></code><em>, <strong>added by one</strong> as an integer array </em><code>[index<sub>1</sub>, index<sub>2</sub>]</code><em> of length 2.</em></p>\n\n<p>The tests are generated such that there is <strong>exactly one solution</strong>. You <strong>may not</strong> use the same element twice.</p>\n\n<p>Your solution must use only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>2</u>,<u>7</u>,11,15], target = 9\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore, index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>2</u>,3,<u>4</u>], target = 6\n<strong>Output:</strong> [1,3]\n<strong>Explanation:</strong> The sum of 2 and 4 is 6. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 3. We return [1, 3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>-1</u>,<u>0</u>], target = -1\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of -1 and 0 is -1. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= numbers.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>\n\t<li><code>numbers</code> is sorted in <strong>non-decreasing order</strong>.</li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n\t<li>The tests are generated such that there is <strong>exactly one solution</strong>.</li>\n</ul>\n"}}, "168": {"__typename": "QuestionLightNode", "acRate": 0.4461392516385005, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "168", "isFavor": false, "solutionNum": 1244, "title": "Excel Sheet Column Title", "titleCn": "Excel表列名称", "titleSlug": "excel-sheet-column-title", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 65, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数 <code>columnNumber</code> ，返回它在 Excel 表中相对应的列名称。</p>\n\n<p>例如：</p>\n\n<pre>\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n</pre>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>columnNumber = 1\n<strong>输出：</strong>\"A\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>columnNumber = 28\n<strong>输出：</strong>\"AB\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>columnNumber = 701\n<strong>输出：</strong>\"ZY\"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>columnNumber = 2147483647\n<strong>输出：</strong>\"FXSHRXW\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= columnNumber <= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given an integer <code>columnNumber</code>, return <em>its corresponding column title as it appears in an Excel sheet</em>.</p>\n\n<p>For example:</p>\n\n<pre>\nA -&gt; 1\nB -&gt; 2\nC -&gt; 3\n...\nZ -&gt; 26\nAA -&gt; 27\nAB -&gt; 28 \n...\n</pre>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnNumber = 1\n<strong>Output:</strong> &quot;A&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnNumber = 28\n<strong>Output:</strong> &quot;AB&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnNumber = 701\n<strong>Output:</strong> &quot;ZY&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= columnNumber &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "169": {"__typename": "QuestionLightNode", "acRate": 0.663232734122828, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "169", "isFavor": false, "solutionNum": 4610, "title": "Majority Element", "titleCn": "多数元素", "titleSlug": "majority-element", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "pxpqcm", "name": "Counting", "slug": "counting", "nameTranslated": "计数", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 91, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个大小为 <code>n</code><em> </em>的数组&nbsp;<code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong>&nbsp;<code>⌊ n/2 ⌋</code>&nbsp;的元素。</p>\n\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,3]\n<strong>输出：</strong>3</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,1,1,1,2,2]\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n<strong>提示：</strong>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。</p>\n", "en": "<p>Given an array <code>nums</code> of size <code>n</code>, return <em>the majority element</em>.</p>\n\n<p>The majority element is the element that appears more than <code>&lfloor;n / 2&rfloor;</code> times. You may assume that the majority element always exists in the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [3,2,3]\n<strong>Output:</strong> 3\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,1,1,1,2,2]\n<strong>Output:</strong> 2\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow-up:</strong> Could you solve the problem in linear time and in <code>O(1)</code> space?"}}, "170": {"__typename": "QuestionLightNode", "acRate": 0.4258436095975528, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "170", "isFavor": false, "solutionNum": 164, "title": "Two Sum III - Data structure design", "titleCn": "两数之和 III - 数据结构设计", "titleSlug": "two-sum-iii-data-structure-design", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "pgti0i", "name": "Data Stream", "slug": "data-stream", "nameTranslated": "数据流", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 12, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "171": {"__typename": "QuestionLightNode", "acRate": 0.7146520362613809, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "171", "isFavor": false, "solutionNum": 1455, "title": "Excel Sheet Column Number", "titleCn": "Excel 表列序号", "titleSlug": "excel-sheet-column-number", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 55, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串&nbsp;<code>columnTitle</code> ，表示 Excel 表格中的列名称。返回 <em>该列名称对应的列序号</em>&nbsp;。</p>\n\n<p>例如：</p>\n\n<pre>\nA -&gt; 1\nB -&gt; 2\nC -&gt; 3\n...\nZ -&gt; 26\nAA -&gt; 27\nAB -&gt; 28 \n...</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> columnTitle = \"A\"\n<strong>输出:</strong> 1\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入: </strong>columnTitle = \"AB\"\n<strong>输出:</strong> 28\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre>\n<strong>输入: </strong>columnTitle = \"ZY\"\n<strong>输出:</strong> 701</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= columnTitle.length &lt;= 7</code></li>\n\t<li><code>columnTitle</code> 仅由大写英文组成</li>\n\t<li><code>columnTitle</code> 在范围 <code>[\"A\", \"FXSHRXW\"]</code> 内</li>\n</ul>\n", "en": "<p>Given a string <code>columnTitle</code> that represents the column title as appears in an Excel sheet, return <em>its corresponding column number</em>.</p>\n\n<p>For example:</p>\n\n<pre>\nA -&gt; 1\nB -&gt; 2\nC -&gt; 3\n...\nZ -&gt; 26\nAA -&gt; 27\nAB -&gt; 28 \n...\n</pre>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnTitle = &quot;A&quot;\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnTitle = &quot;AB&quot;\n<strong>Output:</strong> 28\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> columnTitle = &quot;ZY&quot;\n<strong>Output:</strong> 701\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= columnTitle.length &lt;= 7</code></li>\n\t<li><code>columnTitle</code> consists only of uppercase English letters.</li>\n\t<li><code>columnTitle</code> is in the range <code>[&quot;A&quot;, &quot;FXSHRXW&quot;]</code>.</li>\n</ul>\n"}}, "172": {"__typename": "QuestionLightNode", "acRate": 0.5037691371136959, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "172", "isFavor": false, "solutionNum": 1193, "title": "Factorial Trailing Zeroes", "titleCn": "阶乘后的零", "titleSlug": "factorial-trailing-zeroes", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 50, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个整数 <code>n</code> ，返回 <code>n!</code> 结果中尾随零的数量。</p>\n\n<p>提示&nbsp;<code>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>0\n<strong>解释：</strong>3! = 6 ，不含尾随 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>1\n<strong>解释：</strong>5! = 120 ，有一个尾随 0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 0\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>进阶：</b>你可以设计并实现对数时间复杂度的算法来解决此问题吗？</p>\n", "en": "<p>Given an integer <code>n</code>, return <em>the number of trailing zeroes in </em><code>n!</code>.</p>\n\n<p>Note that <code>n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> 3! = 6, no trailing zero.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 5! = 120, one trailing zero.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you write a solution that works in logarithmic time complexity?</p>\n"}}, "173": {"__typename": "QuestionLightNode", "acRate": 0.8196547047395624, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "173", "isFavor": false, "solutionNum": 976, "title": "Binary Search Tree Iterator", "titleCn": "二叉搜索树迭代器", "titleSlug": "binary-search-tree-iterator", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}, {"id": "7eks9i", "name": "Iterator", "slug": "iterator", "nameTranslated": "迭代器", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 48, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "实现一个二叉搜索树迭代器类<code>BSTIterator</code> ，表示一个按中序遍历二叉搜索树（BST）的迭代器：\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li><code>BSTIterator(TreeNode root)</code> 初始化 <code>BSTIterator</code> 类的一个对象。BST 的根节点 <code>root</code> 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</li>\n\t<li><code>boolean hasNext()</code> 如果向指针右侧遍历存在数字，则返回 <code>true</code> ；否则返回 <code>false</code> 。</li>\n\t<li><code>int next()</code>将指针向右移动，然后返回指针处的数字。</li>\n</ul>\n\n<p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 <code>next()</code> 的首次调用将返回 BST 中的最小元素。</p>\n</div>\n</div>\n\n<p>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 的中序遍历中至少存在一个下一个数字。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png\" style=\"width: 189px; height: 178px;\" />\n<pre>\n<strong>输入</strong>\n[\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n<strong>输出</strong>\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n<strong>解释</strong>\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // 返回 3\nbSTIterator.next();    // 返回 7\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 9\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 15\nbSTIterator.hasNext(); // 返回 True\nbSTIterator.next();    // 返回 20\nbSTIterator.hasNext(); // 返回 False\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>0 <= Node.val <= 10<sup>6</sup></code></li>\n\t<li>最多调用 <code>10<sup>5</sup></code> 次 <code>hasNext</code> 和 <code>next</code> 操作</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以设计一个满足下述条件的解决方案吗？<code>next()</code> 和 <code>hasNext()</code> 操作均摊时间复杂度为 <code>O(1)</code> ，并使用 <code>O(h)</code> 内存。其中 <code>h</code> 是树的高度。</li>\n</ul>\n", "en": "<p>Implement the <code>BSTIterator</code> class that represents an iterator over the <strong><a href=\"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)\" target=\"_blank\">in-order traversal</a></strong> of a binary search tree (BST):</p>\n\n<ul>\n\t<li><code>BSTIterator(TreeNode root)</code> Initializes an object of the <code>BSTIterator</code> class. The <code>root</code> of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.</li>\n\t<li><code>boolean hasNext()</code> Returns <code>true</code> if there exists a number in the traversal to the right of the pointer, otherwise returns <code>false</code>.</li>\n\t<li><code>int next()</code> Moves the pointer to the right, then returns the number at the pointer.</li>\n</ul>\n\n<p>Notice that by initializing the pointer to a non-existent smallest number, the first call to <code>next()</code> will return the smallest element in the BST.</p>\n\n<p>You may assume that <code>next()</code> calls will always be valid. That is, there will be at least a next number in the in-order traversal when <code>next()</code> is called.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png\" style=\"width: 189px; height: 178px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n<strong>Output</strong>\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n<strong>Explanation</strong>\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n\t<li>At most <code>10<sup>5</sup></code> calls will be made to <code>hasNext</code>, and <code>next</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Could you implement <code>next()</code> and <code>hasNext()</code> to run in average <code>O(1)</code> time and use&nbsp;<code>O(h)</code> memory, where <code>h</code> is the height of the tree?</li>\n</ul>\n"}}, "174": {"__typename": "QuestionLightNode", "acRate": 0.4851620564962705, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "174", "isFavor": false, "solutionNum": 1486, "title": "Dungeon Game", "titleCn": "地下城游戏", "titleSlug": "dungeon-game", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 36, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<style type=\"text/css\">table.dungeon, .dungeon th, .dungeon td {\n  border:3px solid black;\n}\n\n .dungeon th, .dungeon td {\n    text-align: center;\n    height: 70px;\n    width: 70px;\n}\n</style>\n<p>恶魔们抓住了公主并将她关在了地下城&nbsp;<code>dungeon</code> 的 <strong>右下角</strong> 。地下城是由 <code>m x n</code> 个房间组成的二维网格。我们英勇的骑士最初被安置在 <strong>左上角</strong> 的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>\n\n<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>\n\n<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为<em>负整数</em>，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 <em>0</em>），要么包含增加骑士健康点数的魔法球（若房间里的值为<em>正整数</em>，则表示骑士将增加健康点数）。</p>\n\n<p>为了尽快解救公主，骑士决定每次只 <strong>向右</strong> 或 <strong>向下</strong> 移动一步。</p>\n\n<p>返回确保骑士能够拯救到公主所需的最低初始健康点数。</p>\n\n<p><strong>注意：</strong>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/13/dungeon-grid-1.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>输入：</strong>dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\n<strong>输出：</strong>7\n<strong>解释：</strong>如果骑士遵循最佳路径：右 -&gt; 右 -&gt; 下 -&gt; 下 ，则骑士的初始健康点数至少为 7 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dungeon = [[0]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == dungeon.length</code></li>\n\t<li><code>n == dungeon[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>-1000 &lt;= dungeon[i][j] &lt;= 1000</code></li>\n</ul>\n", "en": "<p>The demons had captured the princess and imprisoned her in <strong>the bottom-right corner</strong> of a <code>dungeon</code>. The <code>dungeon</code> consists of <code>m x n</code> rooms laid out in a 2D grid. Our valiant knight was initially positioned in <strong>the top-left room</strong> and must fight his way through <code>dungeon</code> to rescue the princess.</p>\n\n<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to <code>0</code> or below, he dies immediately.</p>\n\n<p>Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight&#39;s health (represented by positive integers).</p>\n\n<p>To reach the princess as quickly as possible, the knight decides to move only <strong>rightward</strong> or <strong>downward</strong> in each step.</p>\n\n<p>Return <em>the knight&#39;s minimum initial health so that he can rescue the princess</em>.</p>\n\n<p><strong>Note</strong> that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/13/dungeon-grid-1.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> dungeon = [[0]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == dungeon.length</code></li>\n\t<li><code>n == dungeon[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>-1000 &lt;= dungeon[i][j] &lt;= 1000</code></li>\n</ul>\n"}}, "175": {"__typename": "QuestionLightNode", "acRate": 0.743967537367773, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "175", "isFavor": false, "solutionNum": 2335, "title": "Combine Two Tables", "titleCn": "组合两个表", "titleSlug": "combine-two-tables", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 84, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| 列名         | 类型     |\n+-------------+---------+\n| PersonId    | int     |\n| FirstName   | varchar |\n| LastName    | varchar |\n+-------------+---------+\npersonId 是该表的主键（具有唯一值的列）。\n该表包含一些人的 ID 和他们的姓和名的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表: <code>Address</code></p>\n\n<pre>\n+-------------+---------+\n| 列名         | 类型    |\n+-------------+---------+\n| AddressId   | int     |\n| PersonId    | int     |\n| City        | varchar |\n| State       | varchar |\n+-------------+---------+\naddressId 是该表的主键（具有唯一值的列）。\n该表的每一行都包含一个 ID = PersonId 的人的城市和州的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写解决方案，报告 <code>Person</code> 表中每个人的姓、名、城市和州。如果 <code>personId</code> 的地址不在&nbsp;<code>Address</code>&nbsp;表中，则报告为&nbsp;<code>null</code>&nbsp;。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nPerson表:\n+----------+----------+-----------+\n| personId | lastName | firstName |\n+----------+----------+-----------+\n| 1        | Wang     | Allen     |\n| 2        | Alice    | Bob       |\n+----------+----------+-----------+\nAddress表:\n+-----------+----------+---------------+------------+\n| addressId | personId | city          | state      |\n+-----------+----------+---------------+------------+\n| 1         | 2        | New York City | New York   |\n| 2         | 3        | Leetcode      | California |\n+-----------+----------+---------------+------------+\n<strong>输出:</strong> \n+-----------+----------+---------------+----------+\n| firstName | lastName | city          | state    |\n+-----------+----------+---------------+----------+\n| Allen     | Wang     | Null          | Null     |\n| Bob       | Alice    | New York City | New York |\n+-----------+----------+---------------+----------+\n<strong>解释:</strong> \n地址表中没有 personId = 1 的地址，所以它们的城市和州返回 null。\naddressId = 1 包含了 personId = 2 的地址信息。</pre>\n", "en": "<p>Table: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| personId    | int     |\n| lastName    | varchar |\n| firstName   | varchar |\n+-------------+---------+\npersonId is the primary key (column with unique values) for this table.\nThis table contains information about the ID of some persons and their first and last names.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Address</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| addressId   | int     |\n| personId    | int     |\n| city        | varchar |\n| state       | varchar |\n+-------------+---------+\naddressId is the primary key (column with unique values) for this table.\nEach row of this table contains information about the city and state of one person with ID = PersonId.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the first name, last name, city, and state of each person in the <code>Person</code> table. If the address of a <code>personId</code> is not present in the <code>Address</code> table, report <code>null</code> instead.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPerson table:\n+----------+----------+-----------+\n| personId | lastName | firstName |\n+----------+----------+-----------+\n| 1        | Wang     | Allen     |\n| 2        | Alice    | Bob       |\n+----------+----------+-----------+\nAddress table:\n+-----------+----------+---------------+------------+\n| addressId | personId | city          | state      |\n+-----------+----------+---------------+------------+\n| 1         | 2        | New York City | New York   |\n| 2         | 3        | Leetcode      | California |\n+-----------+----------+---------------+------------+\n<strong>Output:</strong> \n+-----------+----------+---------------+----------+\n| firstName | lastName | city          | state    |\n+-----------+----------+---------------+----------+\n| Allen     | Wang     | Null          | Null     |\n| Bob       | Alice    | New York City | New York |\n+-----------+----------+---------------+----------+\n<strong>Explanation:</strong> \nThere is no address in the address table for the personId = 1 so we return null in their city and state.\naddressId = 1 contains information about the address of personId = 2.\n</pre>\n"}}, "176": {"__typename": "QuestionLightNode", "acRate": 0.37328947410401786, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "176", "isFavor": false, "solutionNum": 1894, "title": "Second Highest Salary", "titleCn": "第二高的薪水", "titleSlug": "second-highest-salary", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 96, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<code>Employee</code> 表：\n<div class=\"original__bRMd\">\n<div>\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| salary      | int  |\n+-------------+------+\n在 SQL 中，id 是这个表的主键。\n表的每一行包含员工的工资信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>查询并返回 <code>Employee</code>&nbsp;表中第二高的薪水 。如果不存在第二高的薪水，查询应该返回 <code>null(Pandas 则返回 None)</code> 。</p>\n\n<p>查询结果如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nEmployee 表：\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n<strong>输出：</strong>\n+---------------------+\n| SecondHighestSalary |\n+---------------------+\n| 200                 |\n+---------------------+\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nEmployee 表：\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n+----+--------+\n<strong>输出：</strong>\n+---------------------+\n| SecondHighestSalary |\n+---------------------+\n| null                |\n+---------------------+\n</pre>\n</div>\n</div>\n", "en": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| salary      | int  |\n+-------------+------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains information about the salary of an employee.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find&nbsp;the second highest salary from the <code>Employee</code> table. If there is no second highest salary,&nbsp;return&nbsp;<code>null (return&nbsp;None in Pandas)</code>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\n<strong>Output:</strong> \n+---------------------+\n| SecondHighestSalary |\n+---------------------+\n| 200                 |\n+---------------------+\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n+----+--------+\n<strong>Output:</strong> \n+---------------------+\n| SecondHighestSalary |\n+---------------------+\n| null                |\n+---------------------+\n</pre>\n"}}, "177": {"__typename": "QuestionLightNode", "acRate": 0.463592071275424, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "177", "isFavor": false, "solutionNum": 945, "title": "Nth Highest Salary", "titleCn": "第N高的薪水", "titleSlug": "nth-highest-salary", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 54, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表:&nbsp;<code>Employee</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| salary      | int  |\n+-------------+------+\n在 SQL 中，id 是该表的主键。\n该表的每一行都包含有关员工工资的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>查询&nbsp;<code>Employee</code> 表中第 <code>n</code> 高的工资。如果没有第 <code>n</code> 个最高工资，查询结果应该为&nbsp;<code>null</code> 。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nEmployee table:\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\nn = 2\n<strong>输出:</strong> \n+------------------------+\n| getNthHighestSalary(2) |\n+------------------------+\n| 200                    |\n+------------------------+\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nEmployee 表:\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n+----+--------+\nn = 2\n<strong>输出:</strong> \n+------------------------+\n| getNthHighestSalary(2) |\n+------------------------+\n| null                   |\n+------------------------+</pre>\n", "en": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| salary      | int  |\n+-------------+------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains information about the salary of an employee.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the <code>n<sup>th</sup></code> highest salary from the <code>Employee</code> table. If there is no <code>n<sup>th</sup></code> highest salary, return&nbsp;<code>null</code>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n| 2  | 200    |\n| 3  | 300    |\n+----+--------+\nn = 2\n<strong>Output:</strong> \n+------------------------+\n| getNthHighestSalary(2) |\n+------------------------+\n| 200                    |\n+------------------------+\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+--------+\n| id | salary |\n+----+--------+\n| 1  | 100    |\n+----+--------+\nn = 2\n<strong>Output:</strong> \n+------------------------+\n| getNthHighestSalary(2) |\n+------------------------+\n| null                   |\n+------------------------+\n</pre>\n"}}, "178": {"__typename": "QuestionLightNode", "acRate": 0.6197015132435489, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "178", "isFavor": false, "solutionNum": 1116, "title": "Rank Scores", "titleCn": "分数排名", "titleSlug": "rank-scores", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 52, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表:&nbsp;<code>Scores</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| score       | decimal |\n+-------------+---------+\n在 SQL 中，id 是该表的主键。\n该表的每一行都包含了一场比赛的分数。Score 是一个有两位小数点的浮点值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>查询并对分数进行排序。排名按以下规则计算:</p>\n\n<ul>\n\t<li>分数应按从高到低排列。</li>\n\t<li>如果两个分数相等，那么两个分数的排名应该相同。</li>\n\t<li>在排名相同的分数后，排名数应该是下一个连续的整数。换句话说，排名之间不应该有空缺的数字。</li>\n</ul>\n\n<p>按&nbsp;<code>score</code>&nbsp;降序返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nScores 表:\n+----+-------+\n| id | score |\n+----+-------+\n| 1  | 3.50  |\n| 2  | 3.65  |\n| 3  | 4.00  |\n| 4  | 3.85  |\n| 5  | 4.00  |\n| 6  | 3.65  |\n+----+-------+\n<strong>输出:</strong> \n+-------+------+\n| score | rank |\n+-------+------+\n| 4.00  | 1    |\n| 4.00  | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.50  | 4    |\n+-------+------+</pre>\n", "en": "<p>Table: <code>Scores</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| score       | decimal |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains the score of a game. Score is a floating point value with two decimal places.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the rank of the scores. The ranking should be calculated according to the following rules:</p>\n\n<ul>\n\t<li>The scores should be ranked from the highest to the lowest.</li>\n\t<li>If there is a tie between two scores, both should have the same ranking.</li>\n\t<li>After a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.</li>\n</ul>\n\n<p>Return the result table ordered by <code>score</code> in descending order.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nScores table:\n+----+-------+\n| id | score |\n+----+-------+\n| 1  | 3.50  |\n| 2  | 3.65  |\n| 3  | 4.00  |\n| 4  | 3.85  |\n| 5  | 4.00  |\n| 6  | 3.65  |\n+----+-------+\n<strong>Output:</strong> \n+-------+------+\n| score | rank |\n+-------+------+\n| 4.00  | 1    |\n| 4.00  | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.50  | 4    |\n+-------+------+\n</pre>\n"}}, "179": {"__typename": "QuestionLightNode", "acRate": 0.40992201764787184, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "179", "isFavor": false, "solutionNum": 1559, "title": "Largest Number", "titleCn": "最大数", "titleSlug": "largest-number", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 84, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>\n\n<p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入<code>：</code></strong><code>nums = [10,2]</code>\n<strong>输出：</strong><code>\"210\"</code></pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入<code>：</code></strong><code>nums = [3,30,34,5,9]</code>\n<strong>输出：</strong><code>\"9534330\"</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Given a list of non-negative integers <code>nums</code>, arrange them such that they form the largest number and return it.</p>\n\n<p>Since the result may be very large, so you need to return a string instead of an integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,2]\n<strong>Output:</strong> &quot;210&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,30,34,5,9]\n<strong>Output:</strong> &quot;9534330&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "180": {"__typename": "QuestionLightNode", "acRate": 0.471161383090827, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "180", "isFavor": false, "solutionNum": 1055, "title": "Consecutive Numbers", "titleCn": "连续出现的数字", "titleSlug": "consecutive-numbers", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 51, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表：<code>Logs</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| num         | varchar |\n+-------------+---------+\n在 SQL 中，id 是该表的主键。\nid 是一个自增列。</pre>\n\n<p>&nbsp;</p>\n\n<p>找出所有至少连续出现三次的数字。</p>\n\n<p>返回的结果表中的数据可以按 <strong>任意顺序</strong> 排列。</p>\n\n<p>结果格式如下面的例子所示：</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nLogs 表：\n+----+-----+\n| id | num |\n+----+-----+\n| 1  | 1   |\n| 2  | 1   |\n| 3  | 1   |\n| 4  | 2   |\n| 5  | 1   |\n| 6  | 2   |\n| 7  | 2   |\n+----+-----+\n<strong>输出：</strong>\nResult 表：\n+-----------------+\n| ConsecutiveNums |\n+-----------------+\n| 1               |\n+-----------------+\n<strong>解释：</strong>1 是唯一连续出现至少三次的数字。</pre>\n", "en": "<p>Table: <code>Logs</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| num         | varchar |\n+-------------+---------+\nIn SQL, id is the primary key for this table.\nid is an autoincrement column.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Find all numbers that appear at least three times consecutively.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nLogs table:\n+----+-----+\n| id | num |\n+----+-----+\n| 1  | 1   |\n| 2  | 1   |\n| 3  | 1   |\n| 4  | 2   |\n| 5  | 1   |\n| 6  | 2   |\n| 7  | 2   |\n+----+-----+\n<strong>Output:</strong> \n+-----------------+\n| ConsecutiveNums |\n+-----------------+\n| 1               |\n+-----------------+\n<strong>Explanation:</strong> 1 is the only number that appears consecutively for at least three times.\n</pre>\n"}}, "181": {"__typename": "QuestionLightNode", "acRate": 0.6878368852014533, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "181", "isFavor": false, "solutionNum": 1228, "title": "Employees Earning More Than Their Managers", "titleCn": "超过经理收入的员工", "titleSlug": "employees-earning-more-than-their-managers", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 55, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表：<code>Employee</code>&nbsp;</p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| salary      | int     |\n| managerId   | int     |\n+-------------+---------+\nid 是该表的主键（具有唯一值的列）。\n该表的每一行都表示雇员的ID、姓名、工资和经理的ID。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写解决方案，找出收入比经理高的员工。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nEmployee 表:\n+----+-------+--------+-----------+\n| id | name  | salary | managerId |\n+----+-------+--------+-----------+\n| 1  | Joe   | 70000  | 3         |\n| 2  | Henry | 80000  | 4         |\n| 3  | Sam   | 60000  | Null      |\n| 4  | Max   | 90000  | Null      |\n+----+-------+--------+-----------+\n<strong>输出:</strong> \n+----------+\n| Employee |\n+----------+\n| Joe      |\n+----------+\n<strong>解释:</strong> Joe 是唯一挣得比经理多的雇员。</pre>\n", "en": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| salary      | int     |\n| managerId   | int     |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID of an employee, their name, salary, and the ID of their manager.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution&nbsp;to find the employees who earn more than their managers.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+-------+--------+-----------+\n| id | name  | salary | managerId |\n+----+-------+--------+-----------+\n| 1  | Joe   | 70000  | 3         |\n| 2  | Henry | 80000  | 4         |\n| 3  | Sam   | 60000  | Null      |\n| 4  | Max   | 90000  | Null      |\n+----+-------+--------+-----------+\n<strong>Output:</strong> \n+----------+\n| Employee |\n+----------+\n| Joe      |\n+----------+\n<strong>Explanation:</strong> Joe is the only employee who earns more than his manager.\n</pre>\n"}}, "182": {"__typename": "QuestionLightNode", "acRate": 0.7871669231767695, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "182", "isFavor": false, "solutionNum": 1154, "title": "Duplicate Emails", "titleCn": "查找重复的电子邮箱", "titleSlug": "duplicate-emails", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 36, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><meta charset=\"UTF-8\" /></p>\n\n<p>表:&nbsp;<code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| email       | varchar |\n+-------------+---------+\nid 是该表的主键（具有唯一值的列）。\n此表的每一行都包含一封电子邮件。电子邮件不包含大写字母。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写解决方案来报告所有重复的电子邮件。 请注意，可以保证电子邮件字段不为 NULL。</p>\n\n<p>以&nbsp;<strong>任意顺序&nbsp;</strong>返回结果表。</p>\n\n<p>结果格式如下例。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nPerson 表:\n+----+---------+\n| id | email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n<strong>输出:</strong> \n+---------+\n| Email   |\n+---------+\n| a@b.com |\n+---------+\n<strong>解释:</strong> a@b.com 出现了两次。</pre>\n", "en": "<p>Table: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| email       | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains an email. The emails will not contain uppercase letters.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report all the duplicate emails. Note that it&#39;s guaranteed that the email&nbsp;field is not NULL.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPerson table:\n+----+---------+\n| id | email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n<strong>Output:</strong> \n+---------+\n| Email   |\n+---------+\n| a@b.com |\n+---------+\n<strong>Explanation:</strong> a@b.com is repeated two times.\n</pre>\n"}}, "183": {"__typename": "QuestionLightNode", "acRate": 0.6649011096543235, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "183", "isFavor": false, "solutionNum": 1255, "title": "Customers Who Never Order", "titleCn": "从不订购的客户", "titleSlug": "customers-who-never-order", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 35, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><code>Customers</code> 表：</p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\n在 SQL 中，id 是该表的主键。\n该表的每一行都表示客户的 ID 和名称。</pre>\n\n<p><code>Orders</code> 表：</p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| customerId  | int  |\n+-------------+------+\n在 SQL 中，id 是该表的主键。\ncustomerId 是 Customers 表中 ID 的外键( Pandas 中的连接键)。\n该表的每一行都表示订单的 ID 和订购该订单的客户的 ID。</pre>\n\n<p>&nbsp;</p>\n\n<p>找出所有从不点任何东西的顾客。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\nCustomers table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\nOrders table:\n+----+------------+\n| id | customerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\n<b>输出：</b>\n+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+</pre>\n", "en": "<p>Table: <code>Customers</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID and name of a customer.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Orders</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| customerId  | int  |\n+-------------+------+\nid is the primary key (column with unique values) for this table.\ncustomerId is a foreign key (reference columns) of the ID from the Customers table.\nEach row of this table indicates the ID of an order and the ID of the customer who ordered it.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find all customers who never order anything.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nCustomers table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\nOrders table:\n+----+------------+\n| id | customerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\n<strong>Output:</strong> \n+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+\n</pre>\n"}}, "184": {"__typename": "QuestionLightNode", "acRate": 0.5226493033676398, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "184", "isFavor": false, "solutionNum": 1281, "title": "Department Highest Salary", "titleCn": "部门工资最高的员工", "titleSlug": "department-highest-salary", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 69, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表：&nbsp;<code>Employee</code></p>\n\n<pre>\n+--------------+---------+\n| 列名          | 类型    |\n+--------------+---------+\n| id           | int     |\n| name         | varchar |\n| salary       | int     |\n| departmentId | int     |\n+--------------+---------+\n在 SQL 中，id是此表的主键。\ndepartmentId 是 Department 表中 id 的外键（在 Pandas 中称为 join key）。\n此表的每一行都表示员工的 id、姓名和工资。它还包含他们所在部门的 id。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表：&nbsp;<code>Department</code></p>\n\n<pre>\n+-------------+---------+\n| 列名         | 类型    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\n在 SQL 中，id 是此表的主键列。\n此表的每一行都表示一个部门的 id 及其名称。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>查找出每个部门中薪资最高的员工。<br />\n按 <strong>任意顺序</strong> 返回结果表。<br />\n查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<b>输入：</b>\nEmployee 表:\n+----+-------+--------+--------------+\n| id | name  | salary | departmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 70000  | 1            |\n| 2  | Jim   | 90000  | 1            |\n| 3  | Henry | 80000  | 2            |\n| 4  | Sam   | 60000  | 2            |\n| 5  | Max   | 90000  | 1            |\n+----+-------+--------+--------------+\nDepartment 表:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | IT    |\n| 2  | Sales |\n+----+-------+\n<b>输出：</b>\n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Jim      | 90000  |\n| Sales      | Henry    | 80000  |\n| IT         | Max      | 90000  |\n+------------+----------+--------+\n<strong>解释：</strong>Max 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。</pre>\n", "en": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| id           | int     |\n| name         | varchar |\n| salary       | int     |\n| departmentId | int     |\n+--------------+---------+\nid is the primary key (column with unique values) for this table.\ndepartmentId is a foreign key (reference columns) of the ID from the <code>Department </code>table.\nEach row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Department</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table. It is guaranteed that department name is not <code>NULL.</code>\nEach row of this table indicates the ID of a department and its name.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find employees who have the highest salary in each of the departments.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+-------+--------+--------------+\n| id | name  | salary | departmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 70000  | 1            |\n| 2  | Jim   | 90000  | 1            |\n| 3  | Henry | 80000  | 2            |\n| 4  | Sam   | 60000  | 2            |\n| 5  | Max   | 90000  | 1            |\n+----+-------+--------+--------------+\nDepartment table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | IT    |\n| 2  | Sales |\n+----+-------+\n<strong>Output:</strong> \n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Jim      | 90000  |\n| Sales      | Henry    | 80000  |\n| IT         | Max      | 90000  |\n+------------+----------+--------+\n<strong>Explanation:</strong> Max and Jim both have the highest salary in the IT department and Henry has the highest salary in the Sales department.\n</pre>\n"}}, "185": {"__typename": "QuestionLightNode", "acRate": 0.5422301256319731, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "185", "isFavor": false, "solutionNum": 1181, "title": "Department Top Three Salaries", "titleCn": "部门工资前三高的所有员工", "titleSlug": "department-top-three-salaries", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 75, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表:&nbsp;<code>Employee</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| id           | int     |\n| name         | varchar |\n| salary       | int     |\n| departmentId | int     |\n+--------------+---------+\nid 是该表的主键列(具有唯一值的列)。\ndepartmentId 是 Department 表中 ID 的外键（reference 列）。\n该表的每一行都表示员工的ID、姓名和工资。它还包含了他们部门的ID。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表:&nbsp;<code>Department</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid 是该表的主键列(具有唯一值的列)。\n该表的每一行表示部门ID和部门名。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>公司的主管们感兴趣的是公司每个部门中谁赚的钱最多。一个部门的 <strong>高收入者</strong> 是指一个员工的工资在该部门的 <strong>不同</strong> 工资中 <strong>排名前三</strong> 。</p>\n\n<p>编写解决方案，找出每个部门中 <strong>收入高的员工</strong> 。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>返回结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nEmployee 表:\n+----+-------+--------+--------------+\n| id | name  | salary | departmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 85000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n| 7  | Will  | 70000  | 1            |\n+----+-------+--------+--------------+\nDepartment  表:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | IT    |\n| 2  | Sales |\n+----+-------+\n<strong>输出:</strong> \n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Joe      | 85000  |\n| IT         | Randy    | 85000  |\n| IT         | Will     | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+\n<strong>解释:\n</strong>在IT部门:\n- Max的工资最高\n- 兰迪和乔都赚取第二高的独特的薪水\n- 威尔的薪水是第三高的\n\n在销售部:\n- 亨利的工资最高\n- 山姆的薪水第二高\n- 没有第三高的工资，因为只有两名员工</pre>\n", "en": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| id           | int     |\n| name         | varchar |\n| salary       | int     |\n| departmentId | int     |\n+--------------+---------+\nid is the primary key (column with unique values) for this table.\ndepartmentId is a foreign key (reference column) of the ID from the <code>Department </code>table.\nEach row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Department</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID of a department and its name.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>A company&#39;s executives are interested in seeing who earns the most money in each of the company&#39;s departments. A <strong>high earner</strong> in a department is an employee who has a salary in the <strong>top three unique</strong> salaries for that department.</p>\n\n<p>Write a solution to find the employees who are <strong>high earners</strong> in each of the departments.</p>\n\n<p>Return the result table <strong>in any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+-------+--------+--------------+\n| id | name  | salary | departmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 85000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n| 7  | Will  | 70000  | 1            |\n+----+-------+--------+--------------+\nDepartment table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | IT    |\n| 2  | Sales |\n+----+-------+\n<strong>Output:</strong> \n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Joe      | 85000  |\n| IT         | Randy    | 85000  |\n| IT         | Will     | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+\n<strong>Explanation:</strong> \nIn the IT department:\n- Max earns the highest unique salary\n- Both Randy and Joe earn the second-highest unique salary\n- Will earns the third-highest unique salary\n\nIn the Sales department:\n- Henry earns the highest salary\n- Sam earns the second-highest salary\n- There is no third-highest salary as there are only two employees\n</pre>\n"}}, "186": {"__typename": "QuestionLightNode", "acRate": 0.7610405827263268, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "186", "isFavor": false, "solutionNum": 228, "title": "Reverse Words in a String II", "titleCn": "反转字符串中的单词 II", "titleSlug": "reverse-words-in-a-string-ii", "topicTags": [{"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 29, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "187": {"__typename": "QuestionLightNode", "acRate": 0.5490331136059327, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "187", "isFavor": false, "solutionNum": 1154, "title": "Repeated DNA Sequences", "titleCn": "重复的DNA序列", "titleSlug": "repeated-dna-sequences", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}, {"id": "xp2e97i", "name": "Hash Function", "slug": "hash-function", "nameTranslated": "哈希函数", "__typename": "CommonTagNode"}, {"id": "xp2a8mr", "name": "Rolling Hash", "slug": "rolling-hash", "nameTranslated": "滚动哈希", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 42, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><strong>DNA序列</strong>&nbsp;由一系列核苷酸组成，缩写为<meta charset=\"UTF-8\" />&nbsp;<code>'A'</code>,&nbsp;<code>'C'</code>,&nbsp;<code>'G'</code>&nbsp;和<meta charset=\"UTF-8\" />&nbsp;<code>'T'</code>.。</p>\n\n<ul>\n\t<li>例如，<meta charset=\"UTF-8\" /><code>\"ACGAATTCCG\"</code>&nbsp;是一个 <strong>DNA序列</strong> 。</li>\n</ul>\n\n<p>在研究 <strong>DNA</strong> 时，识别 DNA 中的重复序列非常有用。</p>\n\n<p>给定一个表示 <strong>DNA序列</strong> 的字符串 <code>s</code> ，返回所有在 DNA 分子中出现不止一次的&nbsp;<strong>长度为&nbsp;<code>10</code></strong>&nbsp;的序列(子字符串)。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\n<strong>输出：</strong>[\"AAAAACCCCC\",\"CCCCCAAAAA\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"AAAAAAAAAAAAA\"\n<strong>输出：</strong>[\"AAAAAAAAAA\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code><code>==</code><code>'A'</code>、<code>'C'</code>、<code>'G'</code>&nbsp;or&nbsp;<code>'T'</code></li>\n</ul>\n", "en": "<p>The <strong>DNA sequence</strong> is composed of a series of nucleotides abbreviated as <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;T&#39;</code>.</p>\n\n<ul>\n\t<li>For example, <code>&quot;ACGAATTCCG&quot;</code> is a <strong>DNA sequence</strong>.</li>\n</ul>\n\n<p>When studying <strong>DNA</strong>, it is useful to identify repeated sequences within the DNA.</p>\n\n<p>Given a string <code>s</code> that represents a <strong>DNA sequence</strong>, return all the <strong><code>10</code>-letter-long</strong> sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\n<strong>Output:</strong> [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"AAAAAAAAAAAAA\"\n<strong>Output:</strong> [\"AAAAAAAAAA\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, or <code>&#39;T&#39;</code>.</li>\n</ul>\n"}}, "188": {"__typename": "QuestionLightNode", "acRate": 0.4951260109268216, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "188", "isFavor": false, "solutionNum": 1629, "title": "Best Time to Buy and Sell Stock IV", "titleCn": "买卖股票的最佳时机 IV", "titleSlug": "best-time-to-buy-and-sell-stock-iv", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 55, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组&nbsp;<code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code><em> </em>天的价格。</p>\n\n<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p>\n\n<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 2, prices = [2,4,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 2, prices = [3,2,6,5,0,3]\n<strong>输出：</strong>7\n<strong>解释：</strong>在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。\n     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n\t<li><code>1 &lt;= prices.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>\n</ul>\n", "en": "<p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day, and an integer <code>k</code>.</p>\n\n<p>Find the maximum profit you can achieve. You may complete at most <code>k</code> transactions: i.e. you may buy at most <code>k</code> times and sell at most <code>k</code> times.</p>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, prices = [2,4,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, prices = [3,2,6,5,0,3]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n\t<li><code>1 &lt;= prices.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>\n</ul>\n"}}, "189": {"__typename": "QuestionLightNode", "acRate": 0.44828227352790057, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "189", "isFavor": false, "solutionNum": 4187, "title": "Rotate Array", "titleCn": "轮转数组", "titleSlug": "rotate-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 93, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code><em>&nbsp;</em>个位置，其中&nbsp;<code>k</code><em>&nbsp;</em>是非负数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4,5,6,7], k = 3\n<strong>输出:</strong> <code>[5,6,7,1,2,3,4]</code>\n<strong>解释:</strong>\n向右轮转 1 步: <code>[7,1,2,3,4,5,6]</code>\n向右轮转 2 步: <code>[6,7,1,2,3,4,5]\n</code>向右轮转 3 步: <code>[5,6,7,1,2,3,4]</code>\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,-100,3,99], k = 2\n<strong>输出：</strong>[3,99,-1,-100]\n<strong>解释:</strong> \n向右轮转 1 步: [99,-1,-100,3]\n向右轮转 2 步: [3,99,-1,-100]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</li>\n\t<li>你可以使用空间复杂度为&nbsp;<code>O(1)</code> 的&nbsp;<strong>原地&nbsp;</strong>算法解决这个问题吗？</li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code>, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5,6,7], k = 3\n<strong>Output:</strong> [5,6,7,1,2,3,4]\n<strong>Explanation:</strong>\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-100,3,99], k = 2\n<strong>Output:</strong> [3,99,-1,-100]\n<strong>Explanation:</strong> \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Try to come up with as many solutions as you can. There are at least <strong>three</strong> different ways to solve this problem.</li>\n\t<li>Could you do it in-place with <code>O(1)</code> extra space?</li>\n</ul>\n"}}, "190": {"__typename": "QuestionLightNode", "acRate": 0.7256563001193821, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "190", "isFavor": false, "solutionNum": 1438, "title": "Reverse Bits", "titleCn": "颠倒二进制位", "titleSlug": "reverse-bits", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 36, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>颠倒给定的 32 位无符号整数的二进制位。</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>\n\t<li>在 Java 中，编译器使用<a href=\"https://baike.baidu.com/item/二进制补码/5295284\" target=\"_blank\">二进制补码</a>记法来表示有符号整数。因此，在 <strong>示例 2</strong>&nbsp;中，输入表示有符号整数 <code>-3</code>，输出表示有符号整数 <code>-1073741825</code>。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 00000010100101000001111010011100\n<strong>输出：</strong>964176192 (00111001011110000010100101000000)\n<strong>解释：</strong>输入的二进制串 <strong>00000010100101000001111010011100 </strong>表示无符号整数<strong> 43261596</strong><strong>，\n    </strong> 因此返回 964176192，其二进制表示形式为 <strong>00111001011110000010100101000000</strong>。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 11111111111111111111111111111101\n<strong>输出：</strong>3221225471 (10111111111111111111111111111111)\n<strong>解释：</strong>输入的二进制串 <strong>11111111111111111111111111111101</strong> 表示无符号整数 4294967293，\n   &nbsp; 因此返回 3221225471 其二进制表示形式为 <strong>10111111111111111111111111111111 。</strong></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>输入是一个长度为 <code>32</code> 的二进制字符串</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶</strong>: 如果多次调用这个函数，你将如何优化你的算法？</p>\n", "en": "<p>Reverse bits of a given 32 bits unsigned integer.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer&#39;s internal binary representation is the same, whether it is signed or unsigned.</li>\n\t<li>In Java, the compiler represents the signed integers using <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\">2&#39;s complement notation</a>. Therefore, in <strong class=\"example\">Example 2</strong> above, the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 00000010100101000001111010011100\n<strong>Output:</strong>    964176192 (00111001011110000010100101000000)\n<strong>Explanation: </strong>The input binary string <strong>00000010100101000001111010011100</strong> represents the unsigned integer 43261596, so return 964176192 which its binary representation is <strong>00111001011110000010100101000000</strong>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 11111111111111111111111111111101\n<strong>Output:</strong>   3221225471 (10111111111111111111111111111111)\n<strong>Explanation: </strong>The input binary string <strong>11111111111111111111111111111101</strong> represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is <strong>10111111111111111111111111111111</strong>.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The input must be a <strong>binary string</strong> of length <code>32</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If this function is called many times, how would you optimize it?</p>\n"}}, "191": {"__typename": "QuestionLightNode", "acRate": 0.7722135643805831, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "191", "isFavor": false, "solutionNum": 2234, "title": "Number of 1 Bits", "titleCn": "位1的个数", "titleSlug": "number-of-1-bits", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 56, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中 <span data-keyword=\"set-bit\">设置位</span> 的个数（也被称为<a href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F\" target=\"_blank\">汉明重量</a>）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 11\n<strong>输出：</strong>3\n<strong>解释：</strong>输入的二进制串 <code><strong>1011</strong>&nbsp;中，共有 3 个设置位。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 128\n<strong>输出：</strong>1\n<strong>解释：</strong>输入的二进制串 <strong>10000000</strong>&nbsp;中，共有 1 个设置位。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2147483645\n<strong>输出：</strong>30\n<strong>解释：</strong>输入的二进制串 <strong>11111111111111111111111111111101</strong> 中，共有 30 个设置位。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶</strong>：</p>\n\n<ul>\n\t<li>如果多次调用这个函数，你将如何优化你的算法？</li>\n</ul>\n", "en": "<p>Write a function that takes the binary representation of a positive integer and returns the number of <span data-keyword=\"set-bit\">set bits</span> it has (also known as the <a href=\"http://en.wikipedia.org/wiki/Hamming_weight\" target=\"_blank\">Hamming weight</a>).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 11</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">3</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The input binary string <strong>1011</strong> has a total of three set bits.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 128</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">1</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The input binary string <strong>10000000</strong> has a total of one set bit.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">n = 2147483645</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">30</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>The input binary string <strong>1111111111111111111111111111101</strong> has a total of thirty set bits.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> If this function is called many times, how would you optimize it?"}}, "192": {"__typename": "QuestionLightNode", "acRate": 0.35355668119363864, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "192", "isFavor": false, "solutionNum": 251, "title": "Word Frequency", "titleCn": "统计词频", "titleSlug": "word-frequency", "topicTags": [{"id": "4ijwts", "name": "Shell", "slug": "shell", "nameTranslated": "", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 51, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>写一个 bash 脚本以统计一个文本文件&nbsp;<code>words.txt</code>&nbsp;中每个单词出现的<span data-keyword=\"frequency-textfile\">频率</span>。</p>\n\n<p>为了简单起见，你可以假设：</p>\n\n<ul>\n\t<li><code>words.txt</code>只包括小写字母和&nbsp;<code>' '</code>&nbsp;。</li>\n\t<li>每个单词只由小写字母组成。</li>\n\t<li>单词间由一个或多个空格字符分隔。</li>\n</ul>\n\n<p><strong>示例:</strong></p>\n\n<p>假设 <code>words.txt</code> 内容如下：</p>\n\n<pre>\nthe day is sunny the the\nthe sunny is is\n</pre>\n\n<p>你的脚本应当输出（以词频降序排列）：</p>\n\n<pre>\nthe 4\nis 3\nsunny 2\nday 1\n</pre>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>不要担心词频相同的单词的排序问题，每个单词出现的频率都是唯一的。</li>\n\t<li>你可以使用一行&nbsp;<a href=\"http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-4.html\">Unix pipes</a>&nbsp;实现吗？</li>\n</ul>\n", "en": "<p>Write a bash script to calculate the <span data-keyword=\"frequency-textfile\">frequency</span> of each word in a text file <code>words.txt</code>.</p>\n\n<p>For simplicity sake, you may assume:</p>\n\n<ul>\n\t<li><code>words.txt</code> contains only lowercase characters and space <code>&#39; &#39;</code> characters.</li>\n\t<li>Each word must consist of lowercase characters only.</li>\n\t<li>Words are separated by one or more whitespace characters.</li>\n</ul>\n\n<p><strong class=\"example\">Example:</strong></p>\n\n<p>Assume that <code>words.txt</code> has the following content:</p>\n\n<pre>\nthe day is sunny the the\nthe sunny is is\n</pre>\n\n<p>Your script should output the following, sorted by descending frequency:</p>\n\n<pre>\nthe 4\nis 3\nsunny 2\nday 1\n</pre>\n\n<p><b>Note:</b></p>\n\n<ul>\n\t<li>Don&#39;t worry about handling ties, it is guaranteed that each word&#39;s frequency count is unique.</li>\n\t<li>Could you write it in one-line using <a href=\"http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-4.html\">Unix pipes</a>?</li>\n</ul>\n"}}, "193": {"__typename": "QuestionLightNode", "acRate": 0.3342917267268425, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "193", "isFavor": false, "solutionNum": 212, "title": "Valid Phone Numbers", "titleCn": "有效电话号码", "titleSlug": "valid-phone-numbers", "topicTags": [{"id": "4ijwts", "name": "Shell", "slug": "shell", "nameTranslated": "", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 30, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个包含电话号码列表（一行一个电话号码）的文本文件 <code>file.txt</code>，写一个单行 bash 脚本输出所有有效的电话号码。</p>\n\n<p>你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）</p>\n\n<p>你也可以假设每行前后没有多余的空格字符。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<p>假设 <code>file.txt</code> 内容如下：</p>\n\n<pre>\n987-123-4567\n123 456 7890\n(123) 456-7890\n</pre>\n\n<p>你的脚本应当输出下列有效的电话号码：</p>\n\n<pre>\n987-123-4567\n(123) 456-7890\n</pre>\n", "en": "<p>Given a text file <code>file.txt</code> that contains a list of phone numbers (one per line), write a one-liner bash script to print all valid phone numbers.</p>\n\n<p>You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)</p>\n\n<p>You may also assume each line in the text file must not contain leading or trailing white spaces.</p>\n\n<p><strong class=\"example\">Example:</strong></p>\n\n<p>Assume that <code>file.txt</code> has the following content:</p>\n\n<pre>\n987-123-4567\n123 456 7890\n(123) 456-7890\n</pre>\n\n<p>Your script should output the following valid phone numbers:</p>\n\n<pre>\n987-123-4567\n(123) 456-7890\n</pre>\n"}}, "194": {"__typename": "QuestionLightNode", "acRate": 0.3416032814304488, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "194", "isFavor": false, "solutionNum": 112, "title": "Transpose File", "titleCn": "转置文件", "titleSlug": "transpose-file", "topicTags": [{"id": "4ijwts", "name": "Shell", "slug": "shell", "nameTranslated": "", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 16, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个文件 <code>file.txt</code>，转置它的内容。</p>\n\n<p>你可以假设每行列数相同，并且每个字段由 <code>' '</code> 分隔。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<p>假设 <code>file.txt</code> 文件内容如下：</p>\n\n<pre>\nname age\nalice 21\nryan 30\n</pre>\n\n<p>应当输出：</p>\n\n<pre>\nname alice ryan\nage 21 30\n</pre>\n", "en": "<p>Given a text file <code>file.txt</code>, transpose its content.</p>\n\n<p>You may assume that each row has the same number of columns, and each field is separated by the <code>&#39; &#39;</code> character.</p>\n\n<p><strong class=\"example\">Example:</strong></p>\n\n<p>If <code>file.txt</code> has the following content:</p>\n\n<pre>\nname age\nalice 21\nryan 30\n</pre>\n\n<p>Output the following:</p>\n\n<pre>\nname alice ryan\nage 21 30\n</pre>\n"}}, "195": {"__typename": "QuestionLightNode", "acRate": 0.4374877197225035, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "195", "isFavor": false, "solutionNum": 224, "title": "Tenth Line", "titleCn": "第十行", "titleSlug": "tenth-line", "topicTags": [{"id": "4ijwts", "name": "Shell", "slug": "shell", "nameTranslated": "", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 26, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个文本文件&nbsp;<code>file.txt</code>，请只打印这个文件中的第十行。</p>\n\n<p><strong>示例:</strong></p>\n\n<p>假设&nbsp;<code>file.txt</code> 有如下内容：</p>\n\n<pre>Line 1\nLine 2\nLine 3\nLine 4\nLine 5\nLine 6\nLine 7\nLine 8\nLine 9\nLine 10\n</pre>\n\n<p>你的脚本应当显示第十行：</p>\n\n<pre>Line 10\n</pre>\n\n<p><strong>说明:</strong><br>\n1. 如果文件少于十行，你应当输出什么？<br>\n2. 至少有三种不同的解法，请尝试尽可能多的方法来解题。</p>\n", "en": "<p>Given a text file&nbsp;<code>file.txt</code>, print&nbsp;just the 10th line of the&nbsp;file.</p>\r\n\r\n<p><strong class=\"example\">Example:</strong></p>\r\n\r\n<p>Assume that <code>file.txt</code> has the following content:</p>\r\n\r\n<pre>\r\nLine 1\r\nLine 2\r\nLine 3\r\nLine 4\r\nLine 5\r\nLine 6\r\nLine 7\r\nLine 8\r\nLine 9\r\nLine 10\r\n</pre>\r\n\r\n<p>Your script should output the tenth line, which is:</p>\r\n\r\n<pre>\r\nLine 10\r\n</pre>\r\n\r\n<div class=\"spoilers\"><b>Note:</b><br />\r\n1. If the file contains less than 10 lines, what should you output?<br />\r\n2. There&#39;s at least three different solutions. Try to explore all possibilities.</div>\r\n"}}, "196": {"__typename": "QuestionLightNode", "acRate": 0.6767417990944904, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "196", "isFavor": false, "solutionNum": 915, "title": "Delete Duplicate Emails", "titleCn": "删除重复的电子邮箱", "titleSlug": "delete-duplicate-emails", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 46, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表:&nbsp;<code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| email       | varchar |\n+-------------+---------+\nid 是该表的主键列(具有唯一值的列)。\n该表的每一行包含一封电子邮件。电子邮件将不包含大写字母。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写解决方案<strong> 删除</strong> 所有重复的电子邮件，只保留一个具有最小 <code>id</code> 的唯一电子邮件。</p>\n\n<p>（对于 SQL 用户，请注意你应该编写一个 <code>DELETE</code> 语句而不是 <code>SELECT</code> 语句。）</p>\n\n<p>（对于 Pandas 用户，请注意你应该直接修改 <code>Person</code> 表。）</p>\n\n<p>运行脚本后，显示的答案是 <code>Person</code> 表。驱动程序将首先编译并运行您的代码片段，然后再显示 <code>Person</code> 表。<code>Person</code> 表的最终顺序 <strong>无关紧要</strong> 。</p>\n\n<p>返回结果格式如下示例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nPerson 表:\n+----+------------------+\n| id | email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n| 3  | john@example.com |\n+----+------------------+\n<strong>输出:</strong> \n+----+------------------+\n| id | email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n+----+------------------+\n<strong>解释:</strong> john@example.com重复两次。我们保留最小的Id = 1。</pre>\n", "en": "<p>Table: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| email       | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains an email. The emails will not contain uppercase letters.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to<strong> delete</strong> all duplicate emails, keeping only one unique email with the smallest <code>id</code>.</p>\n\n<p>For SQL users, please note that you are supposed to write a <code>DELETE</code> statement and not a <code>SELECT</code> one.</p>\n\n<p>For Pandas users, please note that you are supposed to modify <code>Person</code> in place.</p>\n\n<p>After running your script, the answer shown is the <code>Person</code> table. The driver will first compile and run your piece of code and then show the <code>Person</code> table. The final order of the <code>Person</code> table <strong>does not matter</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPerson table:\n+----+------------------+\n| id | email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n| 3  | john@example.com |\n+----+------------------+\n<strong>Output:</strong> \n+----+------------------+\n| id | email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n+----+------------------+\n<strong>Explanation:</strong> john@example.com is repeated two times. We keep the row with the smallest Id = 1.\n</pre>\n"}}, "197": {"__typename": "QuestionLightNode", "acRate": 0.5364645661929693, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "197", "isFavor": false, "solutionNum": 1203, "title": "Rising Temperature", "titleCn": "上升的温度", "titleSlug": "rising-temperature", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 38, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<div class=\"original__bRMd\">\n<div>\n<p>表：&nbsp;<code>Weather</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| recordDate    | date    |\n| temperature   | int     |\n+---------------+---------+\nid 是该表具有唯一值的列。\n没有具有相同 recordDate 的不同行。\n该表包含特定日期的温度信息</pre>\n\n<p>&nbsp;</p>\n\n<p>编写解决方案，找出与之前（昨天的）日期相比温度更高的所有日期的 <code>id</code> 。</p>\n\n<p>返回结果 <strong>无顺序要求</strong> 。</p>\n\n<p>结果格式如下例子所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nWeather 表：\n+----+------------+-------------+\n| id | recordDate | Temperature |\n+----+------------+-------------+\n| 1  | 2015-01-01 | 10          |\n| 2  | 2015-01-02 | 25          |\n| 3  | 2015-01-03 | 20          |\n| 4  | 2015-01-04 | 30          |\n+----+------------+-------------+\n<strong>输出：</strong>\n+----+\n| id |\n+----+\n| 2  |\n| 4  |\n+----+\n<strong>解释：</strong>\n2015-01-02 的温度比前一天高（10 -&gt; 25）\n2015-01-04 的温度比前一天高（20 -&gt; 30）</pre>\n</div>\n</div>\n", "en": "<p>Table: <code>Weather</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| recordDate    | date    |\n| temperature   | int     |\n+---------------+---------+\nid is the column with unique values for this table.\nThere are no different rows with the same recordDate.\nThis table contains information about the temperature on a certain day.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find all dates&#39; <code>Id</code> with higher temperatures compared to its previous dates (yesterday).</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nWeather table:\n+----+------------+-------------+\n| id | recordDate | temperature |\n+----+------------+-------------+\n| 1  | 2015-01-01 | 10          |\n| 2  | 2015-01-02 | 25          |\n| 3  | 2015-01-03 | 20          |\n| 4  | 2015-01-04 | 30          |\n+----+------------+-------------+\n<strong>Output:</strong> \n+----+\n| id |\n+----+\n| 2  |\n| 4  |\n+----+\n<strong>Explanation:</strong> \nIn 2015-01-02, the temperature was higher than the previous day (10 -&gt; 25).\nIn 2015-01-04, the temperature was higher than the previous day (20 -&gt; 30).\n</pre>\n"}}, "198": {"__typename": "QuestionLightNode", "acRate": 0.5496387887506458, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "198", "isFavor": false, "solutionNum": 5438, "title": "House Robber", "titleCn": "打家劫舍", "titleSlug": "house-robber", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 118, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>\n\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong> 不触动警报装置的情况下 </strong>，一夜之内能够偷窃到的最高金额。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1,2,3,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[2,7,9,3,1]\n<strong>输出：</strong>12\n<strong>解释：</strong>偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 100</code></li>\n\t<li><code>0 <= nums[i] <= 400</code></li>\n</ul>\n", "en": "<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>\n\n<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <b>without alerting the police</b></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,7,9,3,1]\n<strong>Output:</strong> 12\n<strong>Explanation:</strong> Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 400</code></li>\n</ul>\n"}}, "199": {"__typename": "QuestionLightNode", "acRate": 0.6690424240014446, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "199", "isFavor": false, "solutionNum": 3307, "title": "Binary Tree Right Side View", "titleCn": "二叉树的右视图", "titleSlug": "binary-tree-right-side-view", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 90, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\" style=\"width: 270px; \" /></p>\n\n<pre>\n<strong>输入:</strong> [1,2,3,null,5,null,4]\n<strong>输出:</strong> [1,3,4]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,null,3]\n<strong>输出:</strong> [1,3]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> []\n<strong>输出:</strong> []\n</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,100]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-100 <= Node.val <= 100</code> </li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\" style=\"width: 401px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,5,null,4]\n<strong>Output:</strong> [1,3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3]\n<strong>Output:</strong> [1,3]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n"}}, "200": {"__typename": "QuestionLightNode", "acRate": 0.6038034924013149, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "200", "isFavor": false, "solutionNum": 4522, "title": "Number of Islands", "titleCn": "岛屿数量", "titleSlug": "number-of-islands", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "n6a2i", "name": "Union Find", "slug": "union-find", "nameTranslated": "并查集", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 175, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>\n\n<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>\n\n<p>此外，你可以假设该网格的四条边均被水包围。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 <= m, n <= 300</code></li>\n\t<li><code>grid[i][j]</code> 的值为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n", "en": "<p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), return <em>the number of islands</em>.</p>\n\n<p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]\n]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],\n  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]\n]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>grid[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n"}}, "201": {"__typename": "QuestionLightNode", "acRate": 0.5452818702057713, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "201", "isFavor": false, "solutionNum": 581, "title": "Bitwise AND of Numbers Range", "titleCn": "数字范围按位与", "titleSlug": "bitwise-and-of-numbers-range", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 26, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个整数 <code>left</code> 和 <code>right</code> ，表示区间 <code>[left, right]</code> ，返回此区间内所有数字 <strong>按位与</strong> 的结果（包含 <code>left</code> 、<code>right</code> 端点）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 5, right = 7\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 0, right = 0\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>left = 1, right = 2147483647\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= left <= right <= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given two integers <code>left</code> and <code>right</code> that represent the range <code>[left, right]</code>, return <em>the bitwise AND of all numbers in this range, inclusive</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 5, right = 7\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 0, right = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> left = 1, right = 2147483647\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= left &lt;= right &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "202": {"__typename": "QuestionLightNode", "acRate": 0.6421544210012766, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "202", "isFavor": false, "solutionNum": 3412, "title": "Happy Number", "titleCn": "快乐数", "titleSlug": "happy-number", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 70, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1604559404-lBlorc-https---i.forbesimg.com-media-lists-companies-jpmorgan-chase_416x416.jpg", "slug": "jpmorgan", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>\n\n<p><strong>「快乐数」</strong>&nbsp;定义为：</p>\n\n<ul>\n\t<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>\n\t<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li>\n\t<li>如果这个过程 <strong>结果为</strong>&nbsp;1，那么这个数就是快乐数。</li>\n</ul>\n\n<p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 19\n<strong>输出：</strong>true\n<strong>解释：\n</strong>1<sup>2</sup> + 9<sup>2</sup> = 82\n8<sup>2</sup> + 2<sup>2</sup> = 68\n6<sup>2</sup> + 8<sup>2</sup> = 100\n1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Write an algorithm to determine if a number <code>n</code> is happy.</p>\n\n<p>A <strong>happy number</strong> is a number defined by the following process:</p>\n\n<ul>\n\t<li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li>\n\t<li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li>\n\t<li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if</em> <code>n</code> <em>is a happy number, and</em> <code>false</code> <em>if not</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 19\n<strong>Output:</strong> true\n<strong>Explanation:</strong>\n1<sup>2</sup> + 9<sup>2</sup> = 82\n8<sup>2</sup> + 2<sup>2</sup> = 68\n6<sup>2</sup> + 8<sup>2</sup> = 100\n1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "203": {"__typename": "QuestionLightNode", "acRate": 0.5649343684640549, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "203", "isFavor": false, "solutionNum": 3800, "title": "Remove Linked List Elements", "titleCn": "移除链表元素", "titleSlug": "remove-linked-list-elements", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 67, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg\" style=\"width: 500px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,6,3,4,5,6], val = 6\n<strong>输出：</strong>[1,2,3,4,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [], val = 1\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = [7,7,7,7], val = 7\n<strong>输出：</strong>[]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>列表中的节点数目在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>1 <= Node.val <= 50</code></li>\n\t<li><code>0 <= val <= 50</code></li>\n</ul>\n", "en": "<p>Given the <code>head</code> of a linked list and an integer <code>val</code>, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return <em>the new head</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg\" style=\"width: 500px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,6,3,4,5,6], val = 6\n<strong>Output:</strong> [1,2,3,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [], val = 1\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [7,7,7,7], val = 7\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 50</code></li>\n\t<li><code>0 &lt;= val &lt;= 50</code></li>\n</ul>\n"}}, "204": {"__typename": "QuestionLightNode", "acRate": 0.37010107675717435, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "204", "isFavor": false, "solutionNum": 1166, "title": "Count Primes", "titleCn": "计数质数", "titleSlug": "count-primes", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "2men8m", "name": "Enumeration", "slug": "enumeration", "nameTranslated": "枚举", "__typename": "CommonTagNode"}, {"id": "3vubuc", "name": "Number Theory", "slug": "number-theory", "nameTranslated": "数论", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 83, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1711090840-jlSkmv-capital one.png", "slug": "capital-one", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定整数 <code>n</code> ，返回 <em>所有小于非负整数&nbsp;<code>n</code>&nbsp;的质数的数量</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10\n<strong>输出：</strong>4\n<strong>解释：</strong>小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 0\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出</strong>：0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 5 * 10<sup>6</sup></code></li>\n</ul>\n", "en": "<p>Given an integer <code>n</code>, return <em>the number of prime numbers that are strictly less than</em> <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 5 * 10<sup>6</sup></code></li>\n</ul>\n"}}, "205": {"__typename": "QuestionLightNode", "acRate": 0.4932563413593599, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "205", "isFavor": false, "solutionNum": 1845, "title": "Isomorphic Strings", "titleCn": "同构字符串", "titleSlug": "isomorphic-strings", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 50, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个字符串&nbsp;<code>s</code>&nbsp;和&nbsp;<code>t</code>&nbsp;，判断它们是否是同构的。</p>\n\n<p>如果&nbsp;<code>s</code>&nbsp;中的字符可以按某种映射关系替换得到&nbsp;<code>t</code>&nbsp;，那么这两个字符串是同构的。</p>\n\n<p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>s = <code>\"egg\"</code>, t = <code>\"add\"</code>\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = <code>\"foo\"</code>, t = <code>\"bar\"</code>\n<strong>输出：</strong>false</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = <code>\"paper\"</code>, t = <code>\"title\"</code>\n<strong>输出：</strong>true</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>t.length == s.length</code></li>\n\t<li><code>s</code>&nbsp;和&nbsp;<code>t</code>&nbsp;由任意有效的 ASCII 字符组成</li>\n</ul>\n", "en": "<p>Given two strings <code>s</code> and <code>t</code>, <em>determine if they are isomorphic</em>.</p>\n\n<p>Two strings <code>s</code> and <code>t</code> are isomorphic if the characters in <code>s</code> can be replaced to get <code>t</code>.</p>\n\n<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"egg\", t = \"add\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"foo\", t = \"bar\"\n<strong>Output:</strong> false\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> s = \"paper\", t = \"title\"\n<strong>Output:</strong> true\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>t.length == s.length</code></li>\n\t<li><code>s</code> and <code>t</code> consist of any valid ascii character.</li>\n</ul>\n"}}, "206": {"__typename": "QuestionLightNode", "acRate": 0.7424153392051912, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "206", "isFavor": false, "solutionNum": 12689, "title": "Reverse Linked List", "titleCn": "反转链表", "titleSlug": "reverse-linked-list", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 220, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。\n<div class=\"original__bRMd\">\n<div>\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5]\n<strong>输出：</strong>[5,4,3,2,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\" style=\"width: 182px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2]\n<strong>输出：</strong>[2,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>\n\t<li><code>-5000 <= Node.val <= 5000</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>\n</div>\n</div>\n", "en": "<p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\" style=\"width: 542px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5]\n<strong>Output:</strong> [5,4,3,2,1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\" style=\"width: 182px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2]\n<strong>Output:</strong> [2,1]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li>\n\t<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> A linked list can be reversed either iteratively or recursively. Could you implement both?</p>\n"}}, "207": {"__typename": "QuestionLightNode", "acRate": 0.5394430608271977, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "207", "isFavor": false, "solutionNum": 2589, "title": "Course Schedule", "titleCn": "课程表", "titleSlug": "course-schedule", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}, {"id": "ns19t", "name": "Topological Sort", "slug": "topological-sort", "nameTranslated": "拓扑排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 91, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你这个学期必须选修 <code>numCourses</code> 门课程，记为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>numCourses - 1</code> 。</p>\n\n<p>在选修某些课程之前需要一些先修课程。 先修课程按数组&nbsp;<code>prerequisites</code> 给出，其中&nbsp;<code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> ，表示如果要学习课程&nbsp;<code>a<sub>i</sub></code> 则 <strong>必须</strong> 先学习课程&nbsp; <code>b<sub>i</sub></code><sub> </sub>。</p>\n\n<ul>\n\t<li>例如，先修课程对&nbsp;<code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>\n</ul>\n\n<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 2, prerequisites = [[1,0]]\n<strong>输出：</strong>true\n<strong>解释：</strong>总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 2, prerequisites = [[1,0],[0,1]]\n<strong>输出：</strong>false\n<strong>解释：</strong>总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>\n\t<li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li>\n</ul>\n", "en": "<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>\n\n<ul>\n\t<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>\n</ul>\n\n<p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0],[0,1]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>\n\t<li>All the pairs prerequisites[i] are <strong>unique</strong>.</li>\n</ul>\n"}}, "208": {"__typename": "QuestionLightNode", "acRate": 0.7195978352525464, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "208", "isFavor": false, "solutionNum": 1866, "title": "Implement Trie (Prefix Tree)", "titleCn": "实现 Trie (前缀树)", "titleSlug": "implement-trie-prefix-tree", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 83, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><strong><a href=\"https://baike.baidu.com/item/字典树/9825209?fr=aladdin\" target=\"_blank\">Trie</a></strong>（发音类似 \"try\"）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>\n\n<p>请你实现 Trie 类：</p>\n\n<ul>\n\t<li><code>Trie()</code> 初始化前缀树对象。</li>\n\t<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>\n\t<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>\n\t<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\n<strong>输出</strong>\n[null, null, true, false, true, null, true]\n\n<strong>解释</strong>\nTrie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // 返回 True\ntrie.search(\"app\");     // 返回 False\ntrie.startsWith(\"app\"); // 返回 True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // 返回 True\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= word.length, prefix.length <= 2000</code></li>\n\t<li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>\n\t<li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 10<sup>4</sup></code> 次</li>\n</ul>\n", "en": "<p>A <a href=\"https://en.wikipedia.org/wiki/Trie\" target=\"_blank\"><strong>trie</strong></a> (pronounced as &quot;try&quot;) or <strong>prefix tree</strong> is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.</p>\n\n<p>Implement the Trie class:</p>\n\n<ul>\n\t<li><code>Trie()</code> Initializes the trie object.</li>\n\t<li><code>void insert(String word)</code> Inserts the string <code>word</code> into the trie.</li>\n\t<li><code>boolean search(String word)</code> Returns <code>true</code> if the string <code>word</code> is in the trie (i.e., was inserted before), and <code>false</code> otherwise.</li>\n\t<li><code>boolean startsWith(String prefix)</code> Returns <code>true</code> if there is a previously inserted string <code>word</code> that has the prefix <code>prefix</code>, and <code>false</code> otherwise.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]\n[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]\n<strong>Output</strong>\n[null, null, true, false, true, null, true]\n\n<strong>Explanation</strong>\nTrie trie = new Trie();\ntrie.insert(&quot;apple&quot;);\ntrie.search(&quot;apple&quot;);   // return True\ntrie.search(&quot;app&quot;);     // return False\ntrie.startsWith(&quot;app&quot;); // return True\ntrie.insert(&quot;app&quot;);\ntrie.search(&quot;app&quot;);     // return True\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>\n\t<li><code>word</code> and <code>prefix</code> consist only of lowercase English letters.</li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>insert</code>, <code>search</code>, and <code>startsWith</code>.</li>\n</ul>\n"}}, "209": {"__typename": "QuestionLightNode", "acRate": 0.46375644851021686, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "209", "isFavor": false, "solutionNum": 4277, "title": "Minimum Size Subarray Sum", "titleCn": "长度最小的子数组", "titleSlug": "minimum-size-subarray-sum", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 62, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个含有&nbsp;<code>n</code><strong>&nbsp;</strong>个正整数的数组和一个正整数 <code>target</code><strong> 。</strong></p>\n\n<p>找出该数组中满足其总和大于等于<strong> </strong><code>target</code><strong> </strong>的长度最小的 <strong>连续<span data-keyword=\"subarray-nonempty\">子数组</span></strong>&nbsp;<code>[nums<sub>l</sub>, nums<sub>l+1</sub>, ..., nums<sub>r-1</sub>, nums<sub>r</sub>]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 7, nums = [2,3,1,2,4,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>子数组&nbsp;<code>[4,3]</code>&nbsp;是该条件下的长度最小的子数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 4, nums = [1,4,4]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>target = 11, nums = [1,1,1,1,1,1,1,1]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>如果你已经实现<em> </em><code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li>\n</ul>\n", "en": "<p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return <em>the <strong>minimal length</strong> of a </em><span data-keyword=\"subarray-nonempty\"><em>subarray</em></span><em> whose sum is greater than or equal to</em> <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 7, nums = [2,3,1,2,4,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The subarray [4,3] has the minimal length under the problem constraint.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 4, nums = [1,4,4]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> target = 11, nums = [1,1,1,1,1,1,1,1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> If you have figured out the <code>O(n)</code> solution, try coding another solution of which the time complexity is <code>O(n log(n))</code>."}}, "210": {"__typename": "QuestionLightNode", "acRate": 0.5796736523294577, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "210", "isFavor": false, "solutionNum": 1554, "title": "Course Schedule II", "titleCn": "课程表 II", "titleSlug": "course-schedule-ii", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}, {"id": "ns19t", "name": "Topological Sort", "slug": "topological-sort", "nameTranslated": "拓扑排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 81, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>现在你总共有 <code>numCourses</code> 门课需要选，记为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>numCourses - 1</code>。给你一个数组&nbsp;<code>prerequisites</code> ，其中 <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> ，表示在选修课程 <code>a<sub>i</sub></code> 前 <strong>必须</strong> 先选修&nbsp;<code>b<sub>i</sub></code> 。</p>\n\n<ul>\n\t<li>例如，想要学习课程 <code>0</code> ，你需要先完成课程&nbsp;<code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。</li>\n</ul>\n\n<p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 2, prerequisites = [[1,0]]\n<strong>输出：</strong>[0,1]\n<strong>解释：</strong>总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 <code>[0,1] 。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n<strong>输出：</strong>[0,2,1,3]\n<strong>解释：</strong>总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。\n因此，一个正确的课程顺序是&nbsp;<code>[0,1,2,3]</code> 。另一个正确的排序是&nbsp;<code>[0,2,1,3]</code> 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>numCourses = 1, prerequisites = []\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n<strong>提示：</strong>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>所有<code>[a<sub>i</sub>, b<sub>i</sub>]</code> <strong>互不相同</strong></li>\n</ul>\n", "en": "<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p>\n\n<ul>\n\t<li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li>\n</ul>\n\n<p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n<strong>Output:</strong> [0,2,1,3]\n<strong>Explanation:</strong> There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numCourses = 1, prerequisites = []\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= numCourses &lt;= 2000</code></li>\n\t<li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li>\n\t<li><code>prerequisites[i].length == 2</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; numCourses</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>All the pairs <code>[a<sub>i</sub>, b<sub>i</sub>]</code> are <strong>distinct</strong>.</li>\n</ul>\n"}}, "211": {"__typename": "QuestionLightNode", "acRate": 0.49971141636846356, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "211", "isFavor": false, "solutionNum": 825, "title": "Design Add and Search Words Data Structure", "titleCn": "添加与搜索单词 - 数据结构设计", "titleSlug": "design-add-and-search-words-data-structure", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 46, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。</p>\n\n<p>实现词典类 <code>WordDictionary</code> ：</p>\n\n<ul>\n\t<li><code>WordDictionary()</code> 初始化词典对象</li>\n\t<li><code>void addWord(word)</code> 将 <code>word</code> 添加到数据结构中，之后可以对它进行匹配</li>\n\t<li><code>bool search(word)</code> 如果数据结构中存在字符串与&nbsp;<code>word</code> 匹配，则返回 <code>true</code> ；否则，返回&nbsp; <code>false</code> 。<code>word</code> 中可能包含一些 <code>'.'</code> ，每个&nbsp;<code>.</code> 都可以表示任何一个字母。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\n<strong>输出：</strong>\n[null,null,null,null,false,true,true,true]\n\n<strong>解释：</strong>\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\"bad\");\nwordDictionary.addWord(\"dad\");\nwordDictionary.addWord(\"mad\");\nwordDictionary.search(\"pad\"); // 返回 False\nwordDictionary.search(\"bad\"); // 返回 True\nwordDictionary.search(\".ad\"); // 返回 True\nwordDictionary.search(\"b..\"); // 返回 True\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 25</code></li>\n\t<li><code>addWord</code> 中的 <code>word</code> 由小写英文字母组成</li>\n\t<li><code>search</code> 中的 <code>word</code> 由 '.' 或小写英文字母组成</li>\n\t<li>最多调用 <code>10<sup>4</sup></code> 次 <code>addWord</code> 和 <code>search</code></li>\n</ul>\n", "en": "<p>Design a data structure that supports adding new words and finding if a string matches any previously added string.</p>\n\n<p>Implement the <code>WordDictionary</code> class:</p>\n\n<ul>\n\t<li><code>WordDictionary()</code>&nbsp;Initializes the object.</li>\n\t<li><code>void addWord(word)</code> Adds <code>word</code> to the data structure, it can be matched later.</li>\n\t<li><code>bool search(word)</code>&nbsp;Returns <code>true</code> if there is any string in the data structure that matches <code>word</code>&nbsp;or <code>false</code> otherwise. <code>word</code> may contain dots <code>&#39;.&#39;</code> where dots can be matched with any letter.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]\n[[],[&quot;bad&quot;],[&quot;dad&quot;],[&quot;mad&quot;],[&quot;pad&quot;],[&quot;bad&quot;],[&quot;.ad&quot;],[&quot;b..&quot;]]\n<strong>Output</strong>\n[null,null,null,null,false,true,true,true]\n\n<strong>Explanation</strong>\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(&quot;bad&quot;);\nwordDictionary.addWord(&quot;dad&quot;);\nwordDictionary.addWord(&quot;mad&quot;);\nwordDictionary.search(&quot;pad&quot;); // return False\nwordDictionary.search(&quot;bad&quot;); // return True\nwordDictionary.search(&quot;.ad&quot;); // return True\nwordDictionary.search(&quot;b..&quot;); // return True\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 25</code></li>\n\t<li><code>word</code> in <code>addWord</code> consists of lowercase English letters.</li>\n\t<li><code>word</code> in <code>search</code> consist of <code>&#39;.&#39;</code> or lowercase English letters.</li>\n\t<li>There will be at most <code>2</code> dots in <code>word</code> for <code>search</code> queries.</li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>addWord</code> and <code>search</code>.</li>\n</ul>\n"}}, "212": {"__typename": "QuestionLightNode", "acRate": 0.43176714422866935, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "212", "isFavor": false, "solutionNum": 802, "title": "Word Search II", "titleCn": "单词搜索 II", "titleSlug": "word-search-ii", "topicTags": [{"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 70, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个&nbsp;<code>m x n</code> 二维字符网格&nbsp;<code>board</code><strong>&nbsp;</strong>和一个单词（字符串）列表 <code>words</code>，&nbsp;<em>返回所有二维网格上的单词</em>&nbsp;。</p>\n\n<p>单词必须按照字母顺序，通过 <strong>相邻的单元格</strong> 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/07/search1.jpg\" />\n<pre>\n<strong>输入：</strong>board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n<strong>输出：</strong>[\"eat\",\"oath\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/07/search2.jpg\" />\n<pre>\n<strong>输入：</strong>board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 12</code></li>\n\t<li><code>board[i][j]</code> 是一个小写英文字母</li>\n\t<li><code>1 &lt;= words.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n\t<li><code>words</code> 中的所有字符串互不相同</li>\n</ul>\n", "en": "<p>Given an <code>m x n</code> <code>board</code>&nbsp;of characters and a list of strings <code>words</code>, return <em>all words on the board</em>.</p>\n\n<p>Each word must be constructed from letters of sequentially adjacent cells, where <strong>adjacent cells</strong> are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/07/search1.jpg\" style=\"width: 322px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]\n<strong>Output:</strong> [&quot;eat&quot;,&quot;oath&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/07/search2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words = [&quot;abcb&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 12</code></li>\n\t<li><code>board[i][j]</code> is a lowercase English letter.</li>\n\t<li><code>1 &lt;= words.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n\t<li>All the strings of <code>words</code> are unique.</li>\n</ul>\n"}}, "213": {"__typename": "QuestionLightNode", "acRate": 0.4493983373286586, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "213", "isFavor": false, "solutionNum": 3061, "title": "House Robber II", "titleCn": "打家劫舍 II", "titleSlug": "house-robber-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 50, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>\n\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,3,2]\n<strong>输出：</strong>3\n<strong>解释：</strong>你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,1]\n<strong>输出：</strong>4\n<strong>解释：</strong>你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。\n&nbsp;    偷窃到的最高金额 = 1 + 3 = 4 。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n", "en": "<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and&nbsp;<b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>\n\n<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n"}}, "214": {"__typename": "QuestionLightNode", "acRate": 0.4036364777308881, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "214", "isFavor": false, "solutionNum": 517, "title": "Shortest Palindrome", "titleCn": "最短回文串", "titleSlug": "shortest-palindrome", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "ydzvgh", "name": "String Matching", "slug": "string-matching", "nameTranslated": "字符串匹配", "__typename": "CommonTagNode"}, {"id": "xp2e97i", "name": "Hash Function", "slug": "hash-function", "nameTranslated": "哈希函数", "__typename": "CommonTagNode"}, {"id": "xp2a8mr", "name": "Rolling Hash", "slug": "rolling-hash", "nameTranslated": "滚动哈希", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 45, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2020/04/a29f4ff2-772d-4e94-b034-fe2815298cc9/%E7%BD%91%E6%98%93logo-%E6%96%B9.png", "slug": "netease", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个字符串 <em><strong>s</strong></em>，你可以通过在字符串前面添加字符将其转换为<span data-keyword=\"palindrome-string\">回文串</span>。找到并返回可以用这种方式转换的最短回文串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aacecaaa\"\n<strong>输出：</strong>\"aaacecaaa\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\"\n<strong>输出：</strong>\"dcbabcd\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n", "en": "<p>You are given a string <code>s</code>. You can convert <code>s</code> to a <span data-keyword=\"palindrome-string\">palindrome</span> by adding characters in front of it.</p>\n\n<p>Return <em>the shortest palindrome you can find by performing this transformation</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"aacecaaa\"\n<strong>Output:</strong> \"aaacecaaa\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"abcd\"\n<strong>Output:</strong> \"dcbabcd\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters only.</li>\n</ul>\n"}}, "215": {"__typename": "QuestionLightNode", "acRate": 0.6157214147386789, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "215", "isFavor": false, "solutionNum": 4614, "title": "Kth Largest Element in an Array", "titleCn": "数组中的第K个最大元素", "titleSlug": "kth-largest-element-in-an-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "gl65v1", "name": "Quickselect", "slug": "quickselect", "nameTranslated": "快速选择", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 138, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code><strong>k</strong></code> 个最大的元素。</p>\n\n<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>\n\n<p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>[3,2,1,5,6,4],</code> k = 2\n<strong>输出:</strong> 5\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>[3,2,3,1,2,4,5,5,6], </code>k = 4\n<strong>输出:</strong> 4</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示： </strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>largest element in the array</em>.</p>\n\n<p>Note that it is the <code>k<sup>th</sup></code> largest element in the sorted order, not the <code>k<sup>th</sup></code> distinct element.</p>\n\n<p>Can you solve it without sorting?</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [3,2,1,5,6,4], k = 2\n<strong>Output:</strong> 5\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [3,2,3,1,2,4,5,5,6], k = 4\n<strong>Output:</strong> 4\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "216": {"__typename": "QuestionLightNode", "acRate": 0.7102142129333429, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "216", "isFavor": false, "solutionNum": 2292, "title": "Combination Sum III", "titleCn": "组合总和 III", "titleSlug": "combination-sum-iii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 42, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>找出所有相加之和为&nbsp;<code>n</code><em> </em>的&nbsp;<code>k</code><strong>&nbsp;</strong>个数的组合，且满足下列条件：</p>\n\n<ul>\n\t<li>只使用数字1到9</li>\n\t<li>每个数字&nbsp;<strong>最多使用一次</strong>&nbsp;</li>\n</ul>\n\n<p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <em><strong>k</strong></em> = 3, <em><strong>n</strong></em> = 7\n<strong>输出:</strong> [[1,2,4]]\n<strong>解释:</strong>\n1 + 2 + 4 = 7\n没有其他符合的组合了。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> <em><strong>k</strong></em> = 3, <em><strong>n</strong></em> = 9\n<strong>输出:</strong> [[1,2,6], [1,3,5], [2,3,4]]\n<strong>解释:\n</strong>1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\n没有其他符合的组合了。</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> k = 4, n = 1\n<strong>输出:</strong> []\n<strong>解释:</strong> 不存在有效的组合。\n在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 9</code></li>\n\t<li><code>1 &lt;= n &lt;= 60</code></li>\n</ul>\n", "en": "<p>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p>\n\n<ul>\n\t<li>Only numbers <code>1</code> through <code>9</code> are used.</li>\n\t<li>Each number is used <strong>at most once</strong>.</li>\n</ul>\n\n<p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 7\n<strong>Output:</strong> [[1,2,4]]\n<strong>Explanation:</strong>\n1 + 2 + 4 = 7\nThere are no other valid combinations.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 9\n<strong>Output:</strong> [[1,2,6],[1,3,5],[2,3,4]]\n<strong>Explanation:</strong>\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 4, n = 1\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no valid combinations.\nUsing 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &gt; 1, there are no valid combination.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 9</code></li>\n\t<li><code>1 &lt;= n &lt;= 60</code></li>\n</ul>\n"}}, "217": {"__typename": "QuestionLightNode", "acRate": 0.5516785799195791, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "217", "isFavor": false, "solutionNum": 3965, "title": "Contains Duplicate", "titleCn": "存在重复元素", "titleSlug": "contains-duplicate", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 70, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "给你一个整数数组 <code>nums</code> 。如果任一值在数组中出现 <strong>至少两次</strong> ，返回 <code>true</code> ；如果数组中每个元素互不相同，返回 <code>false</code> 。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,1]\n<strong>输出：</strong>true</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>false</pre>\n\n<p><strong>示例&nbsp;3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,3,3,4,3,2,4,2]\n<strong>输出：</strong>true</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code>, return <code>true</code> if any value appears <strong>at least twice</strong> in the array, and return <code>false</code> if every element is distinct.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3,1]\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> false\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1,1,3,3,4,3,2,4,2]\n<strong>Output:</strong> true\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "218": {"__typename": "QuestionLightNode", "acRate": 0.5527564542743233, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "218", "isFavor": false, "solutionNum": 466, "title": "The Skyline Problem", "titleCn": "天际线问题", "titleSlug": "the-skyline-problem", "topicTags": [{"id": "n16hs", "name": "Binary Indexed Tree", "slug": "binary-indexed-tree", "nameTranslated": "树状数组", "__typename": "CommonTagNode"}, {"id": "nytfd", "name": "Segment Tree", "slug": "segment-tree", "nameTranslated": "线段树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "qwy9jd", "name": "Ordered Set", "slug": "ordered-set", "nameTranslated": "有序集合", "__typename": "CommonTagNode"}, {"id": "x54mxi3", "name": "Line Sweep", "slug": "line-sweep", "nameTranslated": "扫描线", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 63, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>城市的 <strong>天际线</strong> 是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回 <em>由这些建筑物形成的<strong> 天际线</strong></em> 。</p>\n\n<p>每个建筑物的几何信息由数组 <code>buildings</code> 表示，其中三元组 <code>buildings[i] = [lefti, righti, heighti]</code> 表示：</p>\n\n<ul>\n\t<li><code>left<sub>i</sub></code> 是第 <code>i</code> 座建筑物左边缘的 <code>x</code> 坐标。</li>\n\t<li><code>right<sub>i</sub></code> 是第 <code>i</code> 座建筑物右边缘的 <code>x</code> 坐标。</li>\n\t<li><code>height<sub>i</sub></code> 是第 <code>i</code> 座建筑物的高度。</li>\n</ul>\n\n<p>你可以假设所有的建筑都是完美的长方形，在高度为 <code>0</code>&nbsp;的绝对平坦的表面上。</p>\n\n<p><strong>天际线</strong> 应该表示为由 “关键点” 组成的列表，格式 <code>[[x<sub>1</sub>,y<sub>1</sub>],[x<sub>2</sub>,y<sub>2</sub>],...]</code> ，并按 <strong>x 坐标 </strong>进行 <strong>排序</strong> 。<strong>关键点是水平线段的左端点</strong>。列表中最后一个点是最右侧建筑物的终点，<code>y</code> 坐标始终为 <code>0</code> ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>\n\n<p><strong>注意：</strong>输出天际线中不得有连续的相同高度的水平线。例如 <code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code> 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：<code>[...[2 3], [4 5], [12 7], ...]</code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/merged.jpg\" style=\"height: 331px; width: 800px;\" />\n<pre>\n<strong>输入：</strong>buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n<strong>输出：</strong>[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n<strong>解释：</strong>\n图 A<strong> </strong>显示输入的所有建筑物的位置和高度，\n图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>buildings = [[0,2,3],[2,5,3]]\n<strong>输出：</strong>[[0,3],[5,0]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= buildings.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= left<sub>i</sub> &lt; right<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 &lt;= height<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>buildings</code> 按 <code>left<sub>i</sub></code> 非递减排序</li>\n</ul>\n", "en": "<p>A city&#39;s <strong>skyline</strong> is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return <em>the <strong>skyline</strong> formed by these buildings collectively</em>.</p>\n\n<p>The geometric information of each building is given in the array <code>buildings</code> where <code>buildings[i] = [left<sub>i</sub>, right<sub>i</sub>, height<sub>i</sub>]</code>:</p>\n\n<ul>\n\t<li><code>left<sub>i</sub></code> is the x coordinate of the left edge of the <code>i<sup>th</sup></code> building.</li>\n\t<li><code>right<sub>i</sub></code> is the x coordinate of the right edge of the <code>i<sup>th</sup></code> building.</li>\n\t<li><code>height<sub>i</sub></code> is the height of the <code>i<sup>th</sup></code> building.</li>\n</ul>\n\n<p>You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height <code>0</code>.</p>\n\n<p>The <strong>skyline</strong> should be represented as a list of &quot;key points&quot; <strong>sorted by their x-coordinate</strong> in the form <code>[[x<sub>1</sub>,y<sub>1</sub>],[x<sub>2</sub>,y<sub>2</sub>],...]</code>. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate <code>0</code> and is used to mark the skyline&#39;s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline&#39;s contour.</p>\n\n<p><b>Note:</b> There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...,[2 3],[4 5],[12 7],...]</code></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/01/merged.jpg\" style=\"width: 800px; height: 331px;\" />\n<pre>\n<strong>Input:</strong> buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]\n<strong>Output:</strong> [[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]\n<strong>Explanation:</strong>\nFigure A shows the buildings of the input.\nFigure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> buildings = [[0,2,3],[2,5,3]]\n<strong>Output:</strong> [[0,3],[5,0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= buildings.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= left<sub>i</sub> &lt; right<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 &lt;= height<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>buildings</code> is sorted by <code>left<sub>i</sub></code> in&nbsp;non-decreasing order.</li>\n</ul>\n"}}, "219": {"__typename": "QuestionLightNode", "acRate": 0.46267683291849143, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "219", "isFavor": false, "solutionNum": 2080, "title": "Contains Duplicate II", "titleCn": "存在重复元素 II", "titleSlug": "contains-duplicate-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 46, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组&nbsp;<code>nums</code> 和一个整数&nbsp;<code>k</code> ，判断数组中是否存在两个 <strong>不同的索引</strong><em>&nbsp;</em><code>i</code>&nbsp;和<em>&nbsp;</em><code>j</code> ，满足 <code>nums[i] == nums[j]</code> 且 <code>abs(i - j) &lt;= k</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,1], k<em> </em>= 3\n<strong>输出：</strong>true</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,0,1,1], k<em> </em>=<em> </em>1\n<strong>输出：</strong>true</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,1,2,3], k<em> </em>=<em> </em>2\n<strong>输出：</strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> <em>if there are two <strong>distinct indices</strong> </em><code>i</code><em> and </em><code>j</code><em> in the array such that </em><code>nums[i] == nums[j]</code><em> and </em><code>abs(i - j) &lt;= k</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1], k = 3\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,1,1], k = 1\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1,2,3], k = 2\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "220": {"__typename": "QuestionLightNode", "acRate": 0.30540430104272287, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "220", "isFavor": false, "solutionNum": 659, "title": "Contains Duplicate III", "titleCn": "存在重复元素 III", "titleSlug": "contains-duplicate-iii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "eqnkri", "name": "Bucket Sort", "slug": "bucket-sort", "nameTranslated": "桶排序", "__typename": "CommonTagNode"}, {"id": "qwy9jd", "name": "Ordered Set", "slug": "ordered-set", "nameTranslated": "有序集合", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 37, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> 和两个整数 <code>indexDiff</code> 和 <code>valueDiff</code> 。</p>\n\n<p>找出满足下述条件的下标对 <code>(i, j)</code>：</p>\n\n<ul>\n\t<li><code>i != j</code>,</li>\n\t<li><code>abs(i - j) &lt;= indexDiff</code></li>\n\t<li><code>abs(nums[i] - nums[j]) &lt;= valueDiff</code></li>\n</ul>\n\n<p>如果存在，返回 <code>true</code><em> ；</em>否则，返回<em> </em><code>false</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\n<strong>输出：</strong>true\n<strong>解释：</strong>可以找出 (i, j) = (0, 3) 。\n满足下述 3 个条件：\ni != j --&gt; 0 != 3\nabs(i - j) &lt;= indexDiff --&gt; abs(0 - 3) &lt;= 3\nabs(nums[i] - nums[j]) &lt;= valueDiff --&gt; abs(1 - 1) &lt;= 0\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\n<strong>输出：</strong>false\n<strong>解释：</strong>尝试所有可能的下标对 (i, j) ，均无法满足这 3 个条件，因此返回 false 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= indexDiff &lt;= nums.length</code></li>\n\t<li><code>0 &lt;= valueDiff &lt;= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>You are given an integer array <code>nums</code> and two integers <code>indexDiff</code> and <code>valueDiff</code>.</p>\n\n<p>Find a pair of indices <code>(i, j)</code> such that:</p>\n\n<ul>\n\t<li><code>i != j</code>,</li>\n\t<li><code>abs(i - j) &lt;= indexDiff</code>.</li>\n\t<li><code>abs(nums[i] - nums[j]) &lt;= valueDiff</code>, and</li>\n</ul>\n\n<p>Return <code>true</code><em> if such pair exists or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We can choose (i, j) = (0, 3).\nWe satisfy the three conditions:\ni != j --&gt; 0 != 3\nabs(i - j) &lt;= indexDiff --&gt; abs(0 - 3) &lt;= 3\nabs(nums[i] - nums[j]) &lt;= valueDiff --&gt; abs(1 - 1) &lt;= 0\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\n<strong>Output:</strong> false\n<strong>Explanation:</strong> After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= indexDiff &lt;= nums.length</code></li>\n\t<li><code>0 &lt;= valueDiff &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "221": {"__typename": "QuestionLightNode", "acRate": 0.5024892849778774, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "221", "isFavor": false, "solutionNum": 1895, "title": "Maximal Square", "titleCn": "最大正方形", "titleSlug": "maximal-square", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 80, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>在一个由 <code>'0'</code> 和 <code>'1'</code> 组成的二维矩阵内，找到只包含 <code>'1'</code> 的最大正方形，并返回其面积。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg\" style=\"width: 400px; height: 319px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg\" style=\"width: 165px; height: 165px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[\"0\"]]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 300</code></li>\n\t<li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n", "en": "<p>Given an <code>m x n</code> binary <code>matrix</code> filled with <code>0</code>&#39;s and <code>1</code>&#39;s, <em>find the largest square containing only</em> <code>1</code>&#39;s <em>and return its area</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg\" style=\"width: 400px; height: 319px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg\" style=\"width: 165px; height: 165px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[&quot;0&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;]]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[&quot;0&quot;]]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>matrix[i][j]</code> is <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n"}}, "222": {"__typename": "QuestionLightNode", "acRate": 0.8154749097261427, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "222", "isFavor": false, "solutionNum": 2142, "title": "Count Complete Tree Nodes", "titleCn": "完全二叉树的节点个数", "titleSlug": "count-complete-tree-nodes", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 42, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一棵<strong> 完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>\n\n<p><a href=\"https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin\">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2<sup>h</sup></code> 个节点。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/complete.jpg\" style=\"width: 372px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5,6]\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目范围是<code>[0, 5 * 10<sup>4</sup>]</code></li>\n\t<li><code>0 <= Node.val <= 5 * 10<sup>4</sup></code></li>\n\t<li>题目数据保证输入的树是 <strong>完全二叉树</strong></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>遍历树来统计节点是一种时间复杂度为 <code>O(n)</code> 的简单解决方案。你可以设计一个更快的算法吗？</p>\n", "en": "<p>Given the <code>root</code> of a <strong>complete</strong> binary tree, return the number of the nodes in the tree.</p>\n\n<p>According to <strong><a href=\"http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees\" target=\"_blank\">Wikipedia</a></strong>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2<sup>h</sup></code> nodes inclusive at the last level <code>h</code>.</p>\n\n<p>Design an algorithm that runs in less than&nbsp;<code data-stringify-type=\"code\">O(n)</code>&nbsp;time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/complete.jpg\" style=\"width: 372px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6]\n<strong>Output:</strong> 6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li>The tree is guaranteed to be <strong>complete</strong>.</li>\n</ul>\n"}}, "223": {"__typename": "QuestionLightNode", "acRate": 0.5405624477397997, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "223", "isFavor": false, "solutionNum": 684, "title": "Rectangle Area", "titleCn": "矩形面积", "titleSlug": "rectangle-area", "topicTags": [{"id": "vlt55", "name": "Geometry", "slug": "geometry", "nameTranslated": "几何", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 61, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你 <strong>二维</strong> 平面上两个 <strong>由直线构成且边与坐标轴平行/垂直</strong> 的矩形，请你计算并返回两个矩形覆盖的总面积。</p>\n\n<p>每个矩形由其 <strong>左下</strong> 顶点和 <strong>右上</strong> 顶点坐标表示：</p>\n\n<div class=\"MachineTrans-Lines\">\n<ul>\n\t<li class=\"MachineTrans-lang-zh-CN\">第一个矩形由其左下顶点 <code>(ax1, ay1)</code> 和右上顶点 <code>(ax2, ay2)</code> 定义。</li>\n\t<li class=\"MachineTrans-lang-zh-CN\">第二个矩形由其左下顶点 <code>(bx1, by1)</code> 和右上顶点 <code>(bx2, by2)</code> 定义。</li>\n</ul>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"Rectangle Area\" src=\"https://assets.leetcode.com/uploads/2021/05/08/rectangle-plane.png\" style=\"width: 700px; height: 365px;\" />\n<pre>\n<strong>输入：</strong>ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\n<strong>输出：</strong>45\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2\n<strong>输出：</strong>16\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-10<sup>4</sup> &lt;= ax1, ay1, ax2, ay2, bx1, by1, bx2, by2 &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given the coordinates of two <strong>rectilinear</strong> rectangles in a 2D plane, return <em>the total area covered by the two rectangles</em>.</p>\n\n<p>The first rectangle is defined by its <strong>bottom-left</strong> corner <code>(ax1, ay1)</code> and its <strong>top-right</strong> corner <code>(ax2, ay2)</code>.</p>\n\n<p>The second rectangle is defined by its <strong>bottom-left</strong> corner <code>(bx1, by1)</code> and its <strong>top-right</strong> corner <code>(bx2, by2)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"Rectangle Area\" src=\"https://assets.leetcode.com/uploads/2021/05/08/rectangle-plane.png\" style=\"width: 700px; height: 365px;\" />\n<pre>\n<strong>Input:</strong> ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\n<strong>Output:</strong> 45\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2\n<strong>Output:</strong> 16\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>4</sup> &lt;= ax1 &lt;= ax2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= ay1 &lt;= ay2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= bx1 &lt;= bx2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= by1 &lt;= by2 &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "224": {"__typename": "QuestionLightNode", "acRate": 0.426338455959019, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "224", "isFavor": false, "solutionNum": 1151, "title": "Basic Calculator", "titleCn": "基本计算器", "titleSlug": "basic-calculator", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 100, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>\n\n<p>注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1 + 1\"\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \" 2-1 + 2 \"\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(1+(4+5+2)-3)+(6+8)\"\n<strong>输出：</strong>23\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3&nbsp;* 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由数字、<code>'+'</code>、<code>'-'</code>、<code>'('</code>、<code>')'</code>、和 <code>' '</code> 组成</li>\n\t<li><code>s</code> 表示一个有效的表达式</li>\n\t<li><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'+'</span></span></font></font> 不能用作一元运算(例如， <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">\"+1\"</span></span></font></font>&nbsp;和 <code>\"+(2 + 3)\"</code>&nbsp;无效)</li>\n\t<li><font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'-'</span></span></font></font> 可以用作一元运算(即 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">\"-1\"</span></span></font></font>&nbsp;和 <code>\"-(2 + 3)\"</code>&nbsp;是有效的)</li>\n\t<li>输入中不存在两个连续的操作符</li>\n\t<li>每个数字和运行的计算将适合于一个有符号的 32位 整数</li>\n</ul>\n", "en": "<p>Given a string <code>s</code> representing a valid expression, implement a basic calculator to evaluate it, and return <em>the result of the evaluation</em>.</p>\n\n<p><strong>Note:</strong> You are <strong>not</strong> allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1 + 1&quot;\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot; 2-1 + 2 &quot;\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(1+(4+5+2)-3)+(6+8)&quot;\n<strong>Output:</strong> 23\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of digits, <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, and <code>&#39; &#39;</code>.</li>\n\t<li><code>s</code> represents a valid expression.</li>\n\t<li><code>&#39;+&#39;</code> is <strong>not</strong> used as a unary operation (i.e., <code>&quot;+1&quot;</code> and <code>&quot;+(2 + 3)&quot;</code> is invalid).</li>\n\t<li><code>&#39;-&#39;</code> could be used as a unary operation (i.e., <code>&quot;-1&quot;</code> and <code>&quot;-(2 + 3)&quot;</code> is valid).</li>\n\t<li>There will be no two consecutive operators in the input.</li>\n\t<li>Every number and running calculation will fit in a signed 32-bit integer.</li>\n</ul>\n"}}, "225": {"__typename": "QuestionLightNode", "acRate": 0.6583838369626771, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "225", "isFavor": false, "solutionNum": 5889, "title": "Implement Stack using Queues", "titleCn": "用队列实现栈", "titleSlug": "implement-stack-using-queues", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "vxfk6", "name": "Queue", "slug": "queue", "nameTranslated": "队列", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 69, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p>\n\n<p>实现 <code>MyStack</code> 类：</p>\n\n<ul>\n\t<li><code>void push(int x)</code> 将元素 x 压入栈顶。</li>\n\t<li><code>int pop()</code> 移除并返回栈顶元素。</li>\n\t<li><code>int top()</code> 返回栈顶元素。</li>\n\t<li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li>你只能使用队列的标准操作 —— 也就是&nbsp;<code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和&nbsp;<code>is empty</code>&nbsp;这些操作。</li>\n\t<li>你所使用的语言也许不支持队列。&nbsp;你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列&nbsp;, 只要是标准的队列操作即可。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n<strong>输出：</strong>\n[null, null, null, 2, 2, false]\n\n<strong>解释：</strong>\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // 返回 2\nmyStack.pop(); // 返回 2\nmyStack.empty(); // 返回 False\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= 9</code></li>\n\t<li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li>\n\t<li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能否仅用一个队列来实现栈。</p>\n", "en": "<p>Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (<code>push</code>, <code>top</code>, <code>pop</code>, and <code>empty</code>).</p>\n\n<p>Implement the <code>MyStack</code> class:</p>\n\n<ul>\n\t<li><code>void push(int x)</code> Pushes element x to the top of the stack.</li>\n\t<li><code>int pop()</code> Removes the element on the top of the stack and returns it.</li>\n\t<li><code>int top()</code> Returns the element on the top of the stack.</li>\n\t<li><code>boolean empty()</code> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li>\n</ul>\n\n<p><b>Notes:</b></p>\n\n<ul>\n\t<li>You must use <strong>only</strong> standard operations of a queue, which means that only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code> and <code>is empty</code> operations are valid.</li>\n\t<li>Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue&#39;s standard operations.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n<strong>Output</strong>\n[null, null, null, 2, 2, false]\n\n<strong>Explanation</strong>\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= 9</code></li>\n\t<li>At most <code>100</code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>empty</code>.</li>\n\t<li>All the calls to <code>pop</code> and <code>top</code> are valid.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you implement the stack using only one queue?</p>\n"}}, "226": {"__typename": "QuestionLightNode", "acRate": 0.8030705855126128, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "226", "isFavor": false, "solutionNum": 4842, "title": "Invert Binary Tree", "titleCn": "翻转二叉树", "titleSlug": "invert-binary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 82, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg\" style=\"height: 165px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [4,2,7,1,3,6,9]\n<strong>输出：</strong>[4,7,2,9,6,3,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg\" style=\"width: 500px; height: 120px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,3]\n<strong>输出：</strong>[2,3,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目范围在 <code>[0, 100]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg\" style=\"width: 500px; height: 165px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3,6,9]\n<strong>Output:</strong> [4,7,2,9,6,3,1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg\" style=\"width: 500px; height: 120px;\" />\n<pre>\n<strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> [2,3,1]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n"}}, "227": {"__typename": "QuestionLightNode", "acRate": 0.4483668702983522, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "227", "isFavor": false, "solutionNum": 1161, "title": "Basic Calculator II", "titleCn": "基本计算器 II", "titleSlug": "basic-calculator-ii", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 80, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>\n\n<p>整数除法仅保留整数部分。</p>\n\n<p>你可以假设给定的表达式总是有效的。所有中间结果将在&nbsp;<code>[-2<sup>31</sup>, 2<sup>31</sup>&nbsp;- 1]</code> 的范围内。</p>\n\n<p><strong>注意：</strong>不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"3+2*2\"\n<strong>输出：</strong>7\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \" 3/2 \"\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \" 3+5 / 2 \"\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由整数和算符 <code>('+', '-', '*', '/')</code> 组成，中间由一些空格隔开</li>\n\t<li><code>s</code> 表示一个 <strong>有效表达式</strong></li>\n\t<li>表达式中的所有整数都是非负整数，且在范围 <code>[0, 2<sup>31</sup> - 1]</code> 内</li>\n\t<li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li>\n</ul>\n", "en": "<p>Given a string <code>s</code> which represents an expression, <em>evaluate this expression and return its value</em>.&nbsp;</p>\n\n<p>The integer division should truncate toward zero.</p>\n\n<p>You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>.</p>\n\n<p><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"3+2*2\"\n<strong>Output:</strong> 7\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \" 3/2 \"\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> s = \" 3+5 / 2 \"\n<strong>Output:</strong> 5\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of integers and operators <code>(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)</code> separated by some number of spaces.</li>\n\t<li><code>s</code> represents <strong>a valid expression</strong>.</li>\n\t<li>All the integers in the expression are non-negative integers in the range <code>[0, 2<sup>31</sup> - 1]</code>.</li>\n\t<li>The answer is <strong>guaranteed</strong> to fit in a <strong>32-bit integer</strong>.</li>\n</ul>\n"}}, "228": {"__typename": "QuestionLightNode", "acRate": 0.5471174756015466, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "228", "isFavor": false, "solutionNum": 1451, "title": "Summary Ranges", "titleCn": "汇总区间", "titleSlug": "summary-ranges", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 33, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1711090840-jlSkmv-capital one.png", "slug": "capital-one", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个 &nbsp;<strong>无重复元素</strong> 的&nbsp;<strong>有序</strong> 整数数组 <code>nums</code> 。</p>\n\n<p>返回 <em><strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表&nbsp;</em>。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p>\n\n<p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p>\n\n<ul>\n\t<li><code>\"a-&gt;b\"</code> ，如果 <code>a != b</code></li>\n\t<li><code>\"a\"</code> ，如果 <code>a == b</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,2,4,5,7]\n<strong>输出：</strong>[\"0-&gt;2\",\"4-&gt;5\",\"7\"]\n<strong>解释：</strong>区间范围是：\n[0,2] --&gt; \"0-&gt;2\"\n[4,5] --&gt; \"4-&gt;5\"\n[7,7] --&gt; \"7\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,2,3,4,6,8,9]\n<strong>输出：</strong>[\"0\",\"2-&gt;4\",\"6\",\"8-&gt;9\"]\n<strong>解释：</strong>区间范围是：\n[0,0] --&gt; \"0\"\n[2,4] --&gt; \"2-&gt;4\"\n[6,6] --&gt; \"6\"\n[8,9] --&gt; \"8-&gt;9\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>nums</code> 中的所有值都 <strong>互不相同</strong></li>\n\t<li><code>nums</code> 按升序排列</li>\n</ul>\n", "en": "<p>You are given a <strong>sorted unique</strong> integer array <code>nums</code>.</p>\n\n<p>A <strong>range</strong> <code>[a,b]</code> is the set of all integers from <code>a</code> to <code>b</code> (inclusive).</p>\n\n<p>Return <em>the <strong>smallest sorted</strong> list of ranges that <strong>cover all the numbers in the array exactly</strong></em>. That is, each element of <code>nums</code> is covered by exactly one of the ranges, and there is no integer <code>x</code> such that <code>x</code> is in one of the ranges but not in <code>nums</code>.</p>\n\n<p>Each range <code>[a,b]</code> in the list should be output as:</p>\n\n<ul>\n\t<li><code>&quot;a-&gt;b&quot;</code> if <code>a != b</code></li>\n\t<li><code>&quot;a&quot;</code> if <code>a == b</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,2,4,5,7]\n<strong>Output:</strong> [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]\n<strong>Explanation:</strong> The ranges are:\n[0,2] --&gt; &quot;0-&gt;2&quot;\n[4,5] --&gt; &quot;4-&gt;5&quot;\n[7,7] --&gt; &quot;7&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,2,3,4,6,8,9]\n<strong>Output:</strong> [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]\n<strong>Explanation:</strong> The ranges are:\n[0,0] --&gt; &quot;0&quot;\n[2,4] --&gt; &quot;2-&gt;4&quot;\n[6,6] --&gt; &quot;6&quot;\n[8,9] --&gt; &quot;8-&gt;9&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>All the values of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted in ascending order.</li>\n</ul>\n"}}, "229": {"__typename": "QuestionLightNode", "acRate": 0.5431964556754317, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "229", "isFavor": false, "solutionNum": 898, "title": "Majority Element II", "titleCn": "多数元素 II", "titleSlug": "majority-element-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "pxpqcm", "name": "Counting", "slug": "counting", "nameTranslated": "计数", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 35, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个大小为&nbsp;<em>n&nbsp;</em>的整数数组，找出其中所有出现超过&nbsp;<code>⌊ n/3 ⌋</code>&nbsp;次的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,2,3]\n<strong>输出：</strong>[3]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2]\n<strong>输出：</strong>[1,2]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。</p>\n", "en": "<p>Given an integer array of size <code>n</code>, find all elements that appear more than <code>&lfloor; n/3 &rfloor;</code> times.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,3]\n<strong>Output:</strong> [3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2]\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve the problem in linear time and in <code>O(1)</code> space?</p>\n"}}, "230": {"__typename": "QuestionLightNode", "acRate": 0.7706447908121411, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "230", "isFavor": false, "solutionNum": 2168, "title": "Kth Smallest Element in a BST", "titleCn": "二叉搜索树中第K小的元素", "titleSlug": "kth-smallest-element-in-a-bst", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 48, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code><strong> </strong>个最小元素（从 1 开始计数）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg\" style=\"width: 212px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [3,1,4,null,2], k = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg\" style=\"width: 382px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [5,3,6,2,4,null,null,1], k = 3\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数为 <code>n</code> 。</li>\n\t<li><code>1 <= k <= n <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= Node.val <= 10<sup>4</sup></code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>\n", "en": "<p>Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest value (<strong>1-indexed</strong>) of all the values of the nodes in the tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg\" style=\"width: 212px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [3,1,4,null,2], k = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg\" style=\"width: 382px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [5,3,6,2,4,null,null,1], k = 3\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is <code>n</code>.</li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?</p>\n"}}, "231": {"__typename": "QuestionLightNode", "acRate": 0.4978918737657886, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "231", "isFavor": false, "solutionNum": 2347, "title": "Power of Two", "titleCn": "2 的幂", "titleSlug": "power-of-two", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 49, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数 <code>n</code>，请你判断该整数是否是 2 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>如果存在一个整数 <code>x</code> 使得&nbsp;<code>n == 2<sup>x</sup></code> ，则认为 <code>n</code> 是 2 的幂次方。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>2<sup>0</sup> = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 16\n<strong>输出：</strong>true\n<strong>解释：</strong>2<sup>4</sup> = 16\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能够不使用循环/递归解决此问题吗？</p>\n", "en": "<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of two. Otherwise, return <code>false</code></em>.</p>\n\n<p>An integer <code>n</code> is a power of two, if there exists an integer <code>x</code> such that <code>n == 2<sup>x</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n<strong>Explanation: </strong>2<sup>0</sup> = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 16\n<strong>Output:</strong> true\n<strong>Explanation: </strong>2<sup>4</sup> = 16\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without loops/recursion?"}}, "232": {"__typename": "QuestionLightNode", "acRate": 0.6814523957516552, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "232", "isFavor": false, "solutionNum": 2716, "title": "Implement Queue using Stacks", "titleCn": "用栈实现队列", "titleSlug": "implement-queue-using-stacks", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "vxfk6", "name": "Queue", "slug": "queue", "nameTranslated": "队列", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 73, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>\n\n<p>实现 <code>MyQueue</code> 类：</p>\n\n<ul>\n\t<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>\n\t<li><code>int pop()</code> 从队列的开头移除并返回元素</li>\n\t<li><code>int peek()</code> 返回队列开头的元素</li>\n\t<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>\n</ul>\n\n<p><strong>说明：</strong></p>\n\n<ul>\n\t<li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有&nbsp;<code>push to top</code>,&nbsp;<code>peek/pop from top</code>,&nbsp;<code>size</code>, 和&nbsp;<code>is empty</code>&nbsp;操作是合法的。</li>\n\t<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n<strong>输出：</strong>\n[null, null, null, 1, 1, false]\n\n<strong>解释：</strong>\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n</pre>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= 9</code></li>\n\t<li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li>\n\t<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li>\n</ul>\n", "en": "<p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>peek</code>, <code>pop</code>, and <code>empty</code>).</p>\n\n<p>Implement the <code>MyQueue</code> class:</p>\n\n<ul>\n\t<li><code>void push(int x)</code> Pushes element x to the back of the queue.</li>\n\t<li><code>int pop()</code> Removes the element from the front of the queue and returns it.</li>\n\t<li><code>int peek()</code> Returns the element at the front of the queue.</li>\n\t<li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code> otherwise.</li>\n</ul>\n\n<p><strong>Notes:</strong></p>\n\n<ul>\n\t<li>You must use <strong>only</strong> standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>\n\t<li>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack&#39;s standard operations.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]\n[[], [1], [2], [], [], []]\n<strong>Output</strong>\n[null, null, null, 1, 1, false]\n\n<strong>Explanation</strong>\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x &lt;= 9</code></li>\n\t<li>At most <code>100</code>&nbsp;calls will be made to <code>push</code>, <code>pop</code>, <code>peek</code>, and <code>empty</code>.</li>\n\t<li>All the calls to <code>pop</code> and <code>peek</code> are valid.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you implement the queue such that each operation is <strong><a href=\"https://en.wikipedia.org/wiki/Amortized_analysis\" target=\"_blank\">amortized</a></strong> <code>O(1)</code> time complexity? In other words, performing <code>n</code> operations will take overall <code>O(n)</code> time even if one of those operations may take longer.</p>\n"}}, "233": {"__typename": "QuestionLightNode", "acRate": 0.49346173892073963, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "233", "isFavor": false, "solutionNum": 681, "title": "Number of Digit One", "titleCn": "数字 1 的个数", "titleSlug": "number-of-digit-one", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 44, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个整数 <code>n</code>，计算所有小于等于 <code>n</code> 的非负整数中数字 <code>1</code> 出现的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 13\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 0\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Given an integer <code>n</code>, count <em>the total number of digit </em><code>1</code><em> appearing in all non-negative integers less than or equal to</em> <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 13\n<strong>Output:</strong> 6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "234": {"__typename": "QuestionLightNode", "acRate": 0.5432234013715171, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "234", "isFavor": false, "solutionNum": 4036, "title": "Palindrome Linked List", "titleCn": "回文链表", "titleSlug": "palindrome-linked-list", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 95, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为<span data-keyword=\"palindrome-sequence\">回文链表</span>。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg\" style=\"width: 422px; height: 62px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2,2,1]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg\" style=\"width: 182px; height: 62px;\" />\n<pre>\n<strong>输入：</strong>head = [1,2]\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点数目在范围<code>[1, 10<sup>5</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能否用&nbsp;<code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p>\n", "en": "<p>Given the <code>head</code> of a singly linked list, return <code>true</code><em> if it is a </em><span data-keyword=\"palindrome-sequence\"><em>palindrome</em></span><em> or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg\" style=\"width: 422px; height: 62px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,2,1]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg\" style=\"width: 182px; height: 62px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you do it in <code>O(n)</code> time and <code>O(1)</code> space?"}}, "235": {"__typename": "QuestionLightNode", "acRate": 0.7012433126114564, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "235", "isFavor": false, "solutionNum": 2159, "title": "Lowest Common Ancestor of a Binary Search Tree", "titleCn": "二叉搜索树的最近公共祖先", "titleSlug": "lowest-common-ancestor-of-a-binary-search-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 72, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>\n\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\" target=\"_blank\">百度百科</a>中最近公共祖先的定义为：&ldquo;对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。&rdquo;</p>\n\n<p>例如，给定如下二叉搜索树:&nbsp; root =&nbsp;[6,2,8,0,4,7,9,null,null,3,5]</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png\" style=\"height: 190px; width: 200px;\"></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n<strong>输出:</strong> 6 \n<strong>解释: </strong>节点 <code>2 </code>和节点 <code>8 </code>的最近公共祖先是 <code>6。</code>\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre><strong>输入:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n<strong>输出:</strong> 2\n<strong>解释: </strong>节点 <code>2</code> 和节点 <code>4</code> 的最近公共祖先是 <code>2</code>, 因为根据定义最近公共祖先节点可以为节点本身。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li>所有节点的值都是唯一的。</li>\n\t<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>\n</ul>\n", "en": "<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.</p>\n\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: &ldquo;The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).&rdquo;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The LCA of nodes 2 and 8 is 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [2,1], p = 2, q = 1\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>\n\t<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n\t<li>All <code>Node.val</code> are <strong>unique</strong>.</li>\n\t<li><code>p != q</code></li>\n\t<li><code>p</code> and <code>q</code> will exist in the BST.</li>\n</ul>\n"}}, "236": {"__typename": "QuestionLightNode", "acRate": 0.7101258702062501, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "236", "isFavor": false, "solutionNum": 3340, "title": "Lowest Common Ancestor of a Binary Tree", "titleCn": "二叉树的最近公共祖先", "titleSlug": "lowest-common-ancestor-of-a-binary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 111, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\" target=\"_blank\">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>节点 <code>5 </code>和节点 <code>1 </code>的最近公共祖先是节点 <code>3 。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>输出：</strong>5\n<strong>解释：</strong>节点 <code>5 </code>和节点 <code>4 </code>的最近公共祖先是节点 <code>5 。</code>因为根据定义最近公共祖先节点可以为节点本身。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2], p = 1, q = 2\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[2, 10<sup>5</sup>]</code> 内。</li>\n\t<li><code>-10<sup>9</sup> <= Node.val <= 10<sup>9</sup></code></li>\n\t<li>所有 <code>Node.val</code> <code>互不相同</code> 。</li>\n\t<li><code>p != q</code></li>\n\t<li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>\n</ul>\n", "en": "<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>\n\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: &ldquo;The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <b>a node to be a descendant of itself</b>).&rdquo;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,2], p = 1, q = 2\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>\n\t<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n\t<li>All <code>Node.val</code> are <strong>unique</strong>.</li>\n\t<li><code>p != q</code></li>\n\t<li><code>p</code> and <code>q</code> will exist in the tree.</li>\n</ul>\n"}}, "237": {"__typename": "QuestionLightNode", "acRate": 0.8632214228803877, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "237", "isFavor": false, "solutionNum": 1844, "title": "Delete Node in a Linked List", "titleCn": "删除链表中的节点", "titleSlug": "delete-node-in-a-linked-list", "topicTags": [{"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 70, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>有一个单链表的&nbsp;<code>head</code>，我们想删除它其中的一个节点&nbsp;<code>node</code>。</p>\n\n<p>给你一个需要删除的节点&nbsp;<code>node</code>&nbsp;。你将&nbsp;<strong>无法访问</strong>&nbsp;第一个节点&nbsp;&nbsp;<code>head</code>。</p>\n\n<p>链表的所有值都是 <b>唯一的</b>，并且保证给定的节点&nbsp;<code>node</code>&nbsp;不是链表中的最后一个节点。</p>\n\n<p>删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：</p>\n\n<ul>\n\t<li>给定节点的值不应该存在于链表中。</li>\n\t<li>链表中的节点数应该减少 1。</li>\n\t<li><code>node</code>&nbsp;前面的所有值顺序相同。</li>\n\t<li><code>node</code>&nbsp;后面的所有值顺序相同。</li>\n</ul>\n\n<p><strong>自定义测试：</strong></p>\n\n<ul>\n\t<li>对于输入，你应该提供整个链表&nbsp;<code>head</code>&nbsp;和要给出的节点&nbsp;<code>node</code>。<code>node</code>&nbsp;不应该是链表的最后一个节点，而应该是链表中的一个实际节点。</li>\n\t<li>我们将构建链表，并将节点传递给你的函数。</li>\n\t<li>输出将是调用你函数后的整个链表。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node1.jpg\" style=\"height: 286px; width: 400px;\" />\n<pre>\n<strong>输入：</strong>head = [4,5,1,9], node = 5\n<strong>输出：</strong>[4,1,9]\n<strong>解释：</strong>指定链表中值为&nbsp;5&nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node2.jpg\" style=\"height: 315px; width: 400px;\" />\n<pre>\n<strong>输入：</strong>head = [4,5,1,9], node = 1\n<strong>输出：</strong>[4,5,9]\n<strong>解释：</strong>指定链表中值为&nbsp;1&nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中节点的数目范围是 <code>[2, 1000]</code></li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>链表中每个节点的值都是 <strong>唯一</strong> 的</li>\n\t<li>需要删除的节点 <code>node</code> 是 <strong>链表中的节点</strong> ，且 <strong>不是末尾节点</strong></li>\n</ul>\n", "en": "<p>There is a singly-linked list <code>head</code> and we want to delete a node <code>node</code> in it.</p>\n\n<p>You are given the node to be deleted <code>node</code>. You will <strong>not be given access</strong> to the first node of <code>head</code>.</p>\n\n<p>All the values of the linked list are <strong>unique</strong>, and it is guaranteed that the given node <code>node</code> is not the last node in the linked list.</p>\n\n<p>Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:</p>\n\n<ul>\n\t<li>The value of the given node should not exist in the linked list.</li>\n\t<li>The number of nodes in the linked list should decrease by one.</li>\n\t<li>All the values before <code>node</code> should be in the same order.</li>\n\t<li>All the values after <code>node</code> should be in the same order.</li>\n</ul>\n\n<p><strong>Custom testing:</strong></p>\n\n<ul>\n\t<li>For the input, you should provide the entire linked list <code>head</code> and the node to be given <code>node</code>. <code>node</code> should not be the last node of the list and should be an actual node in the list.</li>\n\t<li>We will build the linked list and pass the node to your function.</li>\n\t<li>The output will be the entire list after calling your function.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node1.jpg\" style=\"width: 400px; height: 286px;\" />\n<pre>\n<strong>Input:</strong> head = [4,5,1,9], node = 5\n<strong>Output:</strong> [4,1,9]\n<strong>Explanation: </strong>You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/node2.jpg\" style=\"width: 400px; height: 315px;\" />\n<pre>\n<strong>Input:</strong> head = [4,5,1,9], node = 1\n<strong>Output:</strong> [4,5,9]\n<strong>Explanation: </strong>You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the given list is in the range <code>[2, 1000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>The value of each node in the list is <strong>unique</strong>.</li>\n\t<li>The <code>node</code> to be deleted is <strong>in the list</strong> and is <strong>not a tail</strong> node.</li>\n</ul>\n"}}, "238": {"__typename": "QuestionLightNode", "acRate": 0.7542104569623453, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "238", "isFavor": false, "solutionNum": 2325, "title": "Product of Array Except Self", "titleCn": "除自身以外数组的乘积", "titleSlug": "product-of-array-except-self", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 96, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组&nbsp;<code>nums</code>，返回 <em>数组&nbsp;<code>answer</code>&nbsp;，其中&nbsp;<code>answer[i]</code>&nbsp;等于&nbsp;<code>nums</code>&nbsp;中除&nbsp;<code>nums[i]</code>&nbsp;之外其余各元素的乘积</em>&nbsp;。</p>\n\n<p>题目数据 <strong>保证</strong> 数组&nbsp;<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在&nbsp; <strong>32 位</strong> 整数范围内。</p>\n\n<p>请&nbsp;<strong>不要使用除法，</strong>且在&nbsp;<code>O(<em>n</em>)</code> 时间复杂度内完成此题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = <code>[1,2,3,4]</code>\n<strong>输出:</strong> <code>[24,12,8,6]</code>\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [-1,1,0,-3,3]\n<strong>输出:</strong> [0,0,9,0,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>\n\t<li><strong>保证</strong> 数组&nbsp;<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在&nbsp; <strong>32 位</strong> 整数范围内</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以在 <code>O(1)</code>&nbsp;的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组&nbsp;<strong>不被视为&nbsp;</strong>额外空间。）</p>\n", "en": "<p>Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.</p>\n\n<p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time and without using the division operation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> [24,12,8,6]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [-1,1,0,-3,3]\n<strong>Output:</strong> [0,0,9,0,0]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>\n\t<li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong>&nbsp;Can you solve the problem in <code>O(1)</code>&nbsp;extra&nbsp;space complexity? (The output array <strong>does not</strong> count as extra space for space complexity analysis.)</p>\n"}}, "239": {"__typename": "QuestionLightNode", "acRate": 0.48927057788566636, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "239", "isFavor": false, "solutionNum": 3936, "title": "Sliding Window Maximum", "titleCn": "滑动窗口最大值", "titleSlug": "sliding-window-maximum", "topicTags": [{"id": "vxfk6", "name": "Queue", "slug": "queue", "nameTranslated": "队列", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}, {"id": "xeybop7", "name": "Monotonic Queue", "slug": "monotonic-queue", "nameTranslated": "单调队列", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 111, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code>，有一个大小为&nbsp;<code>k</code><em>&nbsp;</em>的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code>&nbsp;个数字。滑动窗口每次只向右移动一位。</p>\n\n<p>返回 <em>滑动窗口中的最大值 </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,3,-1,-3,5,3,6,7], k = 3\n<b>输出：</b>[3,3,5,5,6,7]\n<b>解释：</b>\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1], k = 1\n<b>输出：</b>[1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n", "en": "<p>You are given an array of integers&nbsp;<code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>Return <em>the max sliding window</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3\n<strong>Output:</strong> [3,3,5,5,6,7]\n<strong>Explanation:</strong> \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n"}}, "240": {"__typename": "QuestionLightNode", "acRate": 0.5364665957386174, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "240", "isFavor": false, "solutionNum": 2009, "title": "Search a 2D Matrix II", "titleCn": "搜索二维矩阵 II", "titleSlug": "search-a-2d-matrix-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 80, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>编写一个高效的算法来搜索&nbsp;<code><em>m</em>&nbsp;x&nbsp;<em>n</em></code>&nbsp;矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>\n\n<ul>\n\t<li>每行的元素从左到右升序排列。</li>\n\t<li>每列的元素从上到下升序排列。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>示例 1：</b></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg\" />\n<pre>\n<b>输入：</b>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n<b>输出：</b>true\n</pre>\n\n<p><b>示例 2：</b></p>\n<img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg\" />\n<pre>\n<b>输入：</b>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n<b>输出：</b>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 300</code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>\n\t<li>每行的所有元素从左到右升序排列</li>\n\t<li>每列的所有元素从上到下升序排列</li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:</p>\n\n<ul>\n\t<li>Integers in each row are sorted in ascending from left to right.</li>\n\t<li>Integers in each column are sorted in ascending from top to bottom.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 300</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>\n\t<li>All the integers in each row are <strong>sorted</strong> in ascending order.</li>\n\t<li>All the integers in each column are <strong>sorted</strong> in ascending order.</li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "241": {"__typename": "QuestionLightNode", "acRate": 0.7555669472623929, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "241", "isFavor": false, "solutionNum": 809, "title": "Different Ways to Add Parentheses", "titleCn": "为运算表达式设计优先级", "titleSlug": "different-ways-to-add-parentheses", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "vhos7", "name": "Memoization", "slug": "memoization", "nameTranslated": "记忆化搜索", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 34, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个由数字和运算符组成的字符串&nbsp;<code>expression</code> ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 <strong>按任意顺序</strong> 返回答案。</p>\n\n<p>生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 <code>10<sup>4</sup></code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"2-1-1\"\n<strong>输出：</strong>[0,2]\n<strong>解释：</strong>\n((2-1)-1) = 0 \n(2-(1-1)) = 2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>expression = \"2*3-4*5\"\n<strong>输出：</strong>[-34,-14,-10,-10,10]\n<strong>解释：</strong>\n(2*(3-(4*5))) = -34 \n((2*3)-(4*5)) = -14 \n((2*(3-4))*5) = -10 \n(2*((3-4)*5)) = -10 \n(((2*3)-4)*5) = 10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 20</code></li>\n\t<li><code>expression</code> 由数字和算符 <code>'+'</code>、<code>'-'</code> 和 <code>'*'</code> 组成。</li>\n\t<li>输入表达式中的所有整数值在范围 <code>[0, 99]</code>&nbsp;</li>\n</ul>\n", "en": "<p>Given a string <code>expression</code> of numbers and operators, return <em>all possible results from computing all the different possible ways to group numbers and operators</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed <code>10<sup>4</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;2-1-1&quot;\n<strong>Output:</strong> [0,2]\n<strong>Explanation:</strong>\n((2-1)-1) = 0 \n(2-(1-1)) = 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;2*3-4*5&quot;\n<strong>Output:</strong> [-34,-14,-10,-10,10]\n<strong>Explanation:</strong>\n(2*(3-(4*5))) = -34 \n((2*3)-(4*5)) = -14 \n((2*(3-4))*5) = -10 \n(2*((3-4)*5)) = -10 \n(((2*3)-4)*5) = 10\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 20</code></li>\n\t<li><code>expression</code> consists of digits and the operator <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, and <code>&#39;*&#39;</code>.</li>\n\t<li>All the integer values in the input expression are in the range <code>[0, 99]</code>.</li>\n</ul>\n"}}, "242": {"__typename": "QuestionLightNode", "acRate": 0.6643136207183701, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "242", "isFavor": false, "solutionNum": 4163, "title": "Valid Anagram", "titleCn": "有效的字母异位词", "titleSlug": "valid-anagram", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 79, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个字符串 <code><em>s</em></code> 和 <code><em>t</em></code> ，编写一个函数来判断 <code><em>t</em></code> 是否是 <code><em>s</em></code> 的字母异位词。</p>\n\n<p><strong>注意：</strong>若 <code><em>s</em></code> 和 <code><em>t</em></code><em> </em>中每个字符出现的次数都相同，则称 <code><em>s</em></code> 和 <code><em>t</em></code><em> </em>互为字母异位词。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <em>s</em> = \"anagram\", <em>t</em> = \"nagaram\"\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> <em>s</em> = \"rat\", <em>t</em> = \"car\"\n<strong>输出: </strong>false</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length, t.length <= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 和 <code>t</code> 仅包含小写字母</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶: </strong>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>\n", "en": "<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code><em>, and</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"anagram\", t = \"nagaram\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"rat\", t = \"car\"\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if the inputs contain Unicode characters? How would you adapt your solution to such a case?</p>\n"}}, "243": {"__typename": "QuestionLightNode", "acRate": 0.6755341040894975, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "243", "isFavor": false, "solutionNum": 201, "title": "Shortest Word Distance", "titleCn": "最短单词距离", "titleSlug": "shortest-word-distance", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 32, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "244": {"__typename": "QuestionLightNode", "acRate": 0.6067245119305856, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "244", "isFavor": false, "solutionNum": 118, "title": "Shortest Word Distance II", "titleCn": "最短单词距离 II", "titleSlug": "shortest-word-distance-ii", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 21, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "245": {"__typename": "QuestionLightNode", "acRate": 0.5809344030202926, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "245", "isFavor": false, "solutionNum": 103, "title": "Shortest Word Distance III", "titleCn": "最短单词距离 III", "titleSlug": "shortest-word-distance-iii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 13, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "246": {"__typename": "QuestionLightNode", "acRate": 0.4736097639831878, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "246", "isFavor": false, "solutionNum": 186, "title": "Strobogrammatic Number", "titleCn": "中心对称数", "titleSlug": "strobogrammatic-number", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 14, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "247": {"__typename": "QuestionLightNode", "acRate": 0.5475460977104339, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "247", "isFavor": false, "solutionNum": 145, "title": "Strobogrammatic Number II", "titleCn": "中心对称数 II", "titleSlug": "strobogrammatic-number-ii", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 13, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "248": {"__typename": "QuestionLightNode", "acRate": 0.4887952302631579, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "248", "isFavor": false, "solutionNum": 89, "title": "Strobogrammatic Number III", "titleCn": "中心对称数 III", "titleSlug": "strobogrammatic-number-iii", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 8, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "249": {"__typename": "QuestionLightNode", "acRate": 0.655247417074497, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "249", "isFavor": false, "solutionNum": 202, "title": "Group Shifted Strings", "titleCn": "移位字符串分组", "titleSlug": "group-shifted-strings", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "250": {"__typename": "QuestionLightNode", "acRate": 0.647486140317339, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "250", "isFavor": false, "solutionNum": 178, "title": "Count Univalue Subtrees", "titleCn": "统计同值子树", "titleSlug": "count-univalue-subtrees", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "251": {"__typename": "QuestionLightNode", "acRate": 0.5547380002750654, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "251", "isFavor": false, "solutionNum": 117, "title": "Flatten 2D Vector", "titleCn": "展开二维向量", "titleSlug": "flatten-2d-vector", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "7eks9i", "name": "Iterator", "slug": "iterator", "nameTranslated": "迭代器", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 28, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/99a45f957529ef9ac7be507962ccee294f53b3cd87dc8163d18f16c1228e4a70-belo-cn-200x200-9518747d43e25d1834cda4cbe55464c5.png", "slug": "airbnb", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "252": {"__typename": "QuestionLightNode", "acRate": 0.5837559125580603, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "252", "isFavor": false, "solutionNum": 259, "title": "Meeting Rooms", "titleCn": "会议室", "titleSlug": "meeting-rooms", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 47, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "253": {"__typename": "QuestionLightNode", "acRate": 0.5249499234122776, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "253", "isFavor": false, "solutionNum": 631, "title": "Meeting Rooms II", "titleCn": "会议室 II", "titleSlug": "meeting-rooms-ii", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 85, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "254": {"__typename": "QuestionLightNode", "acRate": 0.5704571759259259, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "254", "isFavor": false, "solutionNum": 150, "title": "Factor Combinations", "titleCn": "因子的组合", "titleSlug": "factor-combinations", "topicTags": [{"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 16, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "255": {"__typename": "QuestionLightNode", "acRate": 0.4981872188005067, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "255", "isFavor": false, "solutionNum": 128, "title": "Verify Preorder Sequence in Binary Search Tree", "titleCn": "验证二叉搜索树的前序遍历序列", "titleSlug": "verify-preorder-sequence-in-binary-search-tree", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}, {"id": "xeyj5r5", "name": "Monotonic Stack", "slug": "monotonic-stack", "nameTranslated": "单调栈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 24, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/e180e3e5553f722e5895940d0617f54e988e54e1e530b27e88e76576aedc553d-qw90wxxo_400x400.jpg", "slug": "mathworks", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/36f2173378942edb8233acb9ad28bca6360748797ada8eb545dbd100dbda3dd6-VMware-Logo-200x200-01-1024x1024.png", "slug": "vmware", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "256": {"__typename": "QuestionLightNode", "acRate": 0.7096519218946691, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "256", "isFavor": false, "solutionNum": 334, "title": "Paint House", "titleCn": "粉刷房子", "titleSlug": "paint-house", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 35, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937282-qSKaPF-Unknown-4.jpeg", "slug": "twitter", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1598249949-DcnvwI-2295e083cb0eda207cc56e4ba6aadf55.jpg", "slug": "roblox", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "257": {"__typename": "QuestionLightNode", "acRate": 0.7069459725255577, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "257", "isFavor": false, "solutionNum": 2279, "title": "Binary Tree Paths", "titleCn": "二叉树的所有路径", "titleSlug": "binary-tree-paths", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 51, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>\n\n<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg\" style=\"width: 207px; height: 293px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,5]\n<strong>输出：</strong>[\"1-&gt;2-&gt;5\",\"1-&gt;3\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[\"1\"]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 100]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree, return <em>all root-to-leaf paths in <strong>any order</strong></em>.</p>\n\n<p>A <strong>leaf</strong> is a node with no children.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg\" style=\"width: 207px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,5]\n<strong>Output:</strong> [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [&quot;1&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n"}}, "258": {"__typename": "QuestionLightNode", "acRate": 0.7055342296353819, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "258", "isFavor": false, "solutionNum": 1554, "title": "Add Digits", "titleCn": "各位相加", "titleSlug": "add-digits", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "3vubuc", "name": "Number Theory", "slug": "number-theory", "nameTranslated": "数论", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 46, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> num =<strong> </strong><code>38</code>\n<strong>输出:</strong> 2 \n<strong>解释: </strong>各位相加的过程为<strong>：\n</strong>38 --&gt; 3 + 8 --&gt; 11\n11 --&gt; 1 + 1 --&gt; 2\n由于&nbsp;<code>2</code> 是一位数，所以返回 2。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> num =<strong> </strong>0\n<strong>输出:</strong> 0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以不使用循环或者递归，在 <code>O(1)</code> 时间复杂度内解决这个问题吗？</p>\n", "en": "<p>Given an integer <code>num</code>, repeatedly add all its digits until the result has only one digit, and return it.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 38\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The process is\n38 --&gt; 3 + 8 --&gt; 11\n11 --&gt; 1 + 1 --&gt; 2 \nSince 2 has only one digit, return it.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you do it without any loop/recursion in <code>O(1)</code> runtime?</p>\n"}}, "259": {"__typename": "QuestionLightNode", "acRate": 0.5496875, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "259", "isFavor": false, "solutionNum": 149, "title": "3Sum Smaller", "titleCn": "较小的三数之和", "titleSlug": "3sum-smaller", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 26, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/f7ac685c68bf4a0b569f37cff857f5acaf4054d4386c0f365bee7c29f1500719-IBM.png", "slug": "ibm", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1675928747-DuwjgM-Citadel.png", "slug": "citadel", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "260": {"__typename": "QuestionLightNode", "acRate": 0.7190347580464616, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "260", "isFavor": false, "solutionNum": 1144, "title": "Single Number III", "titleCn": "只出现一次的数字 III", "titleSlug": "single-number-iii", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 47, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组&nbsp;<code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,3,2,5]\n<strong>输出：</strong>[3,5]\n<strong>解释：</strong>[5, 3] 也是有效的答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,0]\n<strong>输出：</strong>[-1,0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>[1,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>除两个只出现一次的整数外，<code>nums</code> 中的其他数字都出现两次</li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in <strong>any order</strong>.</p>\n\n<p>You must write an&nbsp;algorithm that runs in linear runtime complexity and uses&nbsp;only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,3,2,5]\n<strong>Output:</strong> [3,5]\n<strong>Explanation: </strong> [5, 3] is also a valid answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0]\n<strong>Output:</strong> [-1,0]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1]\n<strong>Output:</strong> [1,0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>Each integer in <code>nums</code> will appear twice, only two integers will appear once.</li>\n</ul>\n"}}, "261": {"__typename": "QuestionLightNode", "acRate": 0.5139114541023558, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "261", "isFavor": false, "solutionNum": 254, "title": "Graph Valid Tree", "titleCn": "以图判树", "titleSlug": "graph-valid-tree", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "n6a2i", "name": "Union Find", "slug": "union-find", "nameTranslated": "并查集", "__typename": "CommonTagNode"}, {"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 36, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "262": {"__typename": "QuestionLightNode", "acRate": 0.4097281404465655, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "262", "isFavor": false, "solutionNum": 735, "title": "Trips and Users", "titleCn": "行程和用户", "titleSlug": "trips-and-users", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 27, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "表：<code>Trips</code>\n<div class=\"original__bRMd\">\n<div>\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| id          | int      |\n| client_id   | int      |\n| driver_id   | int      |\n| city_id     | int      |\n| status      | enum     |\n| request_at  | date     |     \n+-------------+----------+\nid 是这张表的主键（具有唯一值的列）。\n这张表中存所有出租车的行程信息。每段行程有唯一 id ，其中 client_id 和 driver_id 是 Users 表中 users_id 的外键。\nstatus 是一个表示行程状态的枚举类型，枚举成员为(‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>表：<code>Users</code></p>\n</div>\n</div>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| users_id    | int      |\n| banned      | enum     |\n| role        | enum     |\n+-------------+----------+\nusers_id 是这张表的主键（具有唯一值的列）。\n这张表中存所有用户，每个用户都有一个唯一的 users_id ，role 是一个表示用户身份的枚举类型，枚举成员为 (‘client’, ‘driver’, ‘partner’) 。\nbanned 是一个表示用户是否被禁止的枚举类型，枚举成员为 (‘Yes’, ‘No’) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>取消率</strong> 的计算方式如下：(被司机或乘客取消的非禁止用户生成的订单数量) / (非禁止用户生成的订单总数)。</p>\n\n<p>编写解决方案找出&nbsp;<code>\"2013-10-01\"</code><strong>&nbsp;</strong>至&nbsp;<code>\"2013-10-03\"</code><strong>&nbsp;</strong>期间非禁止用户（<strong>乘客和司机都必须未被禁止</strong>）的取消率。非禁止用户即 banned 为 No 的用户，禁止用户即 banned 为 Yes 的用户。其中取消率 <code>Cancellation Rate</code> 需要四舍五入保留 <strong>两位小数</strong> 。</p>\n\n<p>返回结果表中的数据 <strong>无顺序要求</strong> 。</p>\n\n<p>结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong> \nTrips 表：\n+----+-----------+-----------+---------+---------------------+------------+\n| id | client_id | driver_id | city_id | status              | request_at |\n+----+-----------+-----------+---------+---------------------+------------+\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\n+----+-----------+-----------+---------+---------------------+------------+\nUsers 表：\n+----------+--------+--------+\n| users_id | banned | role   |\n+----------+--------+--------+\n| 1        | No     | client |\n| 2        | Yes    | client |\n| 3        | No     | client |\n| 4        | No     | client |\n| 10       | No     | driver |\n| 11       | No     | driver |\n| 12       | No     | driver |\n| 13       | No     | driver |\n+----------+--------+--------+\n<strong>输出：</strong>\n+------------+-------------------+\n| Day        | Cancellation Rate |\n+------------+-------------------+\n| 2013-10-01 | 0.33              |\n| 2013-10-02 | 0.00              |\n| 2013-10-03 | 0.50              |\n+------------+-------------------+\n<strong>解释：</strong>\n2013-10-01：\n  - 共有 4 条请求，其中 2 条取消。\n  - 然而，id=2 的请求是由禁止用户（user_id=2）发出的，所以计算时应当忽略它。\n  - 因此，总共有 3 条非禁止请求参与计算，其中 1 条取消。\n  - 取消率为 (1 / 3) = 0.33\n2013-10-02：\n  - 共有 3 条请求，其中 0 条取消。\n  - 然而，id=6 的请求是由禁止用户发出的，所以计算时应当忽略它。\n  - 因此，总共有 2 条非禁止请求参与计算，其中 0 条取消。\n  - 取消率为 (0 / 2) = 0.00\n2013-10-03：\n  - 共有 3 条请求，其中 1 条取消。\n  - 然而，id=8 的请求是由禁止用户发出的，所以计算时应当忽略它。\n  - 因此，总共有 2 条非禁止请求参与计算，其中 1 条取消。\n  - 取消率为 (1 / 2) = 0.50\n</pre>\n</div>\n</div>\n", "en": "<p>Table: <code>Trips</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| id          | int      |\n| client_id   | int      |\n| driver_id   | int      |\n| city_id     | int      |\n| status      | enum     |\n| request_at  | date     |     \n+-------------+----------+\nid is the primary key (column with unique values) for this table.\nThe table holds all taxi trips. Each trip has a unique id, while client_id and driver_id are foreign keys to the users_id at the Users table.\nStatus is an ENUM (category) type of (&#39;completed&#39;, &#39;cancelled_by_driver&#39;, &#39;cancelled_by_client&#39;).\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Users</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| users_id    | int      |\n| banned      | enum     |\n| role        | enum     |\n+-------------+----------+\nusers_id is the primary key (column with unique values) for this table.\nThe table holds all users. Each user has a unique users_id, and role is an ENUM type of (&#39;client&#39;, &#39;driver&#39;, &#39;partner&#39;).\nbanned is an ENUM (category) type of (&#39;Yes&#39;, &#39;No&#39;).\n</pre>\n\n<p>&nbsp;</p>\n\n<p>The <strong>cancellation rate</strong> is computed by dividing the number of canceled (by client or driver) requests with unbanned users by the total number of requests with unbanned users on that day.</p>\n\n<p>Write a solution to find the <strong>cancellation rate</strong> of requests with unbanned users (<strong>both client and driver must not be banned</strong>) each day between <code>&quot;2013-10-01&quot;</code> and <code>&quot;2013-10-03&quot;</code>. Round <code>Cancellation Rate</code> to <strong>two decimal</strong> points.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nTrips table:\n+----+-----------+-----------+---------+---------------------+------------+\n| id | client_id | driver_id | city_id | status              | request_at |\n+----+-----------+-----------+---------+---------------------+------------+\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\n+----+-----------+-----------+---------+---------------------+------------+\nUsers table:\n+----------+--------+--------+\n| users_id | banned | role   |\n+----------+--------+--------+\n| 1        | No     | client |\n| 2        | Yes    | client |\n| 3        | No     | client |\n| 4        | No     | client |\n| 10       | No     | driver |\n| 11       | No     | driver |\n| 12       | No     | driver |\n| 13       | No     | driver |\n+----------+--------+--------+\n<strong>Output:</strong> \n+------------+-------------------+\n| Day        | Cancellation Rate |\n+------------+-------------------+\n| 2013-10-01 | 0.33              |\n| 2013-10-02 | 0.00              |\n| 2013-10-03 | 0.50              |\n+------------+-------------------+\n<strong>Explanation:</strong> \nOn 2013-10-01:\n  - There were 4 requests in total, 2 of which were canceled.\n  - However, the request with Id=2 was made by a banned client (User_Id=2), so it is ignored in the calculation.\n  - Hence there are 3 unbanned requests in total, 1 of which was canceled.\n  - The Cancellation Rate is (1 / 3) = 0.33\nOn 2013-10-02:\n  - There were 3 requests in total, 0 of which were canceled.\n  - The request with Id=6 was made by a banned client, so it is ignored.\n  - Hence there are 2 unbanned requests in total, 0 of which were canceled.\n  - The Cancellation Rate is (0 / 2) = 0.00\nOn 2013-10-03:\n  - There were 3 requests in total, 1 of which was canceled.\n  - The request with Id=8 was made by a banned client, so it is ignored.\n  - Hence there are 2 unbanned request in total, 1 of which were canceled.\n  - The Cancellation Rate is (1 / 2) = 0.50\n</pre>\n"}}, "263": {"__typename": "QuestionLightNode", "acRate": 0.5021966842923099, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "263", "isFavor": false, "solutionNum": 1248, "title": "Ugly Number", "titleCn": "丑数", "titleSlug": "ugly-number", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 34, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><strong>丑数 </strong>就是只包含质因数&nbsp;<code>2</code>、<code>3</code> 和 <code>5</code>&nbsp;的正整数。</p>\n\n<p>给你一个整数 <code>n</code> ，请你判断 <code>n</code> 是否为 <strong>丑数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6\n<strong>输出：</strong>true\n<strong>解释：</strong>6 = 2 × 3</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n<strong>解释：</strong>1 没有质因数，因此它的全部质因数是 {2, 3, 5} 的空集。习惯上将其视作第一个丑数。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 14\n<strong>输出：</strong>false\n<strong>解释：</strong>14 不是丑数，因为它包含了另外一个质因数&nbsp;<code>7 </code>。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>An <strong>ugly number</strong> is a positive integer whose prime factors are limited to <code>2</code>, <code>3</code>, and <code>5</code>.</p>\n\n<p>Given an integer <code>n</code>, return <code>true</code> <em>if</em> <code>n</code> <em>is an <strong>ugly number</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 6\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 6 = 2 &times; 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 14\n<strong>Output:</strong> false\n<strong>Explanation:</strong> 14 is not ugly since it includes the prime factor 7.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "264": {"__typename": "QuestionLightNode", "acRate": 0.5821980863374866, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "264", "isFavor": false, "solutionNum": 1016, "title": "Ugly Number II", "titleCn": "丑数 II", "titleSlug": "ugly-number-ii", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 43, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p>\n\n<p><strong>丑数 </strong>就是质因子只包含&nbsp;<code>2</code>、<code>3</code> 和&nbsp;<code>5</code>&nbsp;的正整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10\n<strong>输出：</strong>12\n<strong>解释：</strong>[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n<strong>解释：</strong>1 通常被视为丑数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1690</code></li>\n</ul>\n", "en": "<p>An <strong>ugly number</strong> is a positive integer whose prime factors are limited to <code>2</code>, <code>3</code>, and <code>5</code>.</p>\n\n<p>Given an integer <code>n</code>, return <em>the</em> <code>n<sup>th</sup></code> <em><strong>ugly number</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> 12\n<strong>Explanation:</strong> [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1690</code></li>\n</ul>\n"}}, "265": {"__typename": "QuestionLightNode", "acRate": 0.644309609708101, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "265", "isFavor": false, "solutionNum": 280, "title": "Paint House II", "titleCn": "粉刷房子 II", "titleSlug": "paint-house-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "266": {"__typename": "QuestionLightNode", "acRate": 0.7089365715633106, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "266", "isFavor": false, "solutionNum": 209, "title": "Palindrome Permutation", "titleCn": "回文排列", "titleSlug": "palindrome-permutation", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 31, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "267": {"__typename": "QuestionLightNode", "acRate": 0.4666030534351145, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "267", "isFavor": false, "solutionNum": 137, "title": "Palindrome Permutation II", "titleCn": "回文排列 II", "titleSlug": "palindrome-permutation-ii", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 14, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "268": {"__typename": "QuestionLightNode", "acRate": 0.670179388537084, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "268", "isFavor": false, "solutionNum": 2562, "title": "Missing Number", "titleCn": "丢失的数字", "titleSlug": "missing-number", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 81, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个包含 <code>[0, n]</code>&nbsp;中&nbsp;<code>n</code>&nbsp;个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p>\n\n<ul>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,0,1]\n<strong>输出：</strong>2\n<b>解释：</b>n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1]\n<strong>输出：</strong>2\n<b>解释：</b>n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [9,6,4,2,3,5,7,0,1]\n<strong>输出：</strong>8\n<b>解释：</b>n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0]\n<strong>输出：</strong>1\n<b>解释：</b>n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= n</code></li>\n\t<li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</p>\n", "en": "<p>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,0,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [9,6,4,2,3,5,7,0,1]\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= n</code></li>\n\t<li>All the numbers of <code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you implement a solution using only <code>O(1)</code> extra space complexity and <code>O(n)</code> runtime complexity?</p>\n"}}, "269": {"__typename": "QuestionLightNode", "acRate": 0.3728937346757786, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "269", "isFavor": false, "solutionNum": 199, "title": "Alien Dictionary", "titleCn": "火星词典", "titleSlug": "alien-dictionary", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}, {"id": "ns19t", "name": "Topological Sort", "slug": "topological-sort", "nameTranslated": "拓扑排序", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 49, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/99a45f957529ef9ac7be507962ccee294f53b3cd87dc8163d18f16c1228e4a70-belo-cn-200x200-9518747d43e25d1834cda4cbe55464c5.png", "slug": "airbnb", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "270": {"__typename": "QuestionLightNode", "acRate": 0.5350192044956564, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "270", "isFavor": false, "solutionNum": 228, "title": "Closest Binary Search Tree Value", "titleCn": "最接近的二叉搜索树值", "titleSlug": "closest-binary-search-tree-value", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 26, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "271": {"__typename": "QuestionLightNode", "acRate": 0.5865520823496081, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "271", "isFavor": false, "solutionNum": 81, "title": "Encode and Decode Strings", "titleCn": "字符串的编码与解码", "titleSlug": "encode-and-decode-strings", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 26, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "272": {"__typename": "QuestionLightNode", "acRate": 0.6622860107210791, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "272", "isFavor": false, "solutionNum": 142, "title": "Closest Binary Search Tree Value II", "titleCn": "最接近的二叉搜索树值 II", "titleSlug": "closest-binary-search-tree-value-ii", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 19, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "273": {"__typename": "QuestionLightNode", "acRate": 0.3654564917628275, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "273", "isFavor": false, "solutionNum": 451, "title": "Integer to English Words", "titleCn": "整数转换英文表示", "titleSlug": "integer-to-english-words", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 70, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>将非负整数 <code>num</code> 转换为其对应的英文表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 123\n<strong>输出：</strong>\"One Hundred Twenty Three\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 12345\n<strong>输出：</strong>\"Twelve Thousand Three Hundred Forty Five\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 1234567\n<strong>输出：</strong>\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Convert a non-negative integer <code>num</code> to its English words representation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 123\n<strong>Output:</strong> &quot;One Hundred Twenty Three&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 12345\n<strong>Output:</strong> &quot;Twelve Thousand Three Hundred Forty Five&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 1234567\n<strong>Output:</strong> &quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "274": {"__typename": "QuestionLightNode", "acRate": 0.46298492601155766, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "274", "isFavor": false, "solutionNum": 1437, "title": "H-Index", "titleCn": "H 指数", "titleSlug": "h-index", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "pxmt11", "name": "Counting Sort", "slug": "counting-sort", "nameTranslated": "计数排序", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 34, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>citations</code> ，其中 <code>citations[i]</code> 表示研究者的第 <code>i</code> 篇论文被引用的次数。计算并返回该研究者的 <strong><code>h</code><em>&nbsp;</em>指数</strong>。</p>\n\n<p>根据维基百科上&nbsp;<a href=\"https://baike.baidu.com/item/h-index/3991452?fr=aladdin\" target=\"_blank\">h 指数的定义</a>：<code>h</code> 代表“高引用次数” ，一名科研人员的 <code>h</code><strong> 指数 </strong>是指他（她）至少发表了 <code>h</code> 篇论文，并且&nbsp;<strong>至少&nbsp;</strong>有 <code>h</code> 篇论文被引用次数大于等于 <code>h</code> 。如果 <code>h</code><em> </em>有多种可能的值，<strong><code>h</code> 指数 </strong>是其中最大的那个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>citations = [3,0,6,1,5]</code>\n<strong>输出：</strong>3 \n<strong>解释：</strong>给定数组表示研究者总共有 <code>5</code> 篇论文，每篇论文相应的被引用了 <code>3, 0, 6, 1, 5</code> 次。\n&nbsp;    由于研究者有 <code>3 </code>篇论文每篇 <strong>至少 </strong>被引用了 <code>3</code> 次，其余两篇论文每篇被引用 <strong>不多于</strong> <code>3</code> 次，所以她的 <em>h </em>指数是 <code>3</code>。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>citations = [1,3,1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == citations.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>\n</ul>\n", "en": "<p>Given an array of integers <code>citations</code> where <code>citations[i]</code> is the number of citations a researcher received for their <code>i<sup>th</sup></code> paper, return <em>the researcher&#39;s h-index</em>.</p>\n\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/H-index\" target=\"_blank\">definition of h-index on Wikipedia</a>: The h-index is defined as the maximum value of <code>h</code> such that the given researcher has published at least <code>h</code> papers that have each been cited at least <code>h</code> times.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> citations = [3,0,6,1,5]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> citations = [1,3,1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == citations.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>\n</ul>\n"}}, "275": {"__typename": "QuestionLightNode", "acRate": 0.4532907553399659, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "275", "isFavor": false, "solutionNum": 718, "title": "H-Index II", "titleCn": "H 指数 II", "titleSlug": "h-index-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>citations</code> ，其中 <code>citations[i]</code> 表示研究者的第 <code>i</code> 篇论文被引用的次数，<code>citations</code> 已经按照&nbsp;<strong>升序排列&nbsp;</strong>。计算并返回该研究者的 h<strong><em>&nbsp;</em></strong>指数。</p>\n\n<p><a href=\"https://baike.baidu.com/item/h-index/3991452?fr=aladdin\" target=\"_blank\">h 指数的定义</a>：h 代表“高引用次数”（high citations），一名科研人员的 <code>h</code> 指数是指他（她）的 （<code>n</code> 篇论文中）<strong>至少&nbsp;</strong>有 <code>h</code> 篇论文分别被引用了<strong>至少</strong> <code>h</code> 次。</p>\n\n<p>请你设计并实现对数时间复杂度的算法解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>citations = [0,1,3,5,6]</code>\n<strong>输出：</strong><code>3</code>\n<strong>解释：</strong>给定数组表示研究者总共有 <code>5</code> 篇论文，每篇论文相应的被引用了 <code>0, 1, 3, 5, 6</code> 次。\n&nbsp;    由于研究者有<code>3</code>篇论文每篇<strong> 至少 </strong>被引用了 <code>3</code> 次，其余两篇论文每篇被引用<strong> 不多于</strong> <code>3</code> 次，所以她的<em> h </em>指数是 <code>3</code> 。</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>citations = [1,2,100]</code>\n<strong>输出：</strong><code>2</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == citations.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>\n\t<li><code>citations</code> 按 <strong>升序排列</strong></li>\n</ul>\n", "en": "<p>Given an array of integers <code>citations</code> where <code>citations[i]</code> is the number of citations a researcher received for their <code>i<sup>th</sup></code> paper and <code>citations</code> is sorted in <strong>ascending order</strong>, return <em>the researcher&#39;s h-index</em>.</p>\n\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/H-index\" target=\"_blank\">definition of h-index on Wikipedia</a>: The h-index is defined as the maximum value of <code>h</code> such that the given researcher has published at least <code>h</code> papers that have each been cited at least <code>h</code> times.</p>\n\n<p>You must write an algorithm that runs in logarithmic time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> citations = [0,1,3,5,6]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> citations = [1,2,100]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == citations.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= citations[i] &lt;= 1000</code></li>\n\t<li><code>citations</code> is sorted in <strong>ascending order</strong>.</li>\n</ul>\n"}}, "276": {"__typename": "QuestionLightNode", "acRate": 0.549778809513381, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "276", "isFavor": false, "solutionNum": 210, "title": "Paint Fence", "titleCn": "栅栏涂色", "titleSlug": "paint-fence", "topicTags": [{"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 22, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/7cfd26c43fbe2f5808af9703ce244b443b84cfd9a42c10477d09b8ae1153ac17-GLobe.jpg", "slug": "expedia", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "277": {"__typename": "QuestionLightNode", "acRate": 0.5786631128568422, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "277", "isFavor": false, "solutionNum": 151, "title": "Find the Celebrity", "titleCn": "搜寻名人", "titleSlug": "find-the-celebrity", "topicTags": [{"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "0qo9zm", "name": "Interactive", "slug": "interactive", "nameTranslated": "交互", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 37, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "278": {"__typename": "QuestionLightNode", "acRate": 0.45583163086890105, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "278", "isFavor": false, "solutionNum": 2644, "title": "First Bad Version", "titleCn": "第一个错误的版本", "titleSlug": "first-bad-version", "topicTags": [{"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "0qo9zm", "name": "Interactive", "slug": "interactive", "nameTranslated": "交互", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 50, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>\n\n<p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p>\n\n<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>\n \n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5, bad = 4\n<strong>输出：</strong>4\n<strong>解释：</strong>\n<code>调用 isBadVersion(3) -> false \n调用 isBadVersion(5) -> true \n调用 isBadVersion(4) -> true</code>\n<code>所以，4 是第一个错误的版本。</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, bad = 1\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= bad <= n <= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>\n\n<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p>\n\n<p>You are given an API <code>bool isBadVersion(version)</code> which returns whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5, bad = 4\n<strong>Output:</strong> 4\n<strong>Explanation:</strong>\ncall isBadVersion(3) -&gt; false\ncall isBadVersion(5)&nbsp;-&gt; true\ncall isBadVersion(4)&nbsp;-&gt; true\nThen 4 is the first bad version.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, bad = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bad &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "279": {"__typename": "QuestionLightNode", "acRate": 0.6676215923385579, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "279", "isFavor": false, "solutionNum": 2303, "title": "Perfect Squares", "titleCn": "完全平方数", "titleSlug": "perfect-squares", "topicTags": [{"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 70, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>\n\n<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = <code>12</code>\n<strong>输出：</strong>3 \n<strong>解释：</strong><code>12 = 4 + 4 + 4</code></pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = <code>13</code>\n<strong>输出：</strong>2\n<strong>解释：</strong><code>13 = 4 + 9</code></pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given an integer <code>n</code>, return <em>the least number of perfect square numbers that sum to</em> <code>n</code>.</p>\n\n<p>A <strong>perfect square</strong> is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, <code>1</code>, <code>4</code>, <code>9</code>, and <code>16</code> are perfect squares while <code>3</code> and <code>11</code> are not.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 12\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 12 = 4 + 4 + 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 13\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> 13 = 4 + 9.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "280": {"__typename": "QuestionLightNode", "acRate": 0.6930281454580207, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "280", "isFavor": false, "solutionNum": 135, "title": "Wiggle Sort", "titleCn": "摆动排序", "titleSlug": "wiggle-sort", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 27, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "281": {"__typename": "QuestionLightNode", "acRate": 0.7687507222928465, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "281", "isFavor": false, "solutionNum": 140, "title": "Zigzag Iterator", "titleCn": "锯齿迭代器", "titleSlug": "zigzag-iterator", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "vxfk6", "name": "Queue", "slug": "queue", "nameTranslated": "队列", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "7eks9i", "name": "Iterator", "slug": "iterator", "nameTranslated": "迭代器", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 23, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1711005148-NDGnlq-Coinbase.png", "slug": "coinbase", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "282": {"__typename": "QuestionLightNode", "acRate": 0.4676174084091468, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "282", "isFavor": false, "solutionNum": 231, "title": "Expression Add Operators", "titleCn": "给表达式添加运算符", "titleSlug": "expression-add-operators", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 32, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个仅包含数字&nbsp;<code>0-9</code>&nbsp;的字符串 <code>num</code> 和一个目标值整数 <code>target</code> ，在 <code>num</code> 的数字之间添加 <strong>二元 </strong>运算符（不是一元）<code>+</code>、<code>-</code>&nbsp;或&nbsp;<code>*</code>&nbsp;，返回 <strong>所有</strong> 能够得到 <code>target </code>的表达式。</p>\n\n<p>注意，返回表达式中的操作数 <strong>不应该</strong> 包含前导零。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>num = </code>\"123\", target = 6\n<strong>输出: </strong>[\"1+2+3\", \"1*2*3\"] \n<strong>解释: </strong>“1*2*3” 和 “1+2+3” 的值都是6。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>num = </code>\"232\", target = 8\n<strong>输出: </strong>[\"2*3+2\", \"2+3*2\"]\n<strong>解释:</strong> “2*3+2” 和 “2+3*2” 的值都是8。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> <code>num = </code>\"3456237490\", target = 9191\n<strong>输出: </strong>[]\n<strong>解释: </strong>表达式 “3456237490” 无法得到 9191 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10</code></li>\n\t<li><code>num</code> 仅含数字</li>\n\t<li><code>-2<sup>31</sup> &lt;= target &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given a string <code>num</code> that contains only digits and an integer <code>target</code>, return <em><strong>all possibilities</strong> to insert the binary operators </em><code>&#39;+&#39;</code><em>, </em><code>&#39;-&#39;</code><em>, and/or </em><code>&#39;*&#39;</code><em> between the digits of </em><code>num</code><em> so that the resultant expression evaluates to the </em><code>target</code><em> value</em>.</p>\n\n<p>Note that operands in the returned expressions <strong>should not</strong> contain leading zeros.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;123&quot;, target = 6\n<strong>Output:</strong> [&quot;1*2*3&quot;,&quot;1+2+3&quot;]\n<strong>Explanation:</strong> Both &quot;1*2*3&quot; and &quot;1+2+3&quot; evaluate to 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;232&quot;, target = 8\n<strong>Output:</strong> [&quot;2*3+2&quot;,&quot;2+3*2&quot;]\n<strong>Explanation:</strong> Both &quot;2*3+2&quot; and &quot;2+3*2&quot; evaluate to 8.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;3456237490&quot;, target = 9191\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no expressions that can be created from &quot;3456237490&quot; to evaluate to 9191.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10</code></li>\n\t<li><code>num</code> consists of only digits.</li>\n\t<li><code>-2<sup>31</sup> &lt;= target &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "283": {"__typename": "QuestionLightNode", "acRate": 0.6348488214172237, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "283", "isFavor": false, "solutionNum": 7842, "title": "Move Zeroes", "titleCn": "移动零", "titleSlug": "move-zeroes", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 116, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>\n\n<p><strong>请注意</strong>&nbsp;，必须在不复制数组的情况下原地对数组进行操作。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = <code>[0,1,0,3,12]</code>\n<strong>输出:</strong> <code>[1,3,12,0,0]</code>\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = <code>[0]</code>\n<strong>输出:</strong> <code>[0]</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示</strong>:</p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= nums[i] &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>进阶：</b>你能尽量减少完成的操作次数吗？</p>\n", "en": "<p>Given an integer array <code>nums</code>, move all <code>0</code>&#39;s to the end of it while maintaining the relative order of the non-zero elements.</p>\n\n<p><strong>Note</strong> that you must do this in-place without making a copy of the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [0,1,0,3,12]\n<strong>Output:</strong> [1,3,12,0,0]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [0]\n<strong>Output:</strong> [0]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you minimize the total number of operations done?"}}, "284": {"__typename": "QuestionLightNode", "acRate": 0.7652332505658221, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "284", "isFavor": false, "solutionNum": 270, "title": "Peeking Iterator", "titleCn": "窥视迭代器", "titleSlug": "peeking-iterator", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "7eks9i", "name": "Iterator", "slug": "iterator", "nameTranslated": "迭代器", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 32, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>请你在设计一个迭代器，在集成现有迭代器拥有的&nbsp;<code>hasNext</code> 和 <code>next</code> 操作的基础上，还额外支持 <code>peek</code> 操作。</p>\n\n<p>实现 <code>PeekingIterator</code> 类：</p>\n\n<ul>\n\t<li><code>PeekingIterator(Iterator&lt;int&gt; nums)</code> 使用指定整数迭代器&nbsp;<code>nums</code> 初始化迭代器。</li>\n\t<li><code>int next()</code> 返回数组中的下一个元素，并将指针移动到下个元素处。</li>\n\t<li><code>bool hasNext()</code> 如果数组中存在下一个元素，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n\t<li><code>int peek()</code> 返回数组中的下一个元素，但 <strong>不</strong> 移动指针。</li>\n</ul>\n\n<p><strong>注意：</strong>每种语言可能有不同的构造函数和迭代器&nbsp;<code>Iterator</code>，但均支持 <code>int next()</code> 和 <code>boolean hasNext()</code> 函数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"PeekingIterator\", \"next\", \"peek\", \"next\", \"next\", \"hasNext\"]\n[[[1, 2, 3]], [], [], [], [], []]\n<strong>输出：</strong>\n[null, 1, 2, 2, 3, false]\n\n<strong>解释：</strong>\nPeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [<u><strong>1</strong></u>,2,3]\npeekingIterator.next();    // 返回 1 ，指针移动到下一个元素 [1,<u><strong>2</strong></u>,3]\npeekingIterator.peek();    // 返回 2 ，指针未发生移动 [1,<u><strong>2</strong></u>,3]\npeekingIterator.next();    // 返回 2 ，指针移动到下一个元素 [1,2,<u><strong>3</strong></u>]\npeekingIterator.next();    // 返回 3 ，指针移动到下一个元素 [1,2,3]\npeekingIterator.hasNext(); // 返回 False\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>对 <code>next</code> 和 <code>peek</code> 的调用均有效</li>\n\t<li><code>next</code>、<code>hasNext</code> 和 <code>peek </code>最多调用&nbsp; <code>1000</code> 次</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？</p>\n", "en": "<p>Design an iterator that supports the <code>peek</code> operation on an existing iterator in addition to the <code>hasNext</code> and the <code>next</code> operations.</p>\n\n<p>Implement the <code>PeekingIterator</code> class:</p>\n\n<ul>\n\t<li><code>PeekingIterator(Iterator&lt;int&gt; nums)</code> Initializes the object with the given integer iterator <code>iterator</code>.</li>\n\t<li><code>int next()</code> Returns the next element in the array and moves the pointer to the next element.</li>\n\t<li><code>boolean hasNext()</code> Returns <code>true</code> if there are still elements in the array.</li>\n\t<li><code>int peek()</code> Returns the next element in the array <strong>without</strong> moving the pointer.</li>\n</ul>\n\n<p><strong>Note:</strong> Each language may have a different implementation of the constructor and <code>Iterator</code>, but they all support the <code>int next()</code> and <code>boolean hasNext()</code> functions.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;PeekingIterator&quot;, &quot;next&quot;, &quot;peek&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;]\n[[[1, 2, 3]], [], [], [], [], []]\n<strong>Output</strong>\n[null, 1, 2, 2, 3, false]\n\n<strong>Explanation</strong>\nPeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [<u><strong>1</strong></u>,2,3]\npeekingIterator.next();    // return 1, the pointer moves to the next element [1,<u><strong>2</strong></u>,3].\npeekingIterator.peek();    // return 2, the pointer does not move [1,<u><strong>2</strong></u>,3].\npeekingIterator.next();    // return 2, the pointer moves to the next element [1,2,<u><strong>3</strong></u>]\npeekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]\npeekingIterator.hasNext(); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>All the calls to <code>next</code> and <code>peek</code> are valid.</li>\n\t<li>At most <code>1000</code> calls will be made to <code>next</code>, <code>hasNext</code>, and <code>peek</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> How would you extend your design to be generic and work with all types, not just integer?"}}, "285": {"__typename": "QuestionLightNode", "acRate": 0.6462661848840711, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "285", "isFavor": false, "solutionNum": 184, "title": "Inorder Successor in BST", "titleCn": "二叉搜索树中的中序后继", "titleSlug": "inorder-successor-in-bst", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 37, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "286": {"__typename": "QuestionLightNode", "acRate": 0.5533591663612085, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "286", "isFavor": false, "solutionNum": 246, "title": "Walls and Gates", "titleCn": "墙与门", "titleSlug": "walls-and-gates", "topicTags": [{"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 33, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "287": {"__typename": "QuestionLightNode", "acRate": 0.642243928818887, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "287", "isFavor": false, "solutionNum": 2266, "title": "Find the Duplicate Number", "titleCn": "寻找重复数", "titleSlug": "find-the-duplicate-number", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 82, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个包含&nbsp;<code>n + 1</code> 个整数的数组&nbsp;<code>nums</code> ，其数字都在&nbsp;<code>[1, n]</code>&nbsp;范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>\n\n<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回&nbsp;<strong>这个重复的数</strong> 。</p>\n\n<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,4,2,2]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,3,4,2]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3 :</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,3,3,3,3]\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums.length == n + 1</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= n</code></li>\n\t<li><code>nums</code> 中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 <strong>一次</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>进阶：</b></p>\n\n<ul>\n\t<li>如何证明 <code>nums</code> 中至少存在一个重复的数字?</li>\n\t<li>你可以设计一个线性级时间复杂度 <code>O(n)</code> 的解决方案吗？</li>\n</ul>\n", "en": "<p>Given an array of integers <code>nums</code> containing&nbsp;<code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.</p>\n\n<p>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this&nbsp;repeated&nbsp;number</em>.</p>\n\n<p>You must solve the problem <strong>without</strong> modifying the array <code>nums</code>&nbsp;and uses only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,4,2,2]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,3,4,2]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,3,3,3,3]\n<strong>Output:</strong> 3</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums.length == n + 1</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= n</code></li>\n\t<li>All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b>Follow up:</b></p>\n\n<ul>\n\t<li>How can we prove that at least one duplicate number must exist in <code>nums</code>?</li>\n\t<li>Can you solve the problem in linear runtime complexity?</li>\n</ul>\n"}}, "288": {"__typename": "QuestionLightNode", "acRate": 0.5006835024102454, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "288", "isFavor": false, "solutionNum": 94, "title": "Unique Word Abbreviation", "titleCn": "单词的唯一缩写", "titleSlug": "unique-word-abbreviation", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 6, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "289": {"__typename": "QuestionLightNode", "acRate": 0.7612827038881594, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "289", "isFavor": false, "solutionNum": 1315, "title": "Game of Life", "titleCn": "生命游戏", "titleSlug": "game-of-life", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 45, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708936774-exAysB-u=3581604551,3862588286&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "dropbox", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>根据&nbsp;<a href=\"https://baike.baidu.com/item/%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/2926434?fr=aladdin\" target=\"_blank\">百度百科</a>&nbsp;，&nbsp;<strong>生命游戏</strong>&nbsp;，简称为 <strong>生命</strong> ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p>\n\n<p>给定一个包含 <code>m × n</code>&nbsp;个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： <code>1</code> 即为 <strong>活细胞</strong> （live），或 <code>0</code> 即为 <strong>死细胞</strong> （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>\n\n<ol>\n\t<li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li>\n\t<li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li>\n\t<li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li>\n\t<li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li>\n</ol>\n\n<p>下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 <code>m x n</code> 网格面板 <code>board</code> 的当前状态，返回下一个状态。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg\" />\n<pre>\n<strong>输入：</strong>board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n<strong>输出：</strong>[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg\" />\n<pre>\n<strong>输入：</strong>board = [[1,1],[1,0]]\n<strong>输出：</strong>[[1,1],[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 25</code></li>\n\t<li><code>board[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。</li>\n\t<li>本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</li>\n</ul>\n", "en": "<p>According to&nbsp;<a href=\"https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\" target=\"_blank\">Wikipedia&#39;s article</a>: &quot;The <b>Game of Life</b>, also known simply as <b>Life</b>, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&quot;</p>\n\n<p>The board is made up of an <code>m x n</code> grid of cells, where each cell has an initial state: <b>live</b> (represented by a <code>1</code>) or <b>dead</b> (represented by a <code>0</code>). Each cell interacts with its <a href=\"https://en.wikipedia.org/wiki/Moore_neighborhood\" target=\"_blank\">eight neighbors</a> (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>\n\n<ol>\n\t<li>Any live cell with fewer than two live neighbors dies as if caused by under-population.</li>\n\t<li>Any live cell with two or three live neighbors lives on to the next generation.</li>\n\t<li>Any live cell with more than three live neighbors dies, as if by over-population.</li>\n\t<li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>\n</ol>\n\n<p><span>The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the <code>m x n</code> grid <code>board</code>, return <em>the next state</em>.</span></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg\" style=\"width: 562px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n<strong>Output:</strong> [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg\" style=\"width: 402px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> board = [[1,1],[1,0]]\n<strong>Output:</strong> [[1,1],[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 25</code></li>\n\t<li><code>board[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.</li>\n\t<li>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?</li>\n</ul>\n"}}, "290": {"__typename": "QuestionLightNode", "acRate": 0.4457940109007997, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "290", "isFavor": false, "solutionNum": 1991, "title": "Word Pattern", "titleCn": "单词规律", "titleSlug": "word-pattern", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 50, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1711090840-jlSkmv-capital one.png", "slug": "capital-one", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一种规律 <code>pattern</code>&nbsp;和一个字符串&nbsp;<code>s</code>&nbsp;，判断 <code>s</code>&nbsp;是否遵循相同的规律。</p>\n\n<p>这里的&nbsp;<strong>遵循&nbsp;</strong>指完全匹配，例如，&nbsp;<code>pattern</code>&nbsp;里的每个字母和字符串&nbsp;<code>s</code><strong>&nbsp;</strong>中的每个非空单词之间存在着双向连接的对应规律。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1:</strong></p>\n\n<pre>\n<strong>输入:</strong> pattern = <code>\"abba\"</code>, s = <code>\"dog cat cat dog\"</code>\n<strong>输出:</strong> true</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong>pattern = <code>\"abba\"</code>, s = <code>\"dog cat cat fish\"</code>\n<strong>输出:</strong> false</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> pattern = <code>\"aaaa\"</code>, s = <code>\"dog cat cat dog\"</code>\n<strong>输出:</strong> false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length &lt;= 300</code></li>\n\t<li><code>pattern</code>&nbsp;只包含小写英文字母</li>\n\t<li><code>1 &lt;= s.length &lt;= 3000</code></li>\n\t<li><code>s</code>&nbsp;只包含小写英文字母和&nbsp;<code>' '</code></li>\n\t<li><code>s</code>&nbsp;<strong>不包含</strong> 任何前导或尾随对空格</li>\n\t<li><code>s</code>&nbsp;中每个单词都被 <strong>单个空格 </strong>分隔</li>\n</ul>\n", "en": "<p>Given a <code>pattern</code> and a string <code>s</code>, find if <code>s</code>&nbsp;follows the same pattern.</p>\n\n<p>Here <b>follow</b> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <b>non-empty</b> word in <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> pattern = &quot;abba&quot;, s = &quot;dog cat cat fish&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> pattern = &quot;aaaa&quot;, s = &quot;dog cat cat dog&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= pattern.length &lt;= 300</code></li>\n\t<li><code>pattern</code> contains only lower-case English letters.</li>\n\t<li><code>1 &lt;= s.length &lt;= 3000</code></li>\n\t<li><code>s</code> contains only lowercase English letters and spaces <code>&#39; &#39;</code>.</li>\n\t<li><code>s</code> <strong>does not contain</strong> any leading or trailing spaces.</li>\n\t<li>All the words in <code>s</code> are separated by a <strong>single space</strong>.</li>\n</ul>\n"}}, "291": {"__typename": "QuestionLightNode", "acRate": 0.5174943566591422, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "291", "isFavor": false, "solutionNum": 111, "title": "Word Pattern II", "titleCn": "单词规律 II", "titleSlug": "word-pattern-ii", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 23, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708936774-exAysB-u=3581604551,3862588286&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "dropbox", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/455700859e03a769dcb90fabbcce91f17af10954d6cab1b473c341ae8511915c-snapchat_logo1-300x300.png", "slug": "snapchat", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "292": {"__typename": "QuestionLightNode", "acRate": 0.7083965188809621, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "292", "isFavor": false, "solutionNum": 1213, "title": "Nim Game", "titleCn": "Nim 游戏", "titleSlug": "nim-game", "topicTags": [{"id": "njnym", "name": "Brainteaser", "slug": "brainteaser", "nameTranslated": "脑筋急转弯", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "vawmlm", "name": "Game Theory", "slug": "game-theory", "nameTranslated": "博弈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 57, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode.cn/aliyun-lc-upload/uploaded_files/2023/01/e68645fd-9dd0-46ee-b97c-f4ad64a07848/3%26fmt%3Dauto%26app%3D120%26f%3DJPEG.webp", "slug": "tencent", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你和你的朋友，两个人一起玩&nbsp;<a href=\"https://baike.baidu.com/item/Nim游戏/6737105\" target=\"_blank\">Nim 游戏</a>：</p>\n\n<ul>\n\t<li>桌子上有一堆石头。</li>\n\t<li>你们轮流进行自己的回合，&nbsp;<strong>你作为先手&nbsp;</strong>。</li>\n\t<li>每一回合，轮到的人拿掉&nbsp;1 - 3 块石头。</li>\n\t<li>拿掉最后一块石头的人就是获胜者。</li>\n</ul>\n\n<p>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 <code>n</code> 的情况下赢得游戏。如果可以赢，返回 <code>true</code>；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>n = 4</code>\n<strong>输出：</strong>false \n<strong>解释：</strong>以下是可能的结果:\n1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。\n2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。\n3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。\n在所有结果中，你的朋友是赢家。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>You are playing the following Nim Game with your friend:</p>\n\n<ul>\n\t<li>Initially, there is a heap of stones on the table.</li>\n\t<li>You and your friend will alternate taking turns, and <strong>you go first</strong>.</li>\n\t<li>On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.</li>\n\t<li>The one who removes the last stone is the winner.</li>\n</ul>\n\n<p>Given <code>n</code>, the number of stones in the heap, return <code>true</code><em> if you can win the game assuming both you and your friend play optimally, otherwise return </em><code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> false\n<strong>Explanation:</strong> These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "293": {"__typename": "QuestionLightNode", "acRate": 0.729306864064603, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "293", "isFavor": false, "solutionNum": 131, "title": "Flip Game", "titleCn": "翻转游戏", "titleSlug": "flip-game", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 8, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "294": {"__typename": "QuestionLightNode", "acRate": 0.5918316419896856, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "294", "isFavor": false, "solutionNum": 87, "title": "Flip Game II", "titleCn": "翻转游戏 II", "titleSlug": "flip-game-ii", "topicTags": [{"id": "vhos7", "name": "Memoization", "slug": "memoization", "nameTranslated": "记忆化搜索", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "vawmlm", "name": "Game Theory", "slug": "game-theory", "nameTranslated": "博弈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 7, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/e963193dcb2bd0b5707723cfbe67e7dec9240d74c0a686f301bf83c5e3d97f5e-ZYzn7Lro.png", "slug": "rubrik", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "295": {"__typename": "QuestionLightNode", "acRate": 0.5431550507363959, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "295", "isFavor": false, "solutionNum": 923, "title": "Find Median from Data Stream", "titleCn": "数据流的中位数", "titleSlug": "find-median-from-data-stream", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "pgti0i", "name": "Data Stream", "slug": "data-stream", "nameTranslated": "数据流", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 88, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p>\n\n<ul>\n\t<li>例如 <code>arr = [2,3,4]</code>&nbsp;的中位数是 <code>3</code>&nbsp;。</li>\n\t<li>例如&nbsp;<code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li>\n</ul>\n\n<p>实现 MedianFinder 类:</p>\n\n<ul>\n\t<li>\n\t<p><code>MedianFinder() </code>初始化 <code>MedianFinder</code>&nbsp;对象。</p>\n\t</li>\n\t<li>\n\t<p><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</p>\n\t</li>\n\t<li>\n\t<p><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差&nbsp;<code>10<sup>-5</sup></code>&nbsp;以内的答案将被接受。</p>\n\t</li>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\n<strong>输出</strong>\n[null, null, null, 1.5, null, 2.0]\n\n<strong>解释</strong>\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0</pre>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= num &lt;= 10<sup>5</sup></code></li>\n\t<li>在调用 <code>findMedian</code>&nbsp;之前，数据结构中至少有一个元素</li>\n\t<li>最多&nbsp;<code>5 * 10<sup>4</sup></code>&nbsp;次调用&nbsp;<code>addNum</code>&nbsp;和&nbsp;<code>findMedian</code></li>\n</ul>\n", "en": "<p>The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.</p>\n\n<ul>\n\t<li>For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.</li>\n\t<li>For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</li>\n</ul>\n\n<p>Implement the MedianFinder class:</p>\n\n<ul>\n\t<li><code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.</li>\n\t<li><code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.</li>\n\t<li><code>double findMedian()</code> returns the median of all elements so far. Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]\n[[], [1], [2], [], [3], []]\n<strong>Output</strong>\n[null, null, null, 1.5, null, 2.0]\n\n<strong>Explanation</strong>\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>5</sup> &lt;= num &lt;= 10<sup>5</sup></code></li>\n\t<li>There will be at least one element in the data structure before calling <code>findMedian</code>.</li>\n\t<li>At most <code>5 * 10<sup>4</sup></code> calls will be made to <code>addNum</code> and <code>findMedian</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>If all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li>\n\t<li>If <code>99%</code> of all integer numbers from the stream are in the range <code>[0, 100]</code>, how would you optimize your solution?</li>\n</ul>\n"}}, "296": {"__typename": "QuestionLightNode", "acRate": 0.6144024514811032, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "296", "isFavor": false, "solutionNum": 70, "title": "Best Meeting Point", "titleCn": "最佳的碰头地点", "titleSlug": "best-meeting-point", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 25, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/455700859e03a769dcb90fabbcce91f17af10954d6cab1b473c341ae8511915c-snapchat_logo1-300x300.png", "slug": "snapchat", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "297": {"__typename": "QuestionLightNode", "acRate": 0.5915132771569155, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "297", "isFavor": false, "solutionNum": 1447, "title": "Serialize and Deserialize Binary Tree", "titleCn": "二叉树的序列化与反序列化", "titleSlug": "serialize-and-deserialize-binary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 73, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>\n\n<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>\n\n<p><strong>提示: </strong>输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅&nbsp;<a href=\"https://support.leetcode.cn/hc/kb/article/1567641/\">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" style=\"width: 442px; height: 324px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,null,4,5]\n<strong>输出：</strong>[1,2,3,null,null,4,5]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中结点数在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n", "en": "<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>\n\n<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>\n\n<p><strong>Clarification:</strong> The input/output format is the same as <a href=\"https://support.leetcode.com/hc/en-us/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-representation-\" target=\"_blank\">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg\" style=\"width: 442px; height: 324px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,null,4,5]\n<strong>Output:</strong> [1,2,3,null,null,4,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n"}}, "298": {"__typename": "QuestionLightNode", "acRate": 0.5983025461807289, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "298", "isFavor": false, "solutionNum": 159, "title": "Binary Tree Longest Consecutive Sequence", "titleCn": "二叉树最长连续序列", "titleSlug": "binary-tree-longest-consecutive-sequence", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 19, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "299": {"__typename": "QuestionLightNode", "acRate": 0.5957811232308663, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "299", "isFavor": false, "solutionNum": 1041, "title": "Bulls and Cows", "titleCn": "猜数字游戏", "titleSlug": "bulls-and-cows", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "pxpqcm", "name": "Counting", "slug": "counting", "nameTranslated": "计数", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 28, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你在和朋友一起玩 <a href=\"https://baike.baidu.com/item/%E7%8C%9C%E6%95%B0%E5%AD%97/83200?fromtitle=Bulls+and+Cows&amp;fromid=12003488&amp;fr=aladdin\" target=\"_blank\">猜数字（Bulls and Cows）</a>游戏，该游戏规则如下：</p>\n\n<p>写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：</p>\n\n<ul>\n\t<li>猜测数字中有多少位属于数字和确切位置都猜对了（称为 \"Bulls\"，公牛），</li>\n\t<li>有多少位属于数字猜对了但是位置不对（称为 \"Cows\"，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。</li>\n</ul>\n\n<p>给你一个秘密数字&nbsp;<code>secret</code> 和朋友猜测的数字&nbsp;<code>guess</code> ，请你返回对朋友这次猜测的提示。</p>\n\n<p>提示的格式为 <code>\"xAyB\"</code> ，<code>x</code> 是公牛个数， <code>y</code> 是奶牛个数，<code>A</code> 表示公牛，<code>B</code>&nbsp;表示奶牛。</p>\n\n<p>请注意秘密数字和朋友猜测的数字都可能含有重复数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>secret = \"1807\", guess = \"7810\"\n<strong>输出：</strong>\"1A3B\"\n<strong>解释：</strong>数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\"1807\"\n  |\n\"<em><strong>7</strong></em>8<em><strong>10</strong></em>\"</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>secret = \"1123\", guess = \"0111\"\n<strong>输出：</strong>\"1A1B\"\n<strong>解释：</strong>数字和位置都对（公牛）用 '|' 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\"1123\"        \"1123\"\n  |      or     |\n\"01<em><strong>1</strong></em>1\"        \"011<em><strong>1</strong></em>\"\n注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li>\n\t<li><code>secret.length == guess.length</code></li>\n\t<li><code>secret</code> 和 <code>guess</code> 仅由数字组成</li>\n</ul>\n", "en": "<p>You are playing the <strong><a href=\"https://en.wikipedia.org/wiki/Bulls_and_Cows\" target=\"_blank\">Bulls and Cows</a></strong> game with your friend.</p>\n\n<p>You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:</p>\n\n<ul>\n\t<li>The number of &quot;bulls&quot;, which are digits in the guess that are in the correct position.</li>\n\t<li>The number of &quot;cows&quot;, which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.</li>\n</ul>\n\n<p>Given the secret number <code>secret</code> and your friend&#39;s guess <code>guess</code>, return <em>the hint for your friend&#39;s guess</em>.</p>\n\n<p>The hint should be formatted as <code>&quot;xAyB&quot;</code>, where <code>x</code> is the number of bulls and <code>y</code> is the number of cows. Note that both <code>secret</code> and <code>guess</code> may contain duplicate digits.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> secret = &quot;1807&quot;, guess = &quot;7810&quot;\n<strong>Output:</strong> &quot;1A3B&quot;\n<strong>Explanation:</strong> Bulls are connected with a &#39;|&#39; and cows are underlined:\n&quot;1807&quot;\n  |\n&quot;<u>7</u>8<u>10</u>&quot;</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> secret = &quot;1123&quot;, guess = &quot;0111&quot;\n<strong>Output:</strong> &quot;1A1B&quot;\n<strong>Explanation:</strong> Bulls are connected with a &#39;|&#39; and cows are underlined:\n&quot;1123&quot;        &quot;1123&quot;\n  |      or     |\n&quot;01<u>1</u>1&quot;        &quot;011<u>1</u>&quot;\nNote that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li>\n\t<li><code>secret.length == guess.length</code></li>\n\t<li><code>secret</code> and <code>guess</code> consist of digits only.</li>\n</ul>\n"}}, "300": {"__typename": "QuestionLightNode", "acRate": 0.5563805987333089, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "300", "isFavor": false, "solutionNum": 4823, "title": "Longest Increasing Subsequence", "titleCn": "最长递增子序列", "titleSlug": "longest-increasing-subsequence", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 121, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>\n\n<p><strong>子序列&nbsp;</strong>是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的<span data-keyword=\"subsequence-array\">子序列</span>。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,9,2,5,3,7,101,18]\n<strong>输出：</strong>4\n<strong>解释：</strong>最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0,1,0,3,2,3]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,7,7,7,7,7,7]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2500</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><b>进阶：</b></p>\n\n<ul>\n\t<li>你能将算法的时间复杂度降低到&nbsp;<code>O(n log(n))</code> 吗?</li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code>, return <em>the length of the longest <strong>strictly increasing </strong></em><span data-keyword=\"subsequence-array\"><em><strong>subsequence</strong></em></span>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,9,2,5,3,7,101,18]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,0,3,2,3]\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [7,7,7,7,7,7,7]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2500</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b>Follow up:</b>&nbsp;Can you come up with an algorithm that runs in&nbsp;<code>O(n log(n))</code> time complexity?</p>\n"}}, "301": {"__typename": "QuestionLightNode", "acRate": 0.553579830716173, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "301", "isFavor": false, "solutionNum": 622, "title": "Remove Invalid Parentheses", "titleCn": "删除无效的括号", "titleSlug": "remove-invalid-parentheses", "topicTags": [{"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 48, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个由若干括号和字母组成的字符串 <code>s</code> ，删除最小数量的无效括号，使得输入的字符串有效。</p>\n\n<p>返回所有可能的结果。答案可以按 <strong>任意顺序</strong> 返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"()())()\"\n<strong>输出：</strong>[\"(())()\",\"()()()\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(a)())()\"\n<strong>输出：</strong>[\"(a())()\",\"(a)()()\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \")(\"\n<strong>输出：</strong>[\"\"]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 25</code></li>\n\t<li><code>s</code> 由小写英文字母以及括号 <code>'('</code> 和 <code>')'</code> 组成</li>\n\t<li><code>s</code> 中至多含 <code>20</code> 个括号</li>\n</ul>\n", "en": "<p>Given a string <code>s</code> that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.</p>\n\n<p>Return <em>a list of <strong>unique strings</strong> that are valid with the minimum number of removals</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;()())()&quot;\n<strong>Output:</strong> [&quot;(())()&quot;,&quot;()()()&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;(a)())()&quot;\n<strong>Output:</strong> [&quot;(a())()&quot;,&quot;(a)()()&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;)(&quot;\n<strong>Output:</strong> [&quot;&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 25</code></li>\n\t<li><code>s</code> consists of lowercase English letters and parentheses <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>.</li>\n\t<li>There will be at most <code>20</code> parentheses in <code>s</code>.</li>\n</ul>\n"}}, "302": {"__typename": "QuestionLightNode", "acRate": 0.6758232931726907, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "302", "isFavor": false, "solutionNum": 67, "title": "Smallest Rectangle Enclosing Black Pixels", "titleCn": "包含全部黑色像素的最小矩形", "titleSlug": "smallest-rectangle-enclosing-black-pixels", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 7, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "303": {"__typename": "QuestionLightNode", "acRate": 0.7832917632559641, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "303", "isFavor": false, "solutionNum": 2378, "title": "Range Sum Query - Immutable", "titleCn": "区域和检索 - 数组不可变", "titleSlug": "range-sum-query-immutable", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 34, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个整数数组 &nbsp;<code>nums</code>，处理以下类型的多个查询:</p>\n\n<ol>\n\t<li>计算索引&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code>&nbsp;（包含 <code>left</code> 和 <code>right</code>）之间的 <code>nums</code> 元素的 <strong>和</strong> ，其中&nbsp;<code>left &lt;= right</code></li>\n</ol>\n\n<p>实现 <code>NumArray</code> 类：</p>\n\n<ul>\n\t<li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li>\n\t<li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code>&nbsp;中索引&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code>&nbsp;之间的元素的 <strong>总和</strong> ，包含&nbsp;<code>left</code>&nbsp;和&nbsp;<code>right</code>&nbsp;两点（也就是&nbsp;<code>nums[left] + nums[left + 1] + ... + nums[right]</code>&nbsp;)</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n<strong>输出：\n</strong>[null, 1, -1, -3]\n\n<strong>解释：</strong>\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)\nnumArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) \nnumArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= nums[i] &lt;=&nbsp;10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= i &lt;= j &lt; nums.length</code></li>\n\t<li>最多调用 <code>10<sup>4</sup></code> 次 <code>sumRange</code><strong> </strong>方法</li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code>, handle multiple queries of the following type:</p>\n\n<ol>\n\t<li>Calculate the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> where <code>left &lt;= right</code>.</li>\n</ol>\n\n<p>Implement the <code>NumArray</code> class:</p>\n\n<ul>\n\t<li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>\n\t<li><code>int sumRange(int left, int right)</code> Returns the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> (i.e. <code>nums[left] + nums[left + 1] + ... + nums[right]</code>).</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n<strong>Output</strong>\n[null, 1, -1, -3]\n\n<strong>Explanation</strong>\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt; nums.length</code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>sumRange</code>.</li>\n</ul>\n"}}, "304": {"__typename": "QuestionLightNode", "acRate": 0.6230262149317799, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "304", "isFavor": false, "solutionNum": 1434, "title": "Range Sum Query 2D - Immutable", "titleCn": "二维区域和检索 - 矩阵不可变", "titleSlug": "range-sum-query-2d-immutable", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 48, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><big><small>给定一个二维矩阵 <code>matrix</code>，</small></big>以下类型的多个请求：</p>\n\n<ul>\n\t<li><big><small>计算其子矩形范围内元素的总和，该子矩阵的 <strong>左上角</strong> 为 <code>(row1,&nbsp;col1)</code> ，<strong>右下角</strong> 为 <code>(row2,&nbsp;col2)</code> 。</small></big></li>\n</ul>\n\n<p>实现 <code>NumMatrix</code> 类：</p>\n\n<ul>\n\t<li><code>NumMatrix(int[][] matrix)</code>&nbsp;给定整数矩阵 <code>matrix</code> 进行初始化</li>\n\t<li><code>int sumRegion(int row1, int col1, int row2, int col2)</code>&nbsp;返回<big><small> <strong>左上角</strong></small></big><big><small> <code>(row1,&nbsp;col1)</code>&nbsp;、<strong>右下角</strong>&nbsp;<code>(row2,&nbsp;col2)</code></small></big> 所描述的子矩阵的元素 <strong>总和</strong> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://pic.leetcode-cn.com/1626332422-wUpUHT-image.png\" style=\"width: 200px;\" /></p>\n\n<pre>\n<strong>输入:</strong> \n[\"NumMatrix\",\"sumRegion\",\"sumRegion\",\"sumRegion\"]\n[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]\n<strong>输出:</strong> \n[null, 8, 11, 12]\n\n<strong>解释:</strong>\nNumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)\nnumMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)\nnumMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m,&nbsp;n &lt;=&nbsp;200</code><meta charset=\"UTF-8\" /></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= matrix[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= row1 &lt;= row2 &lt; m</code></li>\n\t<li><code>0 &lt;= col1 &lt;= col2 &lt; n</code></li>\n\t<li><meta charset=\"UTF-8\" />最多调用 <code>10<sup>4</sup></code> 次&nbsp;<code>sumRegion</code> 方法</li>\n</ul>\n", "en": "<p>Given a 2D matrix <code>matrix</code>, handle multiple queries of the following type:</p>\n\n<ul>\n\t<li>Calculate the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.</li>\n</ul>\n\n<p>Implement the <code>NumMatrix</code> class:</p>\n\n<ul>\n\t<li><code>NumMatrix(int[][] matrix)</code> Initializes the object with the integer matrix <code>matrix</code>.</li>\n\t<li><code>int sumRegion(int row1, int col1, int row2, int col2)</code> Returns the <strong>sum</strong> of the elements of <code>matrix</code> inside the rectangle defined by its <strong>upper left corner</strong> <code>(row1, col1)</code> and <strong>lower right corner</strong> <code>(row2, col2)</code>.</li>\n</ul>\n\n<p>You must design an algorithm where <code>sumRegion</code> works on <code>O(1)</code> time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/sum-grid.jpg\" style=\"width: 415px; height: 415px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;NumMatrix&quot;, &quot;sumRegion&quot;, &quot;sumRegion&quot;, &quot;sumRegion&quot;]\n[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]\n<strong>Output</strong>\n[null, 8, 11, 12]\n\n<strong>Explanation</strong>\nNumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)\nnumMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)\nnumMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= matrix[i][j] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= row1 &lt;= row2 &lt; m</code></li>\n\t<li><code>0 &lt;= col1 &lt;= col2 &lt; n</code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>sumRegion</code>.</li>\n</ul>\n"}}, "305": {"__typename": "QuestionLightNode", "acRate": 0.42073743541568814, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "305", "isFavor": false, "solutionNum": 137, "title": "Number of Islands II", "titleCn": "岛屿数量 II", "titleSlug": "number-of-islands-ii", "topicTags": [{"id": "n6a2i", "name": "Union Find", "slug": "union-find", "nameTranslated": "并查集", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 31, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "306": {"__typename": "QuestionLightNode", "acRate": 0.37632614980103335, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "306", "isFavor": false, "solutionNum": 727, "title": "Additive Number", "titleCn": "累加数", "titleSlug": "additive-number", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 22, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><strong>累加数</strong> 是一个字符串，组成它的数字可以形成累加序列。</p>\n\n<p>一个有效的 <strong>累加序列</strong> 必须<strong> 至少 </strong>包含 3 个数。除了最开始的两个数以外，序列中的每个后续数字必须是它之前两个数字之和。</p>\n\n<p>给你一个只包含数字&nbsp;<code>'0'-'9'</code>&nbsp;的字符串，编写一个算法来判断给定输入是否是 <strong>累加数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p><strong>说明：</strong>累加序列里的数，除数字 0 之外，<strong>不会</strong> 以 0 开头，所以不会出现&nbsp;<code>1, 2, 03</code> 或者&nbsp;<code>1, 02, 3</code>&nbsp;的情况。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>\"112358\"</code>\n<strong>输出：</strong>true \n<strong>解释：</strong>累加序列为: <code>1, 1, 2, 3, 5, 8 </code>。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<pre>\n<strong>输入<code>：</code></strong><code>\"199100199\"</code>\n<strong>输出：</strong>true \n<strong>解释：</strong>累加序列为: <code>1, 99, 100, 199。</code>1 + 99 = 100, 99 + 100 = 199</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 35</code></li>\n\t<li><code>num</code> 仅由数字（<code>0</code> - <code>9</code>）组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你计划如何处理由过大的整数输入导致的溢出?</p>\n", "en": "<p>An <strong>additive number</strong> is a string whose digits can form an <strong>additive sequence</strong>.</p>\n\n<p>A valid <strong>additive sequence</strong> should contain <strong>at least</strong> three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.</p>\n\n<p>Given a string containing only digits, return <code>true</code> if it is an <strong>additive number</strong> or <code>false</code> otherwise.</p>\n\n<p><strong>Note:</strong> Numbers in the additive sequence <strong>cannot</strong> have leading zeros, so sequence <code>1, 2, 03</code> or <code>1, 02, 3</code> is invalid.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> &quot;112358&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> \nThe digits can form an additive sequence: 1, 1, 2, 3, 5, 8. \n1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> &quot;199100199&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> \nThe additive sequence is: 1, 99, 100, 199.&nbsp;\n1 + 99 = 100, 99 + 100 = 199\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 35</code></li>\n\t<li><code>num</code> consists only of digits.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> How would you handle overflow for very large input integers?</p>\n"}}, "307": {"__typename": "QuestionLightNode", "acRate": 0.5342234240324488, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "307", "isFavor": false, "solutionNum": 686, "title": "Range Sum Query - Mutable", "titleCn": "区域和检索 - 数组可修改", "titleSlug": "range-sum-query-mutable", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "n16hs", "name": "Binary Indexed Tree", "slug": "binary-indexed-tree", "nameTranslated": "树状数组", "__typename": "CommonTagNode"}, {"id": "nytfd", "name": "Segment Tree", "slug": "segment-tree", "nameTranslated": "线段树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 25, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个数组 <code>nums</code> ，请你完成两类查询。</p>\n\n<ol>\n\t<li>其中一类查询要求 <strong>更新</strong> 数组&nbsp;<code>nums</code>&nbsp;下标对应的值</li>\n\t<li>另一类查询要求返回数组&nbsp;<code>nums</code>&nbsp;中索引&nbsp;<code>left</code>&nbsp;和索引&nbsp;<code>right</code>&nbsp;之间（&nbsp;<strong>包含&nbsp;</strong>）的nums元素的 <strong>和</strong>&nbsp;，其中&nbsp;<code>left &lt;= right</code></li>\n</ol>\n\n<p>实现 <code>NumArray</code> 类：</p>\n\n<ul>\n\t<li><code>NumArray(int[] nums)</code> 用整数数组 <code>nums</code> 初始化对象</li>\n\t<li><code>void update(int index, int val)</code> 将 <code>nums[index]</code> 的值 <strong>更新</strong> 为 <code>val</code></li>\n\t<li><code>int sumRange(int left, int right)</code> 返回数组&nbsp;<code>nums</code>&nbsp;中索引&nbsp;<code>left</code>&nbsp;和索引&nbsp;<code>right</code>&nbsp;之间（&nbsp;<strong>包含&nbsp;</strong>）的nums元素的 <strong>和</strong>&nbsp;（即，<code>nums[left] + nums[left + 1], ..., nums[right]</code>）</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>：\n[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"]\n[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]\n<strong>输出</strong>：\n[null, 9, null, 8]\n\n<strong>解释</strong>：\nNumArray numArray = new NumArray([1, 3, 5]);\nnumArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9\nnumArray.update(1, 2);   // nums = [1,2,5]\nnumArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 *&nbsp;10<sup>4</sup></code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= index &lt; nums.length</code></li>\n\t<li><code>-100 &lt;= val &lt;= 100</code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt; nums.length</code></li>\n\t<li>调用 <code>update</code> 和 <code>sumRange</code> 方法次数不大于&nbsp;<code>3 * 10<sup>4</sup></code>&nbsp;</li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code>, handle multiple queries of the following types:</p>\n\n<ol>\n\t<li><strong>Update</strong> the value of an element in <code>nums</code>.</li>\n\t<li>Calculate the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> where <code>left &lt;= right</code>.</li>\n</ol>\n\n<p>Implement the <code>NumArray</code> class:</p>\n\n<ul>\n\t<li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>\n\t<li><code>void update(int index, int val)</code> <strong>Updates</strong> the value of <code>nums[index]</code> to be <code>val</code>.</li>\n\t<li><code>int sumRange(int left, int right)</code> Returns the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> (i.e. <code>nums[left] + nums[left + 1] + ... + nums[right]</code>).</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;update&quot;, &quot;sumRange&quot;]\n[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]\n<strong>Output</strong>\n[null, 9, null, 8]\n\n<strong>Explanation</strong>\nNumArray numArray = new NumArray([1, 3, 5]);\nnumArray.sumRange(0, 2); // return 1 + 3 + 5 = 9\nnumArray.update(1, 2);   // nums = [1, 2, 5]\nnumArray.sumRange(0, 2); // return 1 + 2 + 5 = 8\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= index &lt; nums.length</code></li>\n\t<li><code>-100 &lt;= val &lt;= 100</code></li>\n\t<li><code>0 &lt;= left &lt;= right &lt; nums.length</code></li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>update</code> and <code>sumRange</code>.</li>\n</ul>\n"}}, "308": {"__typename": "QuestionLightNode", "acRate": 0.6389316179555307, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "308", "isFavor": false, "solutionNum": 88, "title": "Range Sum Query 2D - Mutable", "titleCn": "二维区域和检索 - 可变", "titleSlug": "range-sum-query-2d-mutable", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "n16hs", "name": "Binary Indexed Tree", "slug": "binary-indexed-tree", "nameTranslated": "树状数组", "__typename": "CommonTagNode"}, {"id": "nytfd", "name": "Segment Tree", "slug": "segment-tree", "nameTranslated": "线段树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "309": {"__typename": "QuestionLightNode", "acRate": 0.6474653437879913, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "309", "isFavor": false, "solutionNum": 2178, "title": "Best Time to Buy and Sell Stock with Cooldown", "titleCn": "买卖股票的最佳时机含冷冻期", "titleSlug": "best-time-to-buy-and-sell-stock-with-cooldown", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 60, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个整数数组<meta charset=\"UTF-8\" /><code>prices</code>，其中第&nbsp;<em>&nbsp;</em><code>prices[i]</code>&nbsp;表示第&nbsp;<code><em>i</em></code>&nbsp;天的股票价格 。​</p>\n\n<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>\n\n<ul>\n\t<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>\n</ul>\n\n<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> prices = [1,2,3,0,2]\n<strong>输出: </strong>3 \n<strong>解释:</strong> 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> prices = [1]\n<strong>输出:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>\n</ul>\n", "en": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:</p>\n\n<ul>\n\t<li>After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).</li>\n</ul>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,3,0,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> transactions = [buy, sell, cooldown, buy, sell]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>\n</ul>\n"}}, "310": {"__typename": "QuestionLightNode", "acRate": 0.43711747504397475, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "310", "isFavor": false, "solutionNum": 594, "title": "Minimum Height Trees", "titleCn": "最小高度树", "titleSlug": "minimum-height-trees", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}, {"id": "ns19t", "name": "Topological Sort", "slug": "topological-sort", "nameTranslated": "拓扑排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 32, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，任何一个没有简单环路的连通图都是一棵树。</p>\n\n<p>给你一棵包含&nbsp;<code>n</code>&nbsp;个节点的树，标记为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code> 。给定数字&nbsp;<code>n</code>&nbsp;和一个有 <code>n - 1</code> 条无向边的 <code>edges</code>&nbsp;列表（每一个边都是一对标签），其中 <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> 表示树中节点 <code>a<sub>i</sub></code> 和 <code>b<sub>i</sub></code> 之间存在一条无向边。</p>\n\n<p>可选择树中任何一个节点作为根。当选择节点 <code>x</code> 作为根节点时，设结果树的高度为 <code>h</code> 。在所有可能的树中，具有最小高度的树（即，<code>min(h)</code>）被称为 <strong>最小高度树</strong> 。</p>\n\n<p>请你找到所有的 <strong>最小高度树</strong> 并按 <strong>任意顺序</strong> 返回它们的根节点标签列表。</p>\n树的 <strong>高度</strong> 是指根节点和叶子节点之间最长向下路径上边的数量。\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/e1.jpg\" style=\"height: 213px; width: 800px;\" />\n<pre>\n<strong>输入：</strong>n = 4, edges = [[1,0],[1,2],[1,3]]\n<strong>输出：</strong>[1]\n<strong>解释：</strong>如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/e2.jpg\" style=\"height: 321px; width: 800px;\" />\n<pre>\n<strong>输入：</strong>n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\n<strong>输出：</strong>[3,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<ul>\n</ul>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>所有 <code>(a<sub>i</sub>, b<sub>i</sub>)</code> 互不相同</li>\n\t<li>给定的输入 <strong>保证</strong> 是一棵树，并且 <strong>不会有重复的边</strong></li>\n</ul>\n", "en": "<p>A tree is an undirected graph in which any two vertices are connected by&nbsp;<i>exactly</i>&nbsp;one path. In other words, any connected graph without simple cycles is a tree.</p>\n\n<p>Given a tree of <code>n</code> nodes&nbsp;labelled from <code>0</code> to <code>n - 1</code>, and an array of&nbsp;<code>n - 1</code>&nbsp;<code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an undirected edge between the two nodes&nbsp;<code>a<sub>i</sub></code> and&nbsp;<code>b<sub>i</sub></code> in the tree,&nbsp;you can choose any node of the tree as the root. When you select a node <code>x</code> as the root, the result tree has height <code>h</code>. Among all possible rooted trees, those with minimum height (i.e. <code>min(h)</code>)&nbsp; are called <strong>minimum height trees</strong> (MHTs).</p>\n\n<p>Return <em>a list of all <strong>MHTs&#39;</strong> root labels</em>.&nbsp;You can return the answer in <strong>any order</strong>.</p>\n\n<p>The <strong>height</strong> of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/e1.jpg\" style=\"width: 800px; height: 213px;\" />\n<pre>\n<strong>Input:</strong> n = 4, edges = [[1,0],[1,2],[1,3]]\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/01/e2.jpg\" style=\"width: 800px; height: 321px;\" />\n<pre>\n<strong>Input:</strong> n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]\n<strong>Output:</strong> [3,4]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt; n</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>All the pairs <code>(a<sub>i</sub>, b<sub>i</sub>)</code> are distinct.</li>\n\t<li>The given input is <strong>guaranteed</strong> to be a tree and there will be <strong>no repeated</strong> edges.</li>\n</ul>\n"}}, "311": {"__typename": "QuestionLightNode", "acRate": 0.7558534102477096, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "311", "isFavor": false, "solutionNum": 97, "title": "Sparse Matrix Multiplication", "titleCn": "稀疏矩阵的乘法", "titleSlug": "sparse-matrix-multiplication", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 35, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "312": {"__typename": "QuestionLightNode", "acRate": 0.6997608518002211, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "312", "isFavor": false, "solutionNum": 704, "title": "Burst Balloons", "titleCn": "戳气球", "titleSlug": "burst-balloons", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 46, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/25ef7004b08edb8c72e8ce7d36d490025c6246c908e5888805f29798acf391ca-logo-samsung-1-normal-636.png", "slug": "samsung", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组&nbsp;<code>nums</code>&nbsp;中。</p>\n\n<p>现在要求你戳破所有的气球。戳破第 <code>i</code> 个气球，你可以获得&nbsp;<code>nums[i - 1] * nums[i] * nums[i + 1]</code> 枚硬币。&nbsp;这里的 <code>i - 1</code> 和 <code>i + 1</code> 代表和&nbsp;<code>i</code>&nbsp;相邻的两个气球的序号。如果 <code>i - 1</code>或 <code>i + 1</code> 超出了数组的边界，那么就当它是一个数字为 <code>1</code> 的气球。</p>\n\n<p>求所能获得硬币的最大数量。</p>\n\n<p>&nbsp;</p>\n<strong>示例 1：</strong>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,5,8]\n<strong>输出：</strong>167\n<strong>解释：</strong>\nnums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5]\n<strong>输出：</strong>10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 300</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n", "en": "<p>You are given <code>n</code> balloons, indexed from <code>0</code> to <code>n - 1</code>. Each balloon is painted with a number on it represented by an array <code>nums</code>. You are asked to burst all the balloons.</p>\n\n<p>If you burst the <code>i<sup>th</sup></code> balloon, you will get <code>nums[i - 1] * nums[i] * nums[i + 1]</code> coins. If <code>i - 1</code> or <code>i + 1</code> goes out of bounds of the array, then treat it as if there is a balloon with a <code>1</code> painted on it.</p>\n\n<p>Return <em>the maximum coins you can collect by bursting the balloons wisely</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,5,8]\n<strong>Output:</strong> 167\n<strong>Explanation:</strong>\nnums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5]\n<strong>Output:</strong> 10\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 300</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n"}}, "313": {"__typename": "QuestionLightNode", "acRate": 0.5552315236731329, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "313", "isFavor": false, "solutionNum": 526, "title": "Super Ugly Number", "titleCn": "超级丑数", "titleSlug": "super-ugly-number", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 22, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><strong>超级丑数</strong> 是一个正整数，并满足其所有质因数都出现在质数数组 <code>primes</code> 中。</p>\n\n<p>给你一个整数 <code>n</code> 和一个整数数组 <code>primes</code> ，返回第 <code>n</code> 个 <strong>超级丑数</strong> 。</p>\n\n<p>题目数据保证第 <code>n</code> 个 <strong>超级丑数</strong> 在 <strong>32-bit</strong> 带符号整数范围内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 12, <code>primes</code> = <code>[2,7,13,19]</code>\n<strong>输出：</strong>32 \n<strong>解释：</strong>给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, primes = [2,3,5]\n<strong>输出：</strong>1\n<strong>解释：</strong>1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。\n</pre>\n&nbsp;\n\n<div class=\"top-view__1vxA\">\n<div class=\"original__bRMd\">\n<div>\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= primes.length &lt;= 100</code></li>\n\t<li><code>2 &lt;= primes[i] &lt;= 1000</code></li>\n\t<li>题目数据<strong> 保证</strong> <code>primes[i]</code> 是一个质数</li>\n\t<li><code>primes</code> 中的所有值都 <strong>互不相同</strong> ，且按 <strong>递增顺序</strong> 排列</li>\n</ul>\n</div>\n</div>\n</div>\n", "en": "<p>A <strong>super ugly number</strong> is a positive integer whose prime factors are in the array <code>primes</code>.</p>\n\n<p>Given an integer <code>n</code> and an array of integers <code>primes</code>, return <em>the</em> <code>n<sup>th</sup></code> <em><strong>super ugly number</strong></em>.</p>\n\n<p>The <code>n<sup>th</sup></code> <strong>super ugly number</strong> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> signed integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 12, primes = [2,7,13,19]\n<strong>Output:</strong> 32\n<strong>Explanation:</strong> [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, primes = [2,3,5]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= primes.length &lt;= 100</code></li>\n\t<li><code>2 &lt;= primes[i] &lt;= 1000</code></li>\n\t<li><code>primes[i]</code> is <strong>guaranteed</strong> to be a prime number.</li>\n\t<li>All the values of <code>primes</code> are <strong>unique</strong> and sorted in <strong>ascending order</strong>.</li>\n</ul>\n"}}, "314": {"__typename": "QuestionLightNode", "acRate": 0.5638024935859927, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "314", "isFavor": false, "solutionNum": 196, "title": "Binary Tree Vertical Order Traversal", "titleCn": "二叉树的垂直遍历", "titleSlug": "binary-tree-vertical-order-traversal", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 38, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "315": {"__typename": "QuestionLightNode", "acRate": 0.4365822676816032, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "315", "isFavor": false, "solutionNum": 865, "title": "Count of Smaller Numbers After Self", "titleCn": "计算右侧小于当前元素的个数", "titleSlug": "count-of-smaller-numbers-after-self", "topicTags": [{"id": "n16hs", "name": "Binary Indexed Tree", "slug": "binary-indexed-tree", "nameTranslated": "树状数组", "__typename": "CommonTagNode"}, {"id": "nytfd", "name": "Segment Tree", "slug": "segment-tree", "nameTranslated": "线段树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "qwy9jd", "name": "Ordered Set", "slug": "ordered-set", "nameTranslated": "有序集合", "__typename": "CommonTagNode"}, {"id": "xp2r1vv", "name": "Merge Sort", "slug": "merge-sort", "nameTranslated": "归并排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 50, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code><em> </em>，按要求返回一个新数组&nbsp;<code>counts</code><em> </em>。数组 <code>counts</code> 有该性质： <code>counts[i]</code> 的值是&nbsp; <code>nums[i]</code> 右侧小于&nbsp;<code>nums[i]</code> 的元素的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,2,6,1]\n<strong>输出：</strong><code>[2,1,1,0] \n<strong>解释：</strong></code>\n5 的右侧有 <strong>2 </strong>个更小的元素 (2 和 1)\n2 的右侧仅有 <strong>1 </strong>个更小的元素 (1)\n6 的右侧有 <strong>1 </strong>个更小的元素 (1)\n1 的右侧有 <strong>0 </strong>个更小的元素\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1]\n<strong>输出：</strong>[0]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,-1]\n<strong>输出：</strong>[0,0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code>, return<em> an integer array </em><code>counts</code><em> where </em><code>counts[i]</code><em> is the number of smaller elements to the right of </em><code>nums[i]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,2,6,1]\n<strong>Output:</strong> [2,1,1,0]\n<strong>Explanation:</strong>\nTo the right of 5 there are <b>2</b> smaller elements (2 and 1).\nTo the right of 2 there is only <b>1</b> smaller element (1).\nTo the right of 6 there is <b>1</b> smaller element (1).\nTo the right of 1 there is <b>0</b> smaller element.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1]\n<strong>Output:</strong> [0]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-1]\n<strong>Output:</strong> [0,0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "316": {"__typename": "QuestionLightNode", "acRate": 0.4890419672415538, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "316", "isFavor": false, "solutionNum": 969, "title": "Remove Duplicate Letters", "titleCn": "去除重复字母", "titleSlug": "remove-duplicate-letters", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "xeyj5r5", "name": "Monotonic Stack", "slug": "monotonic-stack", "nameTranslated": "单调栈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 55, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 <strong>返回结果的<span data-keyword=\"lexicographically-smaller-string-alien\">字典序</span>最小</strong>（要求不能打乱其他字符的相对位置）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>s = \"bcabc\"</code>\n<strong>输出<code>：</code></strong><code>\"abc\"</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong><code>s = \"cbacdcbc\"</code>\n<strong>输出：</strong><code>\"acdb\"</code></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>该题与 1081 <a href=\"https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters\">https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters</a> 相同</p>\n", "en": "<p>Given a string <code>s</code>, remove duplicate letters so that every letter appears once and only once. You must make sure your result is <span data-keyword=\"lexicographically-smaller-string\"><strong>the smallest in lexicographical order</strong></span> among all possible results.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bcabc&quot;\n<strong>Output:</strong> &quot;abc&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cbacdcbc&quot;\n<strong>Output:</strong> &quot;acdb&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as 1081: <a href=\"https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/\" target=\"_blank\">https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/</a></p>\n"}}, "317": {"__typename": "QuestionLightNode", "acRate": 0.47587045941718326, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "317", "isFavor": false, "solutionNum": 101, "title": "Shortest Distance from All Buildings", "titleCn": "离建筑物最近的距离", "titleSlug": "shortest-distance-from-all-buildings", "topicTags": [{"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 25, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "318": {"__typename": "QuestionLightNode", "acRate": 0.7184731414032802, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "318", "isFavor": false, "solutionNum": 780, "title": "Maximum Product of Word Lengths", "titleCn": "最大单词长度乘积", "titleSlug": "maximum-product-of-word-lengths", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 22, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串数组&nbsp;<code>words</code> ，找出并返回 <code>length(words[i]) * length(words[j])</code>&nbsp;的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = <code>[\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]</code>\n<strong>输出：</strong><code>16 \n<strong>解释</strong></code><strong>：</strong><code>这两个单词为<strong> </strong>\"abcw\", \"xtfn\"</code>。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = <code>[\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]</code>\n<strong>输出：</strong><code>4 \n<strong>解释</strong></code><strong>：</strong>这两个单词为 <code>\"ab\", \"cd\"</code>。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = <code>[\"a\",\"aa\",\"aaa\",\"aaaa\"]</code>\n<strong>输出：</strong><code>0 \n<strong>解释</strong></code><strong>：</strong><code>不存在这样的两个单词。</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>\n\t<li><code>words[i]</code>&nbsp;仅包含小写字母</li>\n</ul>\n", "en": "<p>Given a string array <code>words</code>, return <em>the maximum value of</em> <code>length(word[i]) * length(word[j])</code> <em>where the two words do not share common letters</em>. If no such two words exist, return <code>0</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]\n<strong>Output:</strong> 16\n<strong>Explanation:</strong> The two words can be &quot;abcw&quot;, &quot;xtfn&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The two words can be &quot;ab&quot;, &quot;cd&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> No such pair of words.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>\n\t<li><code>words[i]</code> consists only of lowercase English letters.</li>\n</ul>\n"}}, "319": {"__typename": "QuestionLightNode", "acRate": 0.5778505690599972, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "319", "isFavor": false, "solutionNum": 560, "title": "Bulb Switcher", "titleCn": "灯泡开关", "titleSlug": "bulb-switcher", "topicTags": [{"id": "njnym", "name": "Brainteaser", "slug": "brainteaser", "nameTranslated": "脑筋急转弯", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 38, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>初始时有&nbsp;<code>n</code><em> </em>个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。</p>\n\n<p>第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第 <code>i</code> 轮，你每 <code>i</code> 个灯泡就切换第 <code>i</code> 个灯泡的开关。直到第 <code>n</code> 轮，你只需要切换最后一个灯泡的开关。</p>\n\n<p>找出并返回 <code>n</code><em>&nbsp;</em>轮后有多少个亮着的灯泡。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/bulb.jpg\" style=\"width: 421px; height: 321px;\" /></p>\n\n<pre>\n<strong>输入：</strong>n =<strong> </strong>3\n<strong>输出：</strong>1 \n<strong>解释：</strong>\n初始时, 灯泡状态 <strong>[关闭, 关闭, 关闭]</strong>.\n第一轮后, 灯泡状态 <strong>[开启, 开启, 开启]</strong>.\n第二轮后, 灯泡状态 <strong>[开启, 关闭, 开启]</strong>.\n第三轮后, 灯泡状态 <strong>[开启, 关闭, 关闭]</strong>. \n\n你应该返回 1，因为只有一个灯泡还亮着。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 0\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>There are <code>n</code> bulbs that are initially off. You first turn on all the bulbs, then&nbsp;you turn off every second bulb.</p>\n\n<p>On the third round, you toggle every third bulb (turning on if it&#39;s off or turning off if it&#39;s on). For the <code>i<sup>th</sup></code> round, you toggle every <code>i</code> bulb. For the <code>n<sup>th</sup></code> round, you only toggle the last bulb.</p>\n\n<p>Return <em>the number of bulbs that are on after <code>n</code> rounds</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/05/bulb.jpg\" style=\"width: 421px; height: 321px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off]. \nSo you should return 1 because there is only one bulb is on.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "320": {"__typename": "QuestionLightNode", "acRate": 0.6993045138415382, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "320", "isFavor": false, "solutionNum": 84, "title": "Generalized Abbreviation", "titleCn": "列举单词的全部缩写", "titleSlug": "generalized-abbreviation", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "321": {"__typename": "QuestionLightNode", "acRate": 0.4213129544127793, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "321", "isFavor": false, "solutionNum": 325, "title": "Create Maximum Number", "titleCn": "拼接最大数", "titleSlug": "create-maximum-number", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "xeyj5r5", "name": "Monotonic Stack", "slug": "monotonic-stack", "nameTranslated": "单调栈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 27, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code>，它们的长度分别为 <code>m</code> 和 <code>n</code>。数组 <code>nums1</code> 和 <code>nums2</code> 分别代表两个数各位上的数字。同时你也会得到一个整数 <code>k</code>。</p>\n\n<p>请你利用这两个数组中的数字中创建一个长度为 <code>k &lt;= m + n</code> 的最大数，在这个必须保留来自同一数组的数字的相对顺序。</p>\n\n<p>返回代表答案的长度为 <code>k</code> 的数组。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\n<strong>输出：</strong>[9,8,6,5,3]\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [6,7], nums2 = [6,0,4], k = 5\n<strong>输出：</strong>[6,7,6,0,4]\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [3,9], nums2 = [8,9], k = 3\n<strong>输出：</strong>[9,8,9]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 9</code></li>\n\t<li><code>1 &lt;= k &lt;= m + n</code></li>\n</ul>\n", "en": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> of lengths <code>m</code> and <code>n</code> respectively. <code>nums1</code> and <code>nums2</code> represent the digits of two numbers. You are also given an integer <code>k</code>.</p>\n\n<p>Create the maximum number of length <code>k &lt;= m + n</code> from digits of the two numbers. The relative order of the digits from the same array must be preserved.</p>\n\n<p>Return an array of the <code>k</code> digits representing the answer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\n<strong>Output:</strong> [9,8,6,5,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [6,7], nums2 = [6,0,4], k = 5\n<strong>Output:</strong> [6,7,6,0,4]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [3,9], nums2 = [8,9], k = 3\n<strong>Output:</strong> [9,8,9]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 9</code></li>\n\t<li><code>1 &lt;= k &lt;= m + n</code></li>\n</ul>\n"}}, "322": {"__typename": "QuestionLightNode", "acRate": 0.48073763521074225, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "322", "isFavor": false, "solutionNum": 4042, "title": "Coin Change", "titleCn": "零钱兑换", "titleSlug": "coin-change", "topicTags": [{"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 129, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>\n\n<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回&nbsp;<code>-1</code> 。</p>\n\n<p>你可以认为每种硬币的数量是无限的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = <code>[1, 2, 5]</code>, amount = <code>11</code>\n<strong>输出：</strong><code>3</code> \n<strong>解释：</strong>11 = 5 + 5 + 1</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = <code>[2]</code>, amount = <code>3</code>\n<strong>输出：</strong>-1</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>coins = [1], amount = 0\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= coins.length &lt;= 12</code></li>\n\t<li><code>1 &lt;= coins[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 &lt;= amount &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p>\n\n<p>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>\n\n<p>You may assume that you have an infinite number of each kind of coin.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> coins = [1,2,5], amount = 11\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 11 = 5 + 5 + 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> coins = [2], amount = 3\n<strong>Output:</strong> -1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> coins = [1], amount = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= coins.length &lt;= 12</code></li>\n\t<li><code>1 &lt;= coins[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>0 &lt;= amount &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "323": {"__typename": "QuestionLightNode", "acRate": 0.6531843521490456, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "323", "isFavor": false, "solutionNum": 367, "title": "Number of Connected Components in an Undirected Graph", "titleCn": "无向图中连通分量的数目", "titleSlug": "number-of-connected-components-in-an-undirected-graph", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "n6a2i", "name": "Union Find", "slug": "union-find", "nameTranslated": "并查集", "__typename": "CommonTagNode"}, {"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 40, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "324": {"__typename": "QuestionLightNode", "acRate": 0.4093442961415611, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "324", "isFavor": false, "solutionNum": 422, "title": "Wiggle Sort II", "titleCn": "摆动排序 II", "titleSlug": "wiggle-sort-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "gl65v1", "name": "Quickselect", "slug": "quickselect", "nameTranslated": "快速选择", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 29, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/99a45f957529ef9ac7be507962ccee294f53b3cd87dc8163d18f16c1228e4a70-belo-cn-200x200-9518747d43e25d1834cda4cbe55464c5.png", "slug": "airbnb", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code>，将它重新排列成 <code>nums[0] < nums[1] > nums[2] < nums[3]...</code> 的顺序。</p>\n\n<p>你可以假设所有输入数组都可以得到满足题目要求的结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,1,1,6,4]\n<strong>输出：</strong>[1,6,1,5,1,4]\n<strong>解释：</strong>[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2,2,3,1]\n<strong>输出：</strong>[2,3,1,3,1,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 <= nums[i] <= 5000</code></li>\n\t<li>题目数据保证，对于给定的输入 <code>nums</code> ，总能产生满足题目要求的结果</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？</p>\n", "en": "<p>Given an integer array <code>nums</code>, reorder it such that <code>nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...</code>.</p>\n\n<p>You may assume the input array always has a valid answer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,1,1,6,4]\n<strong>Output:</strong> [1,6,1,5,1,4]\n<strong>Explanation:</strong> [1,4,1,5,1,6] is also accepted.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,2,2,3,1]\n<strong>Output:</strong> [2,3,1,3,1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li>It is guaranteed that there will be an answer for the given input <code>nums</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow Up:</strong> Can you do it in <code>O(n)</code> time and/or <strong>in-place</strong> with <code>O(1)</code> extra space?"}}, "325": {"__typename": "QuestionLightNode", "acRate": 0.5153794342164346, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "325", "isFavor": false, "solutionNum": 199, "title": "Maximum Size Subarray Sum Equals k", "titleCn": "和等于 k 的最长子数组长度", "titleSlug": "maximum-size-subarray-sum-equals-k", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 36, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "326": {"__typename": "QuestionLightNode", "acRate": 0.5136386963215531, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "326", "isFavor": false, "solutionNum": 1028, "title": "Power of Three", "titleCn": "3 的幂", "titleSlug": "power-of-three", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 28, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个整数，写一个函数来判断它是否是 3&nbsp;的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>整数 <code>n</code> 是 3 的幂次方需满足：存在整数 <code>x</code> 使得 <code>n == 3<sup>x</sup></code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 27\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 0\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 9\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 45\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能不使用循环或者递归来完成本题吗？</p>\n", "en": "<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of three. Otherwise, return <code>false</code></em>.</p>\n\n<p>An integer <code>n</code> is a power of three, if there exists an integer <code>x</code> such that <code>n == 3<sup>x</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 27\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 27 = 3<sup>3</sup>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no x where 3<sup>x</sup> = 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = -1\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no x where 3<sup>x</sup> = (-1).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without loops/recursion?"}}, "327": {"__typename": "QuestionLightNode", "acRate": 0.4042470633884793, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "327", "isFavor": false, "solutionNum": 381, "title": "Count of Range Sum", "titleCn": "区间和的个数", "titleSlug": "count-of-range-sum", "topicTags": [{"id": "n16hs", "name": "Binary Indexed Tree", "slug": "binary-indexed-tree", "nameTranslated": "树状数组", "__typename": "CommonTagNode"}, {"id": "nytfd", "name": "Segment Tree", "slug": "segment-tree", "nameTranslated": "线段树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "qwy9jd", "name": "Ordered Set", "slug": "ordered-set", "nameTranslated": "有序集合", "__typename": "CommonTagNode"}, {"id": "xp2r1vv", "name": "Merge Sort", "slug": "merge-sort", "nameTranslated": "归并排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 19, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> 以及两个整数 <code>lower</code> 和 <code>upper</code> 。求数组中，值位于范围 <code>[lower, upper]</code> （包含 <code>lower</code> 和 <code>upper</code>）之内的 <strong>区间和的个数</strong> 。</p>\n\n<p><strong>区间和</strong> <code>S(i, j)</code> 表示在 <code>nums</code> 中，位置从 <code>i</code> 到 <code>j</code> 的元素之和，包含 <code>i</code> 和 <code>j</code> (<code>i</code> ≤ <code>j</code>)。</p>\n\n<p> </p>\n<strong>示例 1：</strong>\n\n<pre>\n<strong>输入：</strong>nums = [-2,5,-1], lower = -2, upper = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [0], lower = 0, upper = 0\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1</code></li>\n\t<li><code>-10<sup>5</sup> <= lower <= upper <= 10<sup>5</sup></code></li>\n\t<li>题目数据保证答案是一个 <strong>32 位</strong> 的整数</li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> and two integers <code>lower</code> and <code>upper</code>, return <em>the number of range sums that lie in</em> <code>[lower, upper]</code> <em>inclusive</em>.</p>\n\n<p>Range sum <code>S(i, j)</code> is defined as the sum of the elements in <code>nums</code> between indices <code>i</code> and <code>j</code> inclusive, where <code>i &lt;= j</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-2,5,-1], lower = -2, upper = 2\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0], lower = 0, upper = 0\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= lower &lt;= upper &lt;= 10<sup>5</sup></code></li>\n\t<li>The answer is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n"}}, "328": {"__typename": "QuestionLightNode", "acRate": 0.6457129922054404, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "328", "isFavor": false, "solutionNum": 1738, "title": "Odd Even Linked List", "titleCn": "奇偶链表", "titleSlug": "odd-even-linked-list", "topicTags": [{"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 53, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1711090840-jlSkmv-capital one.png", "slug": "capital-one", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定单链表的头节点&nbsp;<code>head</code>&nbsp;，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p>\n\n<p><strong>第一个</strong>节点的索引被认为是 <strong>奇数</strong> ， <strong>第二个</strong>节点的索引为&nbsp;<strong>偶数</strong> ，以此类推。</p>\n\n<p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p>\n\n<p>你必须在&nbsp;<code>O(1)</code>&nbsp;的额外空间复杂度和&nbsp;<code>O(n)</code>&nbsp;的时间复杂度下解决这个问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg\" style=\"height: 123px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入: </strong>head = [1,2,3,4,5]\n<strong>输出:</strong>&nbsp;[1,3,5,2,4]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg\" style=\"height: 142px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> head = [2,1,3,5,6,4,7]\n<strong>输出:</strong> [2,3,6,7,1,5,4]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n ==&nbsp;</code> 链表中的节点数</li>\n\t<li><code>0 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>6</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n</ul>\n", "en": "<p>Given the <code>head</code> of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return <em>the reordered list</em>.</p>\n\n<p>The <strong>first</strong> node is considered <strong>odd</strong>, and the <strong>second</strong> node is <strong>even</strong>, and so on.</p>\n\n<p>Note that the relative order inside both the even and odd groups should remain as it was in the input.</p>\n\n<p>You must solve the problem&nbsp;in <code>O(1)</code>&nbsp;extra space complexity and <code>O(n)</code> time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg\" style=\"width: 300px; height: 123px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5]\n<strong>Output:</strong> [1,3,5,2,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg\" style=\"width: 500px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [2,1,3,5,6,4,7]\n<strong>Output:</strong> [2,3,6,7,1,5,4]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the linked list is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>6</sup> &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n</ul>\n"}}, "329": {"__typename": "QuestionLightNode", "acRate": 0.5206704560886182, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "329", "isFavor": false, "solutionNum": 895, "title": "Longest Increasing Path in a Matrix", "titleCn": "矩阵中的最长递增路径", "titleSlug": "longest-increasing-path-in-a-matrix", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}, {"id": "ns19t", "name": "Topological Sort", "slug": "topological-sort", "nameTranslated": "拓扑排序", "__typename": "CommonTagNode"}, {"id": "vhos7", "name": "Memoization", "slug": "memoization", "nameTranslated": "记忆化搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 55, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度。</p>\n\n<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[9,9,4],[6,6,8],[2,1,1]]\n<strong>输出：</strong>4 \n<strong>解释：</strong>最长递增路径为 <code>[1, 2, 6, 9]</code>。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[3,4,5],[3,2,6],[2,2,1]]\n<strong>输出：</strong>4 \n<strong>解释：</strong>最长递增路径是 <code>[3, 4, 5, 6]</code>。注意不允许在对角线方向上移动。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1]]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 200</code></li>\n\t<li><code>0 <= matrix[i][j] <= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given an <code>m x n</code> integers <code>matrix</code>, return <em>the length of the longest increasing path in </em><code>matrix</code>.</p>\n\n<p>From each cell, you can either move in four directions: left, right, up, or down. You <strong>may not</strong> move <strong>diagonally</strong> or move <strong>outside the boundary</strong> (i.e., wrap-around is not allowed).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[9,9,4],[6,6,8],[2,1,1]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The longest increasing path is <code>[1, 2, 6, 9]</code>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[3,4,5],[3,2,6],[2,2,1]]\n<strong>Output:</strong> 4\n<strong>Explanation: </strong>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[1]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= matrix[i][j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "330": {"__typename": "QuestionLightNode", "acRate": 0.5301780104712042, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "330", "isFavor": false, "solutionNum": 209, "title": "Patching Array", "titleCn": "按要求补齐数组", "titleSlug": "patching-array", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个已排序的正整数数组 <code>nums</code>&nbsp;<em>，</em>和一个正整数&nbsp;<code>n</code><em> 。</em>从&nbsp;<code>[1, n]</code>&nbsp;区间内选取任意个数字补充到&nbsp;nums&nbsp;中，使得&nbsp;<code>[1, n]</code>&nbsp;区间内的任何数字都可以用&nbsp;nums&nbsp;中某几个数字的和来表示。</p>\n\n<p>请返回 <em>满足上述要求的最少需要补充的数字个数</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入: </strong>nums = <code>[1,3]</code>, n = <code>6</code>\n<strong>输出: </strong>1 \n<strong>解释:</strong>\n根据 nums&nbsp;里现有的组合&nbsp;<code>[1], [3], [1,3]</code>，可以得出&nbsp;<code>1, 3, 4</code>。\n现在如果我们将&nbsp;<code>2</code>&nbsp;添加到&nbsp;nums 中，&nbsp;组合变为: <code>[1], [2], [3], [1,3], [2,3], [1,2,3]</code>。\n其和可以表示数字&nbsp;<code>1, 2, 3, 4, 5, 6</code>，能够覆盖&nbsp;<code>[1, 6]</code>&nbsp;区间里所有的数。\n所以我们最少需要添加一个数字。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>nums = <code>[1,5,10]</code>, n = <code>20</code>\n<strong>输出:</strong> 2\n<strong>解释: </strong>我们需要添加&nbsp;<code>[2,4]</code>。\n</pre>\n\n<p><strong>示例&nbsp;3:</strong></p>\n\n<pre>\n<strong>输入: </strong>nums = <code>[1,2,2]</code>, n = <code>5</code>\n<strong>输出:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code>&nbsp;按 <strong>升序排列</strong></li>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n", "en": "<p>Given a sorted integer array <code>nums</code> and an integer <code>n</code>, add/patch elements to the array such that any number in the range <code>[1, n]</code> inclusive can be formed by the sum of some elements in the array.</p>\n\n<p>Return <em>the minimum number of patches required</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3], n = 6\n<strong>Output:</strong> 1\nExplanation:\nCombinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\nSo we only need 1 patch.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,10], n = 20\n<strong>Output:</strong> 2\nExplanation: The two patches can be [2, 4].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,2], n = 5\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is sorted in <strong>ascending order</strong>.</li>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "331": {"__typename": "QuestionLightNode", "acRate": 0.4929505076142132, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "331", "isFavor": false, "solutionNum": 770, "title": "Verify Preorder Serialization of a Binary Tree", "titleCn": "验证二叉树的前序序列化", "titleSlug": "verify-preorder-serialization-of-a-binary-tree", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 24, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>序列化二叉树的一种方法是使用 <strong>前序遍历 </strong>。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg\" /></p>\n\n<p>例如，上面的二叉树可以被序列化为字符串 <code>\"9,3,4,#,#,1,#,#,2,#,6,#,#\"</code>，其中 <code>#</code> 代表一个空节点。</p>\n\n<p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p>\n\n<p><strong>保证</strong> 每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>'#'</code> 。</p>\n\n<p>你可以认为输入格式总是有效的</p>\n\n<ul>\n\t<li>例如它永远不会包含两个连续的逗号，比如&nbsp;<code>\"1,,3\"</code> 。</li>\n</ul>\n\n<p><strong>注意：</strong>不允许重建树。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>preorder = <code>\"9,3,4,#,#,1,#,#,2,#,6,#,#\"</code>\n<strong>输出: </strong><code>true</code></pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入: </strong>preorder = <code>\"1,#\"</code>\n<strong>输出: </strong><code>false</code>\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>preorder = <code>\"9,#,#,1\"</code>\n<strong>输出: </strong><code>false</code>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>preorder</code>&nbsp;由以逗号&nbsp;<code>“，”</code> 分隔的 <code>[0,100]</code> 范围内的整数和 <code>“#”</code> 组成</li>\n</ul>\n", "en": "<p>One way to serialize a binary tree is to use <strong>preorder traversal</strong>. When we encounter a non-null node, we record the node&#39;s value. If it is a null node, we record using a sentinel value such as <code>&#39;#&#39;</code>.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg\" style=\"width: 362px; height: 293px;\" />\n<p>For example, the above binary tree can be serialized to the string <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>, where <code>&#39;#&#39;</code> represents a null node.</p>\n\n<p>Given a string of comma-separated values <code>preorder</code>, return <code>true</code> if it is a correct preorder traversal serialization of a binary tree.</p>\n\n<p>It is <strong>guaranteed</strong> that each comma-separated value in the string must be either an integer or a character <code>&#39;#&#39;</code> representing null pointer.</p>\n\n<p>You may assume that the input format is always valid.</p>\n\n<ul>\n\t<li>For example, it could never contain two consecutive commas, such as <code>&quot;1,,3&quot;</code>.</li>\n</ul>\n\n<p><strong>Note:&nbsp;</strong>You are not allowed to reconstruct the tree.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> preorder = \"9,3,4,#,#,1,#,#,2,#,6,#,#\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> preorder = \"1,#\"\n<strong>Output:</strong> false\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> preorder = \"9,#,#,1\"\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>preorder</code> consist of integers in the range <code>[0, 100]</code> and <code>&#39;#&#39;</code> separated by commas <code>&#39;,&#39;</code>.</li>\n</ul>\n"}}, "332": {"__typename": "QuestionLightNode", "acRate": 0.45481514298620523, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "332", "isFavor": false, "solutionNum": 688, "title": "Reconstruct Itinerary", "titleCn": "重新安排行程", "titleSlug": "reconstruct-itinerary", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}, {"id": "xp29rlc", "name": "Eulerian Circuit", "slug": "eulerian-circuit", "nameTranslated": "欧拉回路", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 56, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p>\n\n<p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>\n\n<ul>\n\t<li>例如，行程 <code>[\"JFK\", \"LGA\"]</code> 与 <code>[\"JFK\", \"LGB\"]</code> 相比就更小，排序更靠前。</li>\n</ul>\n\n<p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg\" style=\"width: 382px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]\n<strong>输出：</strong>[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg\" style=\"width: 222px; height: 230px;\" />\n<pre>\n<strong>输入：</strong>tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]\n<strong>输出：</strong>[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]\n<strong>解释：</strong>另一种有效的行程是 [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] ，但是它字典排序更大更靠后。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= tickets.length <= 300</code></li>\n\t<li><code>tickets[i].length == 2</code></li>\n\t<li><code>from<sub>i</sub>.length == 3</code></li>\n\t<li><code>to<sub>i</sub>.length == 3</code></li>\n\t<li><code>from<sub>i</sub></code> 和 <code>to<sub>i</sub></code> 由大写英文字母组成</li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n</ul>\n", "en": "<p>You are given a list of airline <code>tickets</code> where <code>tickets[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.</p>\n\n<p>All of the tickets belong to a man who departs from <code>&quot;JFK&quot;</code>, thus, the itinerary must begin with <code>&quot;JFK&quot;</code>. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.</p>\n\n<ul>\n\t<li>For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.</li>\n</ul>\n\n<p>You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg\" style=\"width: 382px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]\n<strong>Output:</strong> [&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg\" style=\"width: 222px; height: 230px;\" />\n<pre>\n<strong>Input:</strong> tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]\n<strong>Output:</strong> [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]\n<strong>Explanation:</strong> Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] but it is larger in lexical order.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tickets.length &lt;= 300</code></li>\n\t<li><code>tickets[i].length == 2</code></li>\n\t<li><code>from<sub>i</sub>.length == 3</code></li>\n\t<li><code>to<sub>i</sub>.length == 3</code></li>\n\t<li><code>from<sub>i</sub></code> and <code>to<sub>i</sub></code> consist of uppercase English letters.</li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n</ul>\n"}}, "333": {"__typename": "QuestionLightNode", "acRate": 0.49309627387932664, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "333", "isFavor": false, "solutionNum": 168, "title": "Largest BST Subtree", "titleCn": "最大二叉搜索子树", "titleSlug": "largest-bst-subtree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 16, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "334": {"__typename": "QuestionLightNode", "acRate": 0.42780448810112603, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "334", "isFavor": false, "solutionNum": 924, "title": "Increasing Triplet Subsequence", "titleCn": "递增的三元子序列", "titleSlug": "increasing-triplet-subsequence", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 40, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组&nbsp;<code>nums</code> ，判断这个数组中是否存在长度为 <code>3</code> 的递增子序列。</p>\n\n<p>如果存在这样的三元组下标 <code>(i, j, k)</code>&nbsp;且满足 <code>i &lt; j &lt; k</code> ，使得&nbsp;<code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>任何 i &lt; j &lt; k 的三元组都满足题意\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5,4,3,2,1]\n<strong>输出：</strong>false\n<strong>解释：</strong>不存在满足题意的三元组</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,1,5,0,4,6]\n<strong>输出：</strong>true\n<strong>解释：</strong>三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能实现时间复杂度为 <code>O(n)</code> ，空间复杂度为 <code>O(1)</code> 的解决方案吗？</p>\n", "en": "<p>Given an integer array <code>nums</code>, return <code>true</code><em> if there exists a triple of indices </em><code>(i, j, k)</code><em> such that </em><code>i &lt; j &lt; k</code><em> and </em><code>nums[i] &lt; nums[j] &lt; nums[k]</code>. If no such indices exists, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Any triplet where i &lt; j &lt; k is valid.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,4,3,2,1]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> No triplet exists.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,1,5,0,4,6]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The triplet (3, 4, 5) is valid because nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you implement a solution that runs in <code>O(n)</code> time complexity and <code>O(1)</code> space complexity?"}}, "335": {"__typename": "QuestionLightNode", "acRate": 0.4249731929885988, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "335", "isFavor": false, "solutionNum": 174, "title": "Self Crossing", "titleCn": "路径交叉", "titleSlug": "self-crossing", "topicTags": [{"id": "vlt55", "name": "Geometry", "slug": "geometry", "nameTranslated": "几何", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 16, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>distance</code><em> </em>。</p>\n\n<p>从 <strong>X-Y</strong> 平面上的点&nbsp;<code>(0,0)</code>&nbsp;开始，先向北移动 <code>distance[0]</code> 米，然后向西移动 <code>distance[1]</code> 米，向南移动 <code>distance[2]</code> 米，向东移动 <code>distance[3]</code> 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。</p>\n\n<p>判断你所经过的路径是否相交。如果相交，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/selfcross1-plane.jpg\" style=\"width: 400px; height: 435px;\" />\n<pre>\n<strong>输入：</strong>distance = [2,1,1,2]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/selfcross2-plane.jpg\" style=\"width: 400px; height: 435px;\" />\n<pre>\n<strong>输入：</strong>distance = [1,2,3,4]\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/14/selfcross3-plane.jpg\" style=\"width: 400px; height: 435px;\" />\n<pre>\n<strong>输入：</strong>distance = [1,1,1,1]\n<strong>输出：</strong>true</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;distance.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;=&nbsp;distance[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>You are given an array of integers <code>distance</code>.</p>\n\n<p>You start at the point <code>(0, 0)</code> on an <strong>X-Y plane,</strong> and you move <code>distance[0]</code> meters to the north, then <code>distance[1]</code> meters to the west, <code>distance[2]</code> meters to the south, <code>distance[3]</code> meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.</p>\n\n<p>Return <code>true</code> <em>if your path crosses itself or </em><code>false</code><em> if it does not</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/21/11.jpg\" style=\"width: 400px; height: 413px;\" />\n<pre>\n<strong>Input:</strong> distance = [2,1,1,2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The path crosses itself at the point (0, 1).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/21/22.jpg\" style=\"width: 400px; height: 413px;\" />\n<pre>\n<strong>Input:</strong> distance = [1,2,3,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The path does not cross itself at any point.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/12/21/33.jpg\" style=\"width: 400px; height: 413px;\" />\n<pre>\n<strong>Input:</strong> distance = [1,1,1,2,1]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The path crosses itself at the point (0, 0).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;distance.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;=&nbsp;distance[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "336": {"__typename": "QuestionLightNode", "acRate": 0.3799722418624139, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "336", "isFavor": false, "solutionNum": 257, "title": "Palindrome Pairs", "titleCn": "回文对", "titleSlug": "palindrome-pairs", "topicTags": [{"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 39, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/99a45f957529ef9ac7be507962ccee294f53b3cd87dc8163d18f16c1228e4a70-belo-cn-200x200-9518747d43e25d1834cda4cbe55464c5.png", "slug": "airbnb", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个由唯一字符串构成的 <strong>0 索引&nbsp;</strong>数组 <code>words</code>&nbsp;。</p>\n\n<p><strong>回文对</strong> 是一对整数 <code>(i, j)</code> ，满足以下条件：</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j &lt; words.length</code>，</li>\n\t<li><code>i != j</code> ，并且</li>\n\t<li><code>words[i] + words[j]</code>（两个字符串的连接）是一个<span data-keyword=\"palindrome-string\">回文串</span>。</li>\n</ul>\n\n<p>返回一个数组，它包含&nbsp;<code>words</code> 中所有满足 <strong>回文对</strong> 条件的字符串。</p>\n\n<p>你必须设计一个时间复杂度为 <code>O(sum of words[i].length)</code> 的算法。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\n<strong>输出：</strong>[[0,1],[1,0],[3,2],[2,4]] \n<strong>解释：</strong>可拼接成的回文串为 <code>[\"dcbaabcd\",\"abcddcba\",\"slls\",\"llssssll\"]</code>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"bat\",\"tab\",\"cat\"]\n<strong>输出：</strong>[[0,1],[1,0]] \n<strong>解释：</strong>可拼接成的回文串为 <code>[\"battab\",\"tabbat\"]</code></pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"a\",\"\"]\n<strong>输出：</strong>[[0,1],[1,0]]\n</pre>\n&nbsp;\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= words[i].length &lt;= 300</code></li>\n\t<li><code>words[i]</code> 由小写英文字母组成</li>\n</ul>\n", "en": "<p>You are given a <strong>0-indexed</strong> array of <strong>unique</strong> strings <code>words</code>.</p>\n\n<p>A <strong>palindrome pair</strong> is a pair of integers <code>(i, j)</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j &lt; words.length</code>,</li>\n\t<li><code>i != j</code>, and</li>\n\t<li><code>words[i] + words[j]</code> (the concatenation of the two strings) is a <span data-keyword=\"palindrome-string\">palindrome</span>.</li>\n</ul>\n\n<p>Return <em>an array of all the <strong>palindrome pairs</strong> of </em><code>words</code>.</p>\n\n<p>You must write an algorithm with&nbsp;<code>O(sum of words[i].length)</code>&nbsp;runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;]\n<strong>Output:</strong> [[0,1],[1,0],[3,2],[2,4]]\n<strong>Explanation:</strong> The palindromes are [&quot;abcddcba&quot;,&quot;dcbaabcd&quot;,&quot;slls&quot;,&quot;llssssll&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;]\n<strong>Output:</strong> [[0,1],[1,0]]\n<strong>Explanation:</strong> The palindromes are [&quot;battab&quot;,&quot;tabbat&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;&quot;]\n<strong>Output:</strong> [[0,1],[1,0]]\n<strong>Explanation:</strong> The palindromes are [&quot;a&quot;,&quot;a&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= words[i].length &lt;= 300</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n</ul>\n"}}, "337": {"__typename": "QuestionLightNode", "acRate": 0.6156989424450898, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "337", "isFavor": false, "solutionNum": 2017, "title": "House Robber III", "titleCn": "打家劫舍 III", "titleSlug": "house-robber-iii", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 43, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;。</p>\n\n<p>除了<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p>\n\n<p>给定二叉树的&nbsp;<code>root</code>&nbsp;。返回&nbsp;<em><strong>在不触动警报的情况下</strong>&nbsp;，小偷能够盗取的最高金额</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg\" /></p>\n\n<pre>\n<strong>输入: </strong>root = [3,2,3,null,3,null,1]\n<strong>输出:</strong> 7 \n<strong>解释:</strong>&nbsp;小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg\" /></p>\n\n<pre>\n<strong>输入: </strong>root = [3,4,5,1,3,null,1]\n<strong>输出:</strong> 9\n<strong>解释:</strong>&nbsp;小偷一晚能够盗取的最高金额 4 + 5 = 9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li>树的节点数在&nbsp;<code>[1, 10<sup>4</sup>]</code> 范围内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called <code>root</code>.</p>\n\n<p>Besides the <code>root</code>, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if <strong>two directly-linked houses were broken into on the same night</strong>.</p>\n\n<p>Given the <code>root</code> of the binary tree, return <em>the maximum amount of money the thief can rob <strong>without alerting the police</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg\" style=\"width: 277px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> root = [3,2,3,null,3,null,1]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg\" style=\"width: 357px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> root = [3,4,5,1,3,null,1]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> Maximum amount of money the thief can rob = 4 + 5 = 9.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "338": {"__typename": "QuestionLightNode", "acRate": 0.7869353086139184, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "338", "isFavor": false, "solutionNum": 2406, "title": "Counting Bits", "titleCn": "比特位计数", "titleSlug": "counting-bits", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 36, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数 <code>n</code> ，对于&nbsp;<code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p>\n\n<p>&nbsp;</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>[0,1,1]\n<strong>解释：</strong>\n0 --&gt; 0\n1 --&gt; 1\n2 --&gt; 10\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>[0,1,1,2,1,2]\n<strong>解释：</strong>\n0 --&gt; 0\n1 --&gt; 1\n2 --&gt; 10\n3 --&gt; 11\n4 --&gt; 100\n5 --&gt; 101\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>很容易就能实现时间复杂度为 <code>O(n log n)</code> 的解决方案，你可以在线性时间复杂度 <code>O(n)</code> 内用一趟扫描解决此问题吗？</li>\n\t<li>你能不使用任何内置函数解决此问题吗？（如，C++ 中的&nbsp;<code>__builtin_popcount</code> ）</li>\n</ul>\n</div>\n</div>\n", "en": "<p>Given an integer <code>n</code>, return <em>an array </em><code>ans</code><em> of length </em><code>n + 1</code><em> such that for each </em><code>i</code><em> </em>(<code>0 &lt;= i &lt;= n</code>)<em>, </em><code>ans[i]</code><em> is the <strong>number of </strong></em><code>1</code><em><strong>&#39;s</strong> in the binary representation of </em><code>i</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> [0,1,1]\n<strong>Explanation:</strong>\n0 --&gt; 0\n1 --&gt; 1\n2 --&gt; 10\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> [0,1,1,2,1,2]\n<strong>Explanation:</strong>\n0 --&gt; 0\n1 --&gt; 1\n2 --&gt; 10\n3 --&gt; 11\n4 --&gt; 100\n5 --&gt; 101\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>It is very easy to come up with a solution with a runtime of <code>O(n log n)</code>. Can you do it in linear time <code>O(n)</code> and possibly in a single pass?</li>\n\t<li>Can you do it without using any built-in function (i.e., like <code>__builtin_popcount</code> in C++)?</li>\n</ul>\n"}}, "339": {"__typename": "QuestionLightNode", "acRate": 0.8370860927152318, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "339", "isFavor": false, "solutionNum": 87, "title": "Nested List Weight Sum", "titleCn": "嵌套列表加权和", "titleSlug": "nested-list-weight-sum", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 28, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "340": {"__typename": "QuestionLightNode", "acRate": 0.5130334894406645, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "340", "isFavor": false, "solutionNum": 325, "title": "Longest Substring with At Most K Distinct Characters", "titleCn": "至多包含 K 个不同字符的最长子串", "titleSlug": "longest-substring-with-at-most-k-distinct-characters", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 42, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "341": {"__typename": "QuestionLightNode", "acRate": 0.7276375203378366, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "341", "isFavor": false, "solutionNum": 682, "title": "Flatten Nested List Iterator", "titleCn": "扁平化嵌套列表迭代器", "titleSlug": "flatten-nested-list-iterator", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "vxfk6", "name": "Queue", "slug": "queue", "nameTranslated": "队列", "__typename": "CommonTagNode"}, {"id": "7eks9i", "name": "Iterator", "slug": "iterator", "nameTranslated": "迭代器", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 69, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个嵌套的整数列表 <code>nestedList</code> 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。</p>\n\n<p>实现扁平迭代器类 <code>NestedIterator</code> ：</p>\n\n<ul>\n\t<li><code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> 用嵌套列表 <code>nestedList</code> 初始化迭代器。</li>\n\t<li><code>int next()</code> 返回嵌套列表的下一个整数。</li>\n\t<li><code>boolean hasNext()</code> 如果仍然存在待迭代的整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n\n<p>你的代码将会用下述伪代码检测：</p>\n\n<pre>\ninitialize iterator with nestedList\nres = []\nwhile iterator.hasNext()\n    append iterator.next() to the end of res\nreturn res</pre>\n\n<p>如果 <code>res</code> 与预期的扁平化列表匹配，那么你的代码将会被判为正确。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nestedList = [[1,1],2,[1,1]]\n<strong>输出：</strong>[1,1,2,1,1]\n<strong>解释：</strong>通过重复调用&nbsp;<em>next </em>直到&nbsp;<em>hasNex</em>t 返回 false，<em>next&nbsp;</em>返回的元素的顺序应该是: <code>[1,1,2,1,1]</code>。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nestedList = [1,[4,[6]]]\n<strong>输出：</strong>[1,4,6]\n<strong>解释：</strong>通过重复调用&nbsp;<em>next&nbsp;</em>直到&nbsp;<em>hasNex</em>t 返回 false，<em>next&nbsp;</em>返回的元素的顺序应该是: <code>[1,4,6]</code>。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nestedList.length &lt;= 500</code></li>\n\t<li>嵌套列表中的整数值在范围 <code>[-10<sup>6</sup>, 10<sup>6</sup>]</code> 内</li>\n</ul>\n", "en": "<p>You are given a nested list of integers <code>nestedList</code>. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.</p>\n\n<p>Implement the <code>NestedIterator</code> class:</p>\n\n<ul>\n\t<li><code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> Initializes the iterator with the nested list <code>nestedList</code>.</li>\n\t<li><code>int next()</code> Returns the next integer in the nested list.</li>\n\t<li><code>boolean hasNext()</code> Returns <code>true</code> if there are still some integers in the nested list and <code>false</code> otherwise.</li>\n</ul>\n\n<p>Your code will be tested with the following pseudocode:</p>\n\n<pre>\ninitialize iterator with nestedList\nres = []\nwhile iterator.hasNext()\n    append iterator.next() to the end of res\nreturn res\n</pre>\n\n<p>If <code>res</code> matches the expected flattened list, then your code will be judged as correct.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nestedList = [[1,1],2,[1,1]]\n<strong>Output:</strong> [1,1,2,1,1]\n<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nestedList = [1,[4,[6]]]\n<strong>Output:</strong> [1,4,6]\n<strong>Explanation:</strong> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nestedList.length &lt;= 500</code></li>\n\t<li>The values of the integers in the nested list is in the range <code>[-10<sup>6</sup>, 10<sup>6</sup>]</code>.</li>\n</ul>\n"}}, "342": {"__typename": "QuestionLightNode", "acRate": 0.532786444035354, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "342", "isFavor": false, "solutionNum": 1196, "title": "Power of Four", "titleCn": "4的幂", "titleSlug": "power-of-four", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 24, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/db2c726d9e93256c701c8530c852abbe0b9fa11057ee0a83a775a99b556c872c-two-sigma-logo.png", "slug": "two-sigma", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>整数 <code>n</code> 是 4 的幂次方需满足：存在整数 <code>x</code> 使得 <code>n == 4<sup>x</sup></code></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 16\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能不使用循环或者递归来完成本题吗？</p>\n", "en": "<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of four. Otherwise, return <code>false</code></em>.</p>\n\n<p>An integer <code>n</code> is a power of four, if there exists an integer <code>x</code> such that <code>n == 4<sup>x</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 16\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 5\n<strong>Output:</strong> false\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without loops/recursion?"}}, "343": {"__typename": "QuestionLightNode", "acRate": 0.632213495173357, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "343", "isFavor": false, "solutionNum": 2167, "title": "Integer Break", "titleCn": "整数拆分", "titleSlug": "integer-break", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 40, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个正整数&nbsp;<code>n</code>&nbsp;，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（&nbsp;<code>k &gt;= 2</code>&nbsp;），并使这些整数的乘积最大化。</p>\n\n<p>返回 <em>你可以获得的最大乘积</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>n = 2\n<strong>输出: </strong>1\n<strong>解释: </strong>2 = 1 + 1, 1 × 1 = 1。</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入: </strong>n = 10\n<strong>输出: </strong>36\n<strong>解释: </strong>10 = 3 + 3 + 4, 3 ×&nbsp;3 ×&nbsp;4 = 36。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 58</code></li>\n</ul>\n", "en": "<p>Given an integer <code>n</code>, break it into the sum of <code>k</code> <strong>positive integers</strong>, where <code>k &gt;= 2</code>, and maximize the product of those integers.</p>\n\n<p>Return <em>the maximum product you can get</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> 2 = 1 + 1, 1 &times; 1 = 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> 36\n<strong>Explanation:</strong> 10 = 3 + 3 + 4, 3 &times; 3 &times; 4 = 36.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 58</code></li>\n</ul>\n"}}, "344": {"__typename": "QuestionLightNode", "acRate": 0.8020607210286604, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "344", "isFavor": false, "solutionNum": 4119, "title": "Reverse String", "titleCn": "反转字符串", "titleSlug": "reverse-string", "topicTags": [{"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 107, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p>\n\n<p>不要给另外的数组分配额外的空间，你必须<strong><a href=\"https://baike.baidu.com/item/原地算法\" target=\"_blank\">原地</a>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n<strong>输出：</strong>[\"o\",\"l\",\"l\",\"e\",\"h\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n<strong>输出：</strong>[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 都是 <a href=\"https://baike.baidu.com/item/ASCII\" target=\"_blank\">ASCII</a> 码表中的可打印字符</li>\n</ul>\n", "en": "<p>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p>\n\n<p>You must do this by modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a> with <code>O(1)</code> extra memory.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n<strong>Output:</strong> [\"o\",\"l\",\"l\",\"e\",\"h\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n<strong>Output:</strong> [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is a <a href=\"https://en.wikipedia.org/wiki/ASCII#Printable_characters\" target=\"_blank\">printable ascii character</a>.</li>\n</ul>\n"}}, "345": {"__typename": "QuestionLightNode", "acRate": 0.5476539243018476, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "345", "isFavor": false, "solutionNum": 1636, "title": "Reverse Vowels of a String", "titleCn": "反转字符串中的元音字母", "titleSlug": "reverse-vowels-of-a-string", "topicTags": [{"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 44, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code> ，仅反转字符串中的所有元音字母，并返回结果字符串。</p>\n\n<p>元音字母包括 <code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code>、<code>'u'</code>，且可能以大小写两种形式出现不止一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"hello\"\n<strong>输出：</strong>\"holle\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"leetcode\"\n<strong>输出：</strong>\"leotcede\"</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由 <strong>可打印的 ASCII</strong> 字符组成</li>\n</ul>\n", "en": "<p>Given a string <code>s</code>, reverse only all the vowels in the string and return it.</p>\n\n<p>The vowels are <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code>, and they can appear in both lower and upper cases, more than once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"hello\"\n<strong>Output:</strong> \"holle\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"leetcode\"\n<strong>Output:</strong> \"leotcede\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consist of <strong>printable ASCII</strong> characters.</li>\n</ul>\n"}}, "346": {"__typename": "QuestionLightNode", "acRate": 0.7332839712841644, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "346", "isFavor": false, "solutionNum": 222, "title": "Moving Average from Data Stream", "titleCn": "数据流中的移动平均值", "titleSlug": "moving-average-from-data-stream", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "vxfk6", "name": "Queue", "slug": "queue", "nameTranslated": "队列", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "pgti0i", "name": "Data Stream", "slug": "data-stream", "nameTranslated": "数据流", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 39, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "347": {"__typename": "QuestionLightNode", "acRate": 0.6364336625171159, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "347", "isFavor": false, "solutionNum": 3380, "title": "Top K Frequent Elements", "titleCn": "前 K 个高频元素", "titleSlug": "top-k-frequent-elements", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "eqnkri", "name": "Bucket Sort", "slug": "bucket-sort", "nameTranslated": "桶排序", "__typename": "CommonTagNode"}, {"id": "pxpqcm", "name": "Counting", "slug": "counting", "nameTranslated": "计数", "__typename": "CommonTagNode"}, {"id": "gl65v1", "name": "Quickselect", "slug": "quickselect", "nameTranslated": "快速选择", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 115, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>nums = [1,1,1,2,2,3], k = 2\n<strong>输出: </strong>[1,2]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>nums = [1], k = 1\n<strong>输出: </strong>[1]</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li>\n\t<li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code><em> </em>是数组大小。</p>\n", "en": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1,1,2,2,3], k = 2\n<strong>Output:</strong> [1,2]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>.</li>\n\t<li>It is <strong>guaranteed</strong> that the answer is <strong>unique</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Your algorithm&#39;s time complexity must be better than <code>O(n log n)</code>, where n is the array&#39;s size.</p>\n"}}, "348": {"__typename": "QuestionLightNode", "acRate": 0.5944956228185615, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "348", "isFavor": false, "solutionNum": 143, "title": "Design Tic-Tac-Toe", "titleCn": "设计井字棋", "titleSlug": "design-tic-tac-toe", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 48, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "349": {"__typename": "QuestionLightNode", "acRate": 0.7449205574651316, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "349", "isFavor": false, "solutionNum": 3435, "title": "Intersection of Two Arrays", "titleCn": "两个数组的交集", "titleSlug": "intersection-of-two-arrays", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 83, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code> ，返回 <em>它们的 <span data-keyword=\"array-intersection\">交集</span></em>&nbsp;。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,2,1], nums2 = [2,2]\n<strong>输出：</strong>[2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n<strong>输出：</strong>[9,4]\n<strong>解释：</strong>[4,9] 也是可通过的\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n", "en": "<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their <span data-keyword=\"array-intersection\">intersection</span></em>. Each element in the result must be <strong>unique</strong> and you may return the result in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]\n<strong>Output:</strong> [2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n<strong>Output:</strong> [9,4]\n<strong>Explanation:</strong> [4,9] is also accepted.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n"}}, "350": {"__typename": "QuestionLightNode", "acRate": 0.5753304812451334, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "350", "isFavor": false, "solutionNum": 3025, "title": "Intersection of Two Arrays II", "titleCn": "两个数组的交集 II", "titleSlug": "intersection-of-two-arrays-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 72, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个整数数组&nbsp;<code>nums1</code> 和 <code>nums2</code> ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,2,1], nums2 = [2,2]\n<strong>输出：</strong>[2,2]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n<strong>输出：</strong>[4,9]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong><strong>进阶</strong>：</strong></p>\n\n<ul>\n\t<li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li>\n\t<li>如果&nbsp;<code>nums1</code><em>&nbsp;</em>的大小比&nbsp;<code>nums2</code> 小，哪种方法更优？</li>\n\t<li>如果&nbsp;<code>nums2</code><em>&nbsp;</em>的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li>\n</ul>\n", "en": "<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>an array of their intersection</em>. Each element in the result must appear as many times as it shows in both arrays and you may return the result in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]\n<strong>Output:</strong> [2,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n<strong>Output:</strong> [4,9]\n<strong>Explanation:</strong> [9,4] is also accepted.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>What if the given array is already sorted? How would you optimize your algorithm?</li>\n\t<li>What if <code>nums1</code>&#39;s size is small compared to <code>nums2</code>&#39;s size? Which algorithm is better?</li>\n\t<li>What if elements of <code>nums2</code> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>\n</ul>\n"}}, "351": {"__typename": "QuestionLightNode", "acRate": 0.6172346259302781, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "351", "isFavor": false, "solutionNum": 139, "title": "Android Unlock Patterns", "titleCn": "安卓系统手势解锁", "titleSlug": "android-unlock-patterns", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "eeprrj", "name": "Bitmask", "slug": "bitmask", "nameTranslated": "状态压缩", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 12, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "352": {"__typename": "QuestionLightNode", "acRate": 0.6683984867591425, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "352", "isFavor": false, "solutionNum": 426, "title": "Data Stream as Disjoint Intervals", "titleCn": "将数据流变为多个不相交区间", "titleSlug": "data-stream-as-disjoint-intervals", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "qwy9jd", "name": "Ordered Set", "slug": "ordered-set", "nameTranslated": "有序集合", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/cf2a3ac504c38f16ee9e9e828b4f40ed444dc54e25653145bbfdf9f2f467115a-1587797765803.jpg", "slug": "oracle", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>&nbsp;给你一个由非负整数&nbsp;<code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub></code> 组成的数据流输入，请你将到目前为止看到的数字总结为不相交的区间列表。</p>\n\n<p>实现 <code>SummaryRanges</code> 类：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li><code>SummaryRanges()</code> 使用一个空数据流初始化对象。</li>\n\t<li><code>void addNum(int val)</code> 向数据流中加入整数 <code>val</code> 。</li>\n\t<li><code>int[][] getIntervals()</code> 以不相交区间&nbsp;<code>[start<sub>i</sub>, end<sub>i</sub>]</code> 的列表形式返回对数据流中整数的总结。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]\n<strong>输出：</strong>\n[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]\n\n<strong>解释：</strong>\nSummaryRanges summaryRanges = new SummaryRanges();\nsummaryRanges.addNum(1);      // arr = [1]\nsummaryRanges.getIntervals(); // 返回 [[1, 1]]\nsummaryRanges.addNum(3);      // arr = [1, 3]\nsummaryRanges.getIntervals(); // 返回 [[1, 1], [3, 3]]\nsummaryRanges.addNum(7);      // arr = [1, 3, 7]\nsummaryRanges.getIntervals(); // 返回 [[1, 1], [3, 3], [7, 7]]\nsummaryRanges.addNum(2);      // arr = [1, 2, 3, 7]\nsummaryRanges.getIntervals(); // 返回 [[1, 3], [7, 7]]\nsummaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]\nsummaryRanges.getIntervals(); // 返回 [[1, 3], [6, 7]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= val &lt;= 10<sup>4</sup></code></li>\n\t<li>最多调用&nbsp;<code>addNum</code> 和 <code>getIntervals</code> 方法 <code>3 * 10<sup>4</sup></code> 次</li>\n</ul>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>如果存在大量合并，并且与数据流的大小相比，不相交区间的数量很小，该怎么办?</p>\n", "en": "<p>Given a data stream input of non-negative integers <code>a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub></code>, summarize the numbers seen so far as a list of disjoint intervals.</p>\n\n<p>Implement the <code>SummaryRanges</code> class:</p>\n\n<ul>\n\t<li><code>SummaryRanges()</code> Initializes the object with an empty stream.</li>\n\t<li><code>void addNum(int value)</code> Adds the integer <code>value</code> to the stream.</li>\n\t<li><code>int[][] getIntervals()</code> Returns a summary of the integers in the stream currently as a list of disjoint intervals <code>[start<sub>i</sub>, end<sub>i</sub>]</code>. The answer should be sorted by <code>start<sub>i</sub></code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;SummaryRanges&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;, &quot;addNum&quot;, &quot;getIntervals&quot;]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]\n<strong>Output</strong>\n[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]\n\n<strong>Explanation</strong>\nSummaryRanges summaryRanges = new SummaryRanges();\nsummaryRanges.addNum(1);      // arr = [1]\nsummaryRanges.getIntervals(); // return [[1, 1]]\nsummaryRanges.addNum(3);      // arr = [1, 3]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3]]\nsummaryRanges.addNum(7);      // arr = [1, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]\nsummaryRanges.addNum(2);      // arr = [1, 2, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [7, 7]]\nsummaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [6, 7]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= value &lt;= 10<sup>4</sup></code></li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>addNum</code> and <code>getIntervals</code>.</li>\n\t<li>At most <code>10<sup>2</sup></code>&nbsp;calls will be made to&nbsp;<code>getIntervals</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?</p>\n"}}, "353": {"__typename": "QuestionLightNode", "acRate": 0.43113465481886537, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "353", "isFavor": false, "solutionNum": 91, "title": "Design Snake Game", "titleCn": "贪吃蛇", "titleSlug": "design-snake-game", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "vxfk6", "name": "Queue", "slug": "queue", "nameTranslated": "队列", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 29, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1690164235-qipwRG-att.png", "slug": "atlassian", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "354": {"__typename": "QuestionLightNode", "acRate": 0.35968179649761317, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "354", "isFavor": false, "solutionNum": 872, "title": "Russian Doll Envelopes", "titleCn": "俄罗斯套娃信封问题", "titleSlug": "russian-doll-envelopes", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 56, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个二维整数数组 <code>envelopes</code> ，其中 <code>envelopes[i] = [w<sub>i</sub>, h<sub>i</sub>]</code> ，表示第 <code>i</code> 个信封的宽度和高度。</p>\n\n<p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>\n\n<p>请计算 <strong>最多能有多少个</strong> 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>\n\n<p><strong>注意</strong>：不允许旋转信封。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>envelopes = [[5,4],[6,4],[6,7],[2,3]]\n<strong>输出：</strong>3\n<strong>解释：</strong>最多信封的个数为 <code>3, 组合为: </code>[2,3] =&gt; [5,4] =&gt; [6,7]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>envelopes = [[1,1],[1,1],[1,1]]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= envelopes.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>envelopes[i].length == 2</code></li>\n\t<li><code>1 &lt;= w<sub>i</sub>, h<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>You are given a 2D array of integers <code>envelopes</code> where <code>envelopes[i] = [w<sub>i</sub>, h<sub>i</sub>]</code> represents the width and the height of an envelope.</p>\n\n<p>One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope&#39;s width and height.</p>\n\n<p>Return <em>the maximum number of envelopes you can Russian doll (i.e., put one inside the other)</em>.</p>\n\n<p><strong>Note:</strong> You cannot rotate an envelope.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> envelopes = [[5,4],[6,4],[6,7],[2,3]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The maximum number of envelopes you can Russian doll is <code>3</code> ([2,3] =&gt; [5,4] =&gt; [6,7]).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> envelopes = [[1,1],[1,1],[1,1]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= envelopes.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>envelopes[i].length == 2</code></li>\n\t<li><code>1 &lt;= w<sub>i</sub>, h<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "355": {"__typename": "QuestionLightNode", "acRate": 0.41191285510488035, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "355", "isFavor": false, "solutionNum": 744, "title": "Design Twitter", "titleCn": "设计推特", "titleSlug": "design-twitter", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 37, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937282-qSKaPF-Unknown-4.jpeg", "slug": "twitter", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/9c7ab4e2476fc53dc9e8061b1b956172a38d1842b44023aa44e51f223e7d57ac-logo.png", "slug": "yelp", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近 <code>10</code> 条推文。</p>\n\n<p>实现 <code>Twitter</code> 类：</p>\n\n<ul>\n\t<li><code>Twitter()</code> 初始化简易版推特对象</li>\n\t<li><code>void postTweet(int userId, int tweetId)</code> 根据给定的 <code>tweetId</code> 和 <code>userId</code> 创建一条新推文。每次调用此函数都会使用一个不同的 <code>tweetId</code> 。</li>\n\t<li><code>List&lt;Integer&gt; getNewsFeed(int userId)</code> 检索当前用户新闻推送中最近&nbsp; <code>10</code> 条推文的 ID 。新闻推送中的每一项都必须是由用户关注的人或者是用户自己发布的推文。推文必须 <strong>按照时间顺序由最近到最远排序</strong> 。</li>\n\t<li><code>void follow(int followerId, int followeeId)</code> ID 为 <code>followerId</code> 的用户开始关注 ID 为 <code>followeeId</code> 的用户。</li>\n\t<li><code>void unfollow(int followerId, int followeeId)</code> ID 为 <code>followerId</code> 的用户不再关注 ID 为 <code>followeeId</code> 的用户。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"]\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\n<strong>输出</strong>\n[null, null, [5], null, null, [6, 5], null, [5]]\n\n<strong>解释</strong>\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 5); // 用户 1 发送了一条新推文 (用户 id = 1, 推文 id = 5)\ntwitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含一个 id 为 5 的推文\ntwitter.follow(1, 2);    // 用户 1 关注了用户 2\ntwitter.postTweet(2, 6); // 用户 2 发送了一个新推文 (推文 id = 6)\ntwitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含两个推文，id 分别为 -&gt; [6, 5] 。推文 id 6 应当在推文 id 5 之前，因为它是在 5 之后发送的\ntwitter.unfollow(1, 2);  // 用户 1 取消关注了用户 2\ntwitter.getNewsFeed(1);  // 用户 1 获取推文应当返回一个列表，其中包含一个 id 为 5 的推文。因为用户 1 已经不再关注用户 2</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= userId, followerId, followeeId &lt;= 500</code></li>\n\t<li><code>0 &lt;= tweetId &lt;= 10<sup>4</sup></code></li>\n\t<li>所有推特的 ID 都互不相同</li>\n\t<li><code>postTweet</code>、<code>getNewsFeed</code>、<code>follow</code> 和 <code>unfollow</code> 方法最多调用 <code>3 * 10<sup>4</sup></code> 次</li>\n</ul>\n", "en": "<p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the <code>10</code> most recent tweets in the user&#39;s news feed.</p>\n\n<p>Implement the <code>Twitter</code> class:</p>\n\n<ul>\n\t<li><code>Twitter()</code> Initializes your twitter object.</li>\n\t<li><code>void postTweet(int userId, int tweetId)</code> Composes a new tweet with ID <code>tweetId</code> by the user <code>userId</code>. Each call to this function will be made with a unique <code>tweetId</code>.</li>\n\t<li><code>List&lt;Integer&gt; getNewsFeed(int userId)</code> Retrieves the <code>10</code> most recent tweet IDs in the user&#39;s news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be <strong>ordered from most recent to least recent</strong>.</li>\n\t<li><code>void follow(int followerId, int followeeId)</code> The user with ID <code>followerId</code> started following the user with ID <code>followeeId</code>.</li>\n\t<li><code>void unfollow(int followerId, int followeeId)</code> The user with ID <code>followerId</code> started unfollowing the user with ID <code>followeeId</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Twitter&quot;, &quot;postTweet&quot;, &quot;getNewsFeed&quot;, &quot;follow&quot;, &quot;postTweet&quot;, &quot;getNewsFeed&quot;, &quot;unfollow&quot;, &quot;getNewsFeed&quot;]\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\n<strong>Output</strong>\n[null, null, [5], null, null, [6, 5], null, [5]]\n\n<strong>Explanation</strong>\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\ntwitter.getNewsFeed(1);  // User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5]. return [5]\ntwitter.follow(1, 2);    // User 1 follows user 2.\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\ntwitter.getNewsFeed(1);  // User 1&#39;s news feed should return a list with 2 tweet ids -&gt; [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\ntwitter.getNewsFeed(1);  // User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5], since user 1 is no longer following user 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= userId, followerId, followeeId &lt;= 500</code></li>\n\t<li><code>0 &lt;= tweetId &lt;= 10<sup>4</sup></code></li>\n\t<li>All the tweets have <strong>unique</strong> IDs.</li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>postTweet</code>, <code>getNewsFeed</code>, <code>follow</code>, and <code>unfollow</code>.</li>\n</ul>\n"}}, "356": {"__typename": "QuestionLightNode", "acRate": 0.36896901980700864, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "356", "isFavor": false, "solutionNum": 65, "title": "Line Reflection", "titleCn": "直线镜像", "titleSlug": "line-reflection", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 10, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "357": {"__typename": "QuestionLightNode", "acRate": 0.6067677751959291, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "357", "isFavor": false, "solutionNum": 960, "title": "Count Numbers with Unique Digits", "titleCn": "统计各位数字都不同的数字个数", "titleSlug": "count-numbers-with-unique-digits", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 23, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1604559404-lBlorc-https---i.forbesimg.com-media-lists-companies-jpmorgan-chase_416x416.jpg", "slug": "jpmorgan", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "给你一个整数 <code>n</code> ，统计并返回各位数字都不同的数字 <code>x</code> 的个数，其中 <code>0 &lt;= x &lt; 10<sup>n</sup></code><sup>&nbsp;</sup>。\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>91\n<strong>解释：</strong>答案应为除去 <code>11、22、33、44、55、66、77、88、99 </code>外，在 0 ≤ x &lt; 100 范围内的所有数字。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 0\n<strong>输出：</strong>1\n</pre>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 8</code></li>\n</ul>\n", "en": "<p>Given an integer <code>n</code>, return the count of all numbers with unique digits, <code>x</code>, where <code>0 &lt;= x &lt; 10<sup>n</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 91\n<strong>Explanation:</strong> The answer should be the total numbers in the range of 0 &le; x &lt; 100, excluding 11,22,33,44,55,66,77,88,99\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 0\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 8</code></li>\n</ul>\n"}}, "358": {"__typename": "QuestionLightNode", "acRate": 0.3747829107328934, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "358", "isFavor": false, "solutionNum": 97, "title": "Rearrange String k Distance Apart", "titleCn": "K 距离间隔重排字符串", "titleSlug": "rearrange-string-k-distance-apart", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "pxpqcm", "name": "Counting", "slug": "counting", "nameTranslated": "计数", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 18, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "359": {"__typename": "QuestionLightNode", "acRate": 0.7506163021868787, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "359", "isFavor": false, "solutionNum": 110, "title": "Logger Rate Limiter", "titleCn": "日志速率限制器", "titleSlug": "logger-rate-limiter", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "pgti0i", "name": "Data Stream", "slug": "data-stream", "nameTranslated": "数据流", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 37, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1690164235-qipwRG-att.png", "slug": "atlassian", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "360": {"__typename": "QuestionLightNode", "acRate": 0.624359952064495, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "360", "isFavor": false, "solutionNum": 94, "title": "Sort Transformed Array", "titleCn": "有序转化数组", "titleSlug": "sort-transformed-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 13, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "361": {"__typename": "QuestionLightNode", "acRate": 0.5976979225154407, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "361", "isFavor": false, "solutionNum": 109, "title": "Bomb Enemy", "titleCn": "轰炸敌人", "titleSlug": "bomb-enemy", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "362": {"__typename": "QuestionLightNode", "acRate": 0.6922655465254315, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "362", "isFavor": false, "solutionNum": 131, "title": "Design Hit Counter", "titleCn": "敲击计数器", "titleSlug": "design-hit-counter", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "vxfk6", "name": "Queue", "slug": "queue", "nameTranslated": "队列", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "pgti0i", "name": "Data Stream", "slug": "data-stream", "nameTranslated": "数据流", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 58, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/d9a48abd371c666425f82ac8c14dc7f3e9268e25fd43fb57a14b931e3d68fd9d-unnamed.jpg", "slug": "databricks", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "363": {"__typename": "QuestionLightNode", "acRate": 0.4824789846711719, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "363", "isFavor": false, "solutionNum": 278, "title": "Max Sum of Rectangle No Larger Than K", "titleCn": "矩形区域不超过 K 的最大数值和", "titleSlug": "max-sum-of-rectangle-no-larger-than-k", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}, {"id": "qwy9jd", "name": "Ordered Set", "slug": "ordered-set", "nameTranslated": "有序集合", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 31, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 和一个整数 <code>k</code> ，找出并返回矩阵内部矩形区域的不超过 <code>k</code> 的最大数值和。</p>\n\n<p>题目数据保证总会存在一个数值和不超过 <code>k</code> 的矩形区域。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg\" style=\"width: 255px; height: 176px;\" />\n<pre>\n<strong>输入：</strong>matrix = [[1,0,1],[0,-2,3]], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>蓝色边框圈出来的矩形区域 <code>[[0, 1], [-2, 3]]</code> 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[2,2,-1]], k = 3\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li><code>-100 <= matrix[i][j] <= 100</code></li>\n\t<li><code>-10<sup>5</sup> <= k <= 10<sup>5</sup></code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>如果行数远大于列数，该如何设计解决方案？</p>\n", "en": "<p>Given an <code>m x n</code> matrix <code>matrix</code> and an integer <code>k</code>, return <em>the max sum of a rectangle in the matrix such that its sum is no larger than</em> <code>k</code>.</p>\n\n<p>It is <strong>guaranteed</strong> that there will be a rectangle with a sum no larger than <code>k</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg\" style=\"width: 255px; height: 176px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,0,1],[0,-2,3]], k = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[2,2,-1]], k = 3\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if the number of rows is much larger than the number of columns?</p>\n"}}, "364": {"__typename": "QuestionLightNode", "acRate": 0.6468123861566485, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "364", "isFavor": false, "solutionNum": 81, "title": "Nested List Weight Sum II", "titleCn": "嵌套列表加权和 II", "titleSlug": "nested-list-weight-sum-ii", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 12, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1612772581-OTxyOQ-1.png", "slug": "didi", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "365": {"__typename": "QuestionLightNode", "acRate": 0.43340350783093756, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "365", "isFavor": false, "solutionNum": 721, "title": "Water and Jug Problem", "titleCn": "水壶问题", "titleSlug": "water-and-jug-problem", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 41, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/5bd12e3e40eff4a21834cb14e5ad7979abde52ba3a998e7f1e00e3cbb81a4fca-lyft.jpg", "slug": "lyft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>有两个水壶，容量分别为&nbsp;<code>x</code>&nbsp;和 <code>y</code> 升。水的供应是无限的。确定是否有可能使用这两个壶准确得到&nbsp;<code>target</code>&nbsp;升。</p>\n\n<p>你可以：</p>\n\n<ul>\n\t<li>装满任意一个水壶</li>\n\t<li>清空任意一个水壶</li>\n\t<li>将水从一个水壶倒入另一个水壶，直到接水壶已满，或倒水壶已空。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong>&nbsp;</p>\n\n<pre>\n<strong>输入:</strong> x = 3,y = 5,target = 4\n<strong>输出:</strong> true\n<strong>解释：\n</strong>按照以下步骤操作，以达到总共 4 升水：\n1. 装满 5 升的水壶(0, 5)。\n2. 把 5 升的水壶倒进 3 升的水壶，留下 2 升(3, 2)。\n3. 倒空 3 升的水壶(0, 2)。\n4. 把 2 升水从 5 升的水壶转移到 3 升的水壶(2, 0)。\n5. 再次加满 5 升的水壶(2, 5)。\n6. 从 5 升的水壶向 3 升的水壶倒水直到 3 升的水壶倒满。5 升的水壶里留下了 4 升水(3, 4)。\n7. 倒空 3 升的水壶。现在，5 升的水壶里正好有 4 升水(0, 4)。\n参考：来自著名的&nbsp;<a href=\"https://www.youtube.com/watch?v=BVtQNK_ZUJg\"><em>\"Die Hard\"</em></a></pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> x = 2, y = 6, target = 5\n<strong>输出:</strong> false\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> x = 1, y = 2, target = 3\n<strong>输出:</strong> true\n<b>解释：</b>同时倒满两个水壶。现在两个水壶中水的总量等于 3。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x, y, target &lt;= 10<sup>3</sup></code></li>\n</ul>\n", "en": "<p>You are given two jugs with capacities <code>x</code> liters and <code>y</code> liters. You have an infinite water supply. Return whether the total amount of water in both jugs may reach <code>target</code> using the following operations:</p>\n\n<ul>\n\t<li>Fill either jug completely with water.</li>\n\t<li>Completely empty either jug.</li>\n\t<li>Pour water from one jug into another until the receiving jug is full, or the transferring jug is empty.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1: </strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>Input: </strong> <span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\"> x = 3, y = 5, target = 4 </span></p>\n\n<p><strong>Output: </strong> <span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\"> true </span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p>Follow these steps to reach a total of 4 liters:</p>\n\n<ol>\n\t<li>Fill the 5-liter jug (0, 5).</li>\n\t<li>Pour from the 5-liter jug into the 3-liter jug, leaving 2 liters (3, 2).</li>\n\t<li>Empty the 3-liter jug (0, 2).</li>\n\t<li>Transfer the 2 liters from the 5-liter jug to the 3-liter jug (2, 0).</li>\n\t<li>Fill the 5-liter jug again (2, 5).</li>\n\t<li>Pour from the 5-liter jug into the 3-liter jug until the 3-liter jug is full. This leaves 4 liters in the 5-liter jug (3, 4).</li>\n\t<li>Empty the 3-liter jug. Now, you have exactly 4 liters in the 5-liter jug (0, 4).</li>\n</ol>\n\n<p>Reference: The <a href=\"https://www.youtube.com/watch?v=BVtQNK_ZUJg&amp;ab_channel=notnek01\" target=\"_blank\">Die Hard</a> example.</p>\n</div>\n\n<p><strong class=\"example\">Example 2: </strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>Input: </strong> <span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\"> x = 2, y = 6, target = 5 </span></p>\n\n<p><strong>Output: </strong> <span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\"> false </span></p>\n</div>\n\n<p><strong class=\"example\">Example 3: </strong></p>\n\n<div class=\"example-block\" style=\"border-color: var(--border-tertiary); border-left-width: 2px; color: var(--text-secondary); font-size: .875rem; margin-bottom: 1rem; margin-top: 1rem; overflow: visible; padding-left: 1rem;\">\n<p><strong>Input: </strong> <span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\"> x = 1, y = 2, target = 3 </span></p>\n\n<p><strong>Output: </strong> <span class=\"example-io\" style=\"font-family: Menlo,sans-serif; font-size: 0.85rem;\"> true </span></p>\n\n<p><strong>Explanation:</strong> Fill both jugs. The total amount of water in both jugs is equal to 3 now.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= x, y, target&nbsp;&lt;= 10<sup>3</sup></code></li>\n</ul>\n"}}, "366": {"__typename": "QuestionLightNode", "acRate": 0.8049944092433843, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "366", "isFavor": false, "solutionNum": 242, "title": "Find Leaves of Binary Tree", "titleCn": "寻找二叉树的叶子节点", "titleSlug": "find-leaves-of-binary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 27, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "367": {"__typename": "QuestionLightNode", "acRate": 0.4491434903934737, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "367", "isFavor": false, "solutionNum": 1877, "title": "Valid Perfect Square", "titleCn": "有效的完全平方数", "titleSlug": "valid-perfect-square", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 30, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个正整数 <code>num</code> 。如果 <code>num</code> 是一个完全平方数，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p><strong>完全平方数</strong> 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。</p>\n\n<p>不能使用任何内置的库函数，如&nbsp; <code>sqrt</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 16\n<strong>输出：</strong>true\n<strong>解释：</strong>返回 true ，因为 4 * 4 = 16 且 4 是一个整数。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 14\n<strong>输出：</strong>false\n<strong>解释：</strong>返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given a positive integer num, return <code>true</code> <em>if</em> <code>num</code> <em>is a perfect square or</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>A <strong>perfect square</strong> is an integer that is the square of an integer. In other words, it is the product of some integer with itself.</p>\n\n<p>You must not use any built-in library function, such as <code>sqrt</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 16\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We return true because 4 * 4 = 16 and 4 is an integer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 14\n<strong>Output:</strong> false\n<strong>Explanation:</strong> We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "368": {"__typename": "QuestionLightNode", "acRate": 0.45923627182831894, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "368", "isFavor": false, "solutionNum": 615, "title": "Largest Divisible Subset", "titleCn": "最大整除子集", "titleSlug": "largest-divisible-subset", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 25, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "给你一个由 <strong>无重复</strong> 正整数组成的集合 <code>nums</code> ，请你找出并返回其中最大的整除子集 <code>answer</code> ，子集中每一元素对 <code>(answer[i], answer[j])</code> 都应当满足：\n<ul>\n\t<li><code>answer[i] % answer[j] == 0</code> ，或</li>\n\t<li><code>answer[j] % answer[i] == 0</code></li>\n</ul>\n\n<p>如果存在多个有效解子集，返回其中任何一个均可。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>[1,2]\n<strong>解释：</strong>[1,3] 也会被视为正确答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,4,8]\n<strong>输出：</strong>[1,2,4,8]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 1000</code></li>\n\t<li><code>1 <= nums[i] <= 2 * 10<sup>9</sup></code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n", "en": "<p>Given a set of <strong>distinct</strong> positive integers <code>nums</code>, return the largest subset <code>answer</code> such that every pair <code>(answer[i], answer[j])</code> of elements in this subset satisfies:</p>\n\n<ul>\n\t<li><code>answer[i] % answer[j] == 0</code>, or</li>\n\t<li><code>answer[j] % answer[i] == 0</code></li>\n</ul>\n\n<p>If there are multiple solutions, return any of them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> [1,3] is also accepted.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,4,8]\n<strong>Output:</strong> [1,2,4,8]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 2 * 10<sup>9</sup></code></li>\n\t<li>All the integers in <code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n"}}, "369": {"__typename": "QuestionLightNode", "acRate": 0.6197864945382324, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "369", "isFavor": false, "solutionNum": 252, "title": "Plus One Linked List", "titleCn": "给单链表加一", "titleSlug": "plus-one-linked-list", "topicTags": [{"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 18, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "370": {"__typename": "QuestionLightNode", "acRate": 0.772662344797275, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "370", "isFavor": false, "solutionNum": 292, "title": "Range Addition", "titleCn": "区间加法", "titleSlug": "range-addition", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 19, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1675928747-DuwjgM-Citadel.png", "slug": "citadel", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "371": {"__typename": "QuestionLightNode", "acRate": 0.6255251347418899, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "371", "isFavor": false, "solutionNum": 736, "title": "Sum of Two Integers", "titleCn": "两整数之和", "titleSlug": "sum-of-two-integers", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 42, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个整数 <code>a</code> 和 <code>b</code> ，<strong>不使用 </strong>运算符&nbsp;<code>+</code> 和&nbsp;<code>-</code>&nbsp;​​​​​​​，计算并返回两整数之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 1, b = 2\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 2, b = 3\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-1000 &lt;= a, b &lt;= 1000</code></li>\n</ul>\n", "en": "<p>Given two integers <code>a</code> and <code>b</code>, return <em>the sum of the two integers without using the operators</em> <code>+</code> <em>and</em> <code>-</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> a = 1, b = 2\n<strong>Output:</strong> 3\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> a = 2, b = 3\n<strong>Output:</strong> 5\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-1000 &lt;= a, b &lt;= 1000</code></li>\n</ul>\n"}}, "372": {"__typename": "QuestionLightNode", "acRate": 0.5676520979222004, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "372", "isFavor": false, "solutionNum": 529, "title": "Super Pow", "titleCn": "超级次方", "titleSlug": "super-pow", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你的任务是计算 <code>a<sup>b</sup></code> 对 <code>1337</code> 取模，<code>a</code> 是一个正整数，<code>b</code> 是一个非常大的正整数且会以数组形式给出。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 2, b = [3]\n<strong>输出：</strong>8\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 2, b = [1,0]\n<strong>输出：</strong>1024\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 1, b = [4,3,3,8,5,2]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = 2147483647, b = [2,0,0]\n<strong>输出：</strong>1198\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= a <= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 <= b.length <= 2000</code></li>\n\t<li><code>0 <= b[i] <= 9</code></li>\n\t<li><code>b</code> 不含前导 0</li>\n</ul>\n", "en": "<p>Your task is to calculate <code>a<sup>b</sup></code> mod <code>1337</code> where <code>a</code> is a positive integer and <code>b</code> is an extremely large positive integer given in the form of an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = 2, b = [3]\n<strong>Output:</strong> 8\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = 2, b = [1,0]\n<strong>Output:</strong> 1024\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = 1, b = [4,3,3,8,5,2]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 &lt;= b.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= b[i] &lt;= 9</code></li>\n\t<li><code>b</code> does not contain leading zeros.</li>\n</ul>\n"}}, "373": {"__typename": "QuestionLightNode", "acRate": 0.40856739857173, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "373", "isFavor": false, "solutionNum": 598, "title": "Find K Pairs with Smallest Sums", "titleCn": "查找和最小的 K 对数字", "titleSlug": "find-k-pairs-with-smallest-sums", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 32, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个以 <strong>非递减顺序排列</strong> 的整数数组 <code>nums1</code> 和<strong> </strong><code>nums2</code><strong>&nbsp;</strong>,&nbsp;以及一个整数 <code>k</code><strong>&nbsp;</strong>。</p>\n\n<p>定义一对值&nbsp;<code>(u,v)</code>，其中第一个元素来自&nbsp;<code>nums1</code>，第二个元素来自 <code>nums2</code><strong>&nbsp;</strong>。</p>\n\n<p>请找到和最小的 <code>k</code>&nbsp;个数对&nbsp;<code>(u<sub>1</sub>,v<sub>1</sub>)</code>, <code>&nbsp;(u<sub>2</sub>,v<sub>2</sub>)</code> &nbsp;... &nbsp;<code>(u<sub>k</sub>,v<sub>k</sub>)</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n<strong>输出:</strong> [1,2],[1,4],[1,6]\n<strong>解释: </strong>返回序列中的前 3 对数：\n     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n</pre>\n\n<p><strong class=\"example\">示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>nums1 = [1,1,2], nums2 = [1,2,3], k = 2\n<strong>输出: </strong>[1,1],[1,1]\n<strong>解释: </strong>返回序列中的前 2 对数：\n&nbsp;    [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums1</code> 和 <code>nums2</code> 均为 <strong>升序排列</strong></li>\n\t<li><meta charset=\"UTF-8\" /><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>k &lt;=&nbsp;nums1.length *&nbsp;nums2.length</code></li>\n</ul>\n", "en": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> sorted in <strong>non-decreasing&nbsp;order</strong> and an integer <code>k</code>.</p>\n\n<p>Define a pair <code>(u, v)</code> which consists of one element from the first array and one element from the second array.</p>\n\n<p>Return <em>the</em> <code>k</code> <em>pairs</em> <code>(u<sub>1</sub>, v<sub>1</sub>), (u<sub>2</sub>, v<sub>2</sub>), ..., (u<sub>k</sub>, v<sub>k</sub>)</code> <em>with the smallest sums</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n<strong>Output:</strong> [[1,2],[1,4],[1,6]]\n<strong>Explanation:</strong> The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,1,2], nums2 = [1,2,3], k = 2\n<strong>Output:</strong> [[1,1],[1,1]]\n<strong>Explanation:</strong> The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>nums1</code> and <code>nums2</code> both are sorted in <strong>non-decreasing order</strong>.</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>k &lt;=&nbsp;nums1.length *&nbsp;nums2.length</code></li>\n</ul>\n"}}, "374": {"__typename": "QuestionLightNode", "acRate": 0.5237428985687125, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "374", "isFavor": false, "solutionNum": 1126, "title": "Guess Number Higher or Lower", "titleCn": "猜数字大小", "titleSlug": "guess-number-higher-or-lower", "topicTags": [{"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "0qo9zm", "name": "Interactive", "slug": "interactive", "nameTranslated": "交互", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 29, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>猜数字游戏的规则如下：</p>\n\n<ul>\n\t<li>每轮游戏，我都会从 <strong>1</strong> 到 <em><strong>n</strong></em> 随机选择一个数字。 请你猜选出的是哪个数字。</li>\n\t<li>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。</li>\n</ul>\n\n<p>你可以通过调用一个预先定义好的接口 <code>int guess(int num)</code> 来获取猜测结果，返回值一共有 3 种可能的情况（<code>-1</code>，<code>1</code> 或 <code>0</code>）：</p>\n\n<ul>\n\t<li>-1：我选出的数字比你猜的数字小 <code>pick < num</code></li>\n\t<li>1：我选出的数字比你猜的数字大 <code>pick > num</code></li>\n\t<li>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！<code>pick == num</code></li>\n</ul>\n\n<p>返回我选出的数字。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10, pick = 6\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, pick = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, pick = 1\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, pick = 2\n<strong>输出：</strong>2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 <= pick <= n</code></li>\n</ul>\n", "en": "<p>We are playing the Guess Game. The game is as follows:</p>\n\n<p>I pick a number from <code>1</code> to <code>n</code>. You have to guess which number I picked.</p>\n\n<p>Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.</p>\n\n<p>You call a pre-defined API <code>int guess(int num)</code>, which returns three possible results:</p>\n\n<ul>\n\t<li><code>-1</code>: Your guess is higher than the number I picked (i.e. <code>num &gt; pick</code>).</li>\n\t<li><code>1</code>: Your guess is lower than the number I picked (i.e. <code>num &lt; pick</code>).</li>\n\t<li><code>0</code>: your guess is equal to the number I picked (i.e. <code>num == pick</code>).</li>\n</ul>\n\n<p>Return <em>the number that I picked</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10, pick = 6\n<strong>Output:</strong> 6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, pick = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2, pick = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 &lt;= pick &lt;= n</code></li>\n</ul>\n"}}, "375": {"__typename": "QuestionLightNode", "acRate": 0.629526706472893, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "375", "isFavor": false, "solutionNum": 372, "title": "Guess Number Higher or Lower II", "titleCn": "猜数字大小 II", "titleSlug": "guess-number-higher-or-lower-ii", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "vawmlm", "name": "Game Theory", "slug": "game-theory", "nameTranslated": "博弈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 14, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>我们正在玩一个猜数游戏，游戏规则如下：</p>\n\n<ol>\n\t<li>我从&nbsp;<code>1</code><strong>&nbsp;</strong>到 <code>n</code> 之间选择一个数字。</li>\n\t<li>你来猜我选了哪个数字。</li>\n\t<li>如果你猜到正确的数字，就会 <strong>赢得游戏</strong> 。</li>\n\t<li>如果你猜错了，那么我会告诉你，我选的数字比你的 <strong>更大或者更小</strong> ，并且你需要继续猜数。</li>\n\t<li>每当你猜了数字 <code>x</code> 并且猜错了的时候，你需要支付金额为 <code>x</code> 的现金。如果你花光了钱，就会<strong> 输掉游戏</strong> 。</li>\n</ol>\n\n<p>给你一个特定的数字 <code>n</code> ，返回能够 <strong>确保你获胜</strong> 的最小现金数，<strong>不管我选择那个数字</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/10/graph.png\" style=\"width: 505px; height: 388px;\" />\n<pre>\n<strong>输入：</strong>n = 10\n<strong>输出：</strong>16\n<strong>解释：</strong>制胜策略如下：\n- 数字范围是 [1,10] 。你先猜测数字为 7 。\n&nbsp;   - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。\n&nbsp;   - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。\n&nbsp;       - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。\n&nbsp;       - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。\n&nbsp;       - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。\n&nbsp;   - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。\n&nbsp;       - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。\n&nbsp;       - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。\n&nbsp;           - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。\n&nbsp;           - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。\n&nbsp;           - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。\n&nbsp;       - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。\n&nbsp;           - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。\n&nbsp;           - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。\n在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>有两个可能的数字 1 和 2 。\n- 你可以先猜 1 。\n&nbsp;   - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。\n&nbsp;   - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。\n最糟糕的情况下，你需要支付 $1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n</ul>\n", "en": "<p>We are playing the Guessing Game. The game will work as follows:</p>\n\n<ol>\n\t<li>I pick a number between&nbsp;<code>1</code>&nbsp;and&nbsp;<code>n</code>.</li>\n\t<li>You guess a number.</li>\n\t<li>If you guess the right number, <strong>you win the game</strong>.</li>\n\t<li>If you guess the wrong number, then I will tell you whether the number I picked is <strong>higher or lower</strong>, and you will continue guessing.</li>\n\t<li>Every time you guess a wrong number&nbsp;<code>x</code>, you will pay&nbsp;<code>x</code>&nbsp;dollars. If you run out of money, <strong>you lose the game</strong>.</li>\n</ol>\n\n<p>Given a particular&nbsp;<code>n</code>, return&nbsp;<em>the minimum amount of money you need to&nbsp;<strong>guarantee a win regardless of what number I pick</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/10/graph.png\" style=\"width: 505px; height: 388px;\" />\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> 16\n<strong>Explanation:</strong> The winning strategy is as follows:\n- The range is [1,10]. Guess 7.\n&nbsp;   - If this is my number, your total is $0. Otherwise, you pay $7.\n&nbsp;   - If my number is higher, the range is [8,10]. Guess 9.\n&nbsp;       - If this is my number, your total is $7. Otherwise, you pay $9.\n&nbsp;       - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.\n&nbsp;       - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.\n&nbsp;   - If my number is lower, the range is [1,6]. Guess 3.\n&nbsp;       - If this is my number, your total is $7. Otherwise, you pay $3.\n&nbsp;       - If my number is higher, the range is [4,6]. Guess 5.\n&nbsp;           - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.\n&nbsp;           - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n&nbsp;           - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n&nbsp;       - If my number is lower, the range is [1,2]. Guess 1.\n&nbsp;           - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.\n&nbsp;           - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\nThe worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>&nbsp;There is only one possible number, so you can guess 1 and not have to pay anything.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>&nbsp;There are two possible numbers, 1 and 2.\n- Guess 1.\n&nbsp;   - If this is my number, your total is $0. Otherwise, you pay $1.\n&nbsp;   - If my number is higher, it must be 2. Guess 2. Your total is $1.\nThe worst case is that you pay $1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n</ul>\n"}}, "376": {"__typename": "QuestionLightNode", "acRate": 0.4634959782517306, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "376", "isFavor": false, "solutionNum": 1808, "title": "Wiggle Subsequence", "titleCn": "摆动序列", "titleSlug": "wiggle-subsequence", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 26, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为<strong> 摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>\n\n<ul>\n\t<li>\n\t<p>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</p>\n\t</li>\n\t<li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li>\n</ul>\n\n<p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>\n\n<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列 </strong>的 <strong>最长子序列的长度</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,7,4,9,2,5]\n<strong>输出：</strong>6\n<strong>解释：</strong>整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,17,5,10,13,15,10,5,16,8]\n<strong>输出：</strong>7\n<strong>解释：</strong>这个序列包含几个长度为 7 摆动序列。\n其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4,5,6,7,8,9]\n<strong>输出：</strong>2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 1000</code></li>\n\t<li><code>0 <= nums[i] <= 1000</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你能否用 <code>O(n)</code><em> </em>时间复杂度完成此题?</p>\n", "en": "<p>A <strong>wiggle sequence</strong> is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.</p>\n\n<ul>\n\t<li>For example, <code>[1, 7, 4, 9, 2, 5]</code> is a <strong>wiggle sequence</strong> because the differences <code>(6, -3, 5, -7, 3)</code> alternate between positive and negative.</li>\n\t<li>In contrast, <code>[1, 4, 7, 2, 5]</code> and <code>[1, 7, 4, 5, 5]</code> are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.</li>\n</ul>\n\n<p>A <strong>subsequence</strong> is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.</p>\n\n<p>Given an integer array <code>nums</code>, return <em>the length of the longest <strong>wiggle subsequence</strong> of </em><code>nums</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,7,4,9,2,5]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,17,5,10,13,15,10,5,16,8]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> There are several subsequences that achieve this length.\nOne is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5,6,7,8,9]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve this in <code>O(n)</code> time?</p>\n"}}, "377": {"__typename": "QuestionLightNode", "acRate": 0.5259293917481923, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "377", "isFavor": false, "solutionNum": 1116, "title": "Combination Sum IV", "titleCn": "组合总和 Ⅳ", "titleSlug": "combination-sum-iv", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 37, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>\n\n<p>题目数据保证答案符合 32 位整数范围。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], target = 4\n<strong>输出：</strong>7\n<strong>解释：</strong>\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n请注意，顺序不同的序列被视作不同的组合。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [9], target = 3\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 200</code></li>\n\t<li><code>1 <= nums[i] <= 1000</code></li>\n\t<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>\n\t<li><code>1 <= target <= 1000</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p>\n", "en": "<p>Given an array of <strong>distinct</strong> integers <code>nums</code> and a target integer <code>target</code>, return <em>the number of possible combinations that add up to</em>&nbsp;<code>target</code>.</p>\n\n<p>The test cases are generated so that the answer can fit in a <strong>32-bit</strong> integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3], target = 4\n<strong>Output:</strong> 7\n<strong>Explanation:</strong>\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [9], target = 3\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>All the elements of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>1 &lt;= target &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?</p>\n"}}, "378": {"__typename": "QuestionLightNode", "acRate": 0.6373369131620812, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "378", "isFavor": false, "solutionNum": 882, "title": "Kth Smallest Element in a Sorted Matrix", "titleCn": "有序矩阵中第 K 小的元素", "titleSlug": "kth-smallest-element-in-a-sorted-matrix", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 53, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个&nbsp;<code>n x n</code><em>&nbsp;</em>矩阵&nbsp;<code>matrix</code> ，其中每行和每列元素均按升序排序，找到矩阵中第 <code>k</code> 小的元素。<br />\n请注意，它是 <strong>排序后</strong> 的第 <code>k</code> 小元素，而不是第 <code>k</code> 个 <strong>不同</strong> 的元素。</p>\n\n<p>你必须找到一个内存复杂度优于&nbsp;<code>O(n<sup>2</sup>)</code> 的解决方案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n<strong>输出：</strong>13\n<strong>解释：</strong>矩阵中的元素为 [1,5,9,10,11,12,13,<strong>13</strong>,15]，第 8 小元素是 13\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>matrix = [[-5]], k = 1\n<strong>输出：</strong>-5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 300</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>\n\t<li>题目数据 <strong>保证</strong> <code>matrix</code> 中的所有行和列都按 <strong>非递减顺序</strong> 排列</li>\n\t<li><code>1 &lt;= k &lt;= n<sup>2</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>你能否用一个恒定的内存(即 <code>O(1)</code> 内存复杂度)来解决这个问题?</li>\n\t<li>你能在 <code>O(n)</code> 的时间复杂度下解决这个问题吗?这个方法对于面试来说可能太超前了，但是你会发现阅读这篇文章（&nbsp;<a href=\"http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf\" target=\"_blank\">this paper</a>&nbsp;）很有趣。</li>\n</ul>\n", "en": "<p>Given an <code>n x n</code> <code>matrix</code> where each of the rows and columns is sorted in ascending order, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest element in the matrix</em>.</p>\n\n<p>Note that it is the <code>k<sup>th</sup></code> smallest element <strong>in the sorted order</strong>, not the <code>k<sup>th</sup></code> <strong>distinct</strong> element.</p>\n\n<p>You must find a solution with a memory complexity better than <code>O(n<sup>2</sup>)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n<strong>Output:</strong> 13\n<strong>Explanation:</strong> The elements in the matrix are [1,5,9,10,11,12,13,<u><strong>13</strong></u>,15], and the 8<sup>th</sup> smallest number is 13\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[-5]], k = 1\n<strong>Output:</strong> -5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 300</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>\n\t<li>All the rows and columns of <code>matrix</code> are <strong>guaranteed</strong> to be sorted in <strong>non-decreasing order</strong>.</li>\n\t<li><code>1 &lt;= k &lt;= n<sup>2</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Could you solve the problem with a constant memory (i.e., <code>O(1)</code> memory complexity)?</li>\n\t<li>Could you solve the problem in <code>O(n)</code> time complexity? The solution may be too advanced for an interview but you may find reading <a href=\"http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf\" target=\"_blank\">this paper</a> fun.</li>\n</ul>\n"}}, "379": {"__typename": "QuestionLightNode", "acRate": 0.6132624398073836, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "379", "isFavor": false, "solutionNum": 122, "title": "Design Phone Directory", "titleCn": "电话目录管理系统", "titleSlug": "design-phone-directory", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "vxfk6", "name": "Queue", "slug": "queue", "nameTranslated": "队列", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 19, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708936774-exAysB-u=3581604551,3862588286&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "dropbox", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "380": {"__typename": "QuestionLightNode", "acRate": 0.5220886730876383, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "380", "isFavor": false, "solutionNum": 1884, "title": "Insert Delete GetRandom O(1)", "titleCn": "O(1) 时间插入、删除和获取随机元素", "titleSlug": "insert-delete-getrandom-o1", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "xp2m6at", "name": "Randomized", "slug": "randomized", "nameTranslated": "随机化", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 72, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>实现<code>RandomizedSet</code> 类：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li><code>RandomizedSet()</code> 初始化 <code>RandomizedSet</code> 对象</li>\n\t<li><code>bool insert(int val)</code> 当元素 <code>val</code> 不存在时，向集合中插入该项，并返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n\t<li><code>bool remove(int val)</code> 当元素 <code>val</code> 存在时，从集合中移除该项，并返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n\t<li><code>int getRandom()</code> 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 <strong>相同的概率</strong> 被返回。</li>\n</ul>\n\n<p>你必须实现类的所有函数，并满足每个函数的 <strong>平均</strong> 时间复杂度为 <code>O(1)</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], []]\n<strong>输出</strong>\n[null, true, false, true, 2, true, false, 2]\n\n<strong>解释</strong>\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。\nrandomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。\nrandomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。\nrandomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。\nrandomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。\nrandomizedSet.insert(2); // 2 已在集合中，所以返回 false 。\nrandomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>最多调用 <code>insert</code>、<code>remove</code> 和 <code>getRandom</code> 函数 <code>2 *&nbsp;</code><code>10<sup>5</sup></code> 次</li>\n\t<li>在调用 <code>getRandom</code> 方法时，数据结构中 <strong>至少存在一个</strong> 元素。</li>\n</ul>\n</div>\n</div>\n", "en": "<p>Implement the <code>RandomizedSet</code> class:</p>\n\n<ul>\n\t<li><code>RandomizedSet()</code> Initializes the <code>RandomizedSet</code> object.</li>\n\t<li><code>bool insert(int val)</code> Inserts an item <code>val</code> into the set if not present. Returns <code>true</code> if the item was not present, <code>false</code> otherwise.</li>\n\t<li><code>bool remove(int val)</code> Removes an item <code>val</code> from the set if present. Returns <code>true</code> if the item was present, <code>false</code> otherwise.</li>\n\t<li><code>int getRandom()</code> Returns a random element from the current set of elements (it&#39;s guaranteed that at least one element exists when this method is called). Each element must have the <b>same probability</b> of being returned.</li>\n</ul>\n\n<p>You must implement the functions of the class such that each function works in&nbsp;<strong>average</strong>&nbsp;<code>O(1)</code>&nbsp;time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]\n[[], [1], [2], [2], [], [1], [2], []]\n<strong>Output</strong>\n[null, true, false, true, 2, true, false, 2]\n\n<strong>Explanation</strong>\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>At most <code>2 *&nbsp;</code><code>10<sup>5</sup></code> calls will be made to <code>insert</code>, <code>remove</code>, and <code>getRandom</code>.</li>\n\t<li>There will be <strong>at least one</strong> element in the data structure when <code>getRandom</code> is called.</li>\n</ul>\n"}}, "381": {"__typename": "QuestionLightNode", "acRate": 0.4185495385430619, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "381", "isFavor": false, "solutionNum": 249, "title": "Insert Delete GetRandom O(1) - Duplicates allowed", "titleCn": "O(1) 时间插入、删除和获取随机元素 - 允许重复", "titleSlug": "insert-delete-getrandom-o1-duplicates-allowed", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "xp2m6at", "name": "Randomized", "slug": "randomized", "nameTranslated": "随机化", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 34, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><code>RandomizedCollection</code> 是一种包含数字集合(可能是重复的)的数据结构。它应该支持插入和删除特定元素，以及删除随机元素。</p>\n\n<p>实现 <code>RandomizedCollection</code> 类:</p>\n\n<ul>\n\t<li><code>RandomizedCollection()</code>初始化空的 <code>RandomizedCollection</code> 对象。</li>\n\t<li><code>bool insert(int val)</code>&nbsp;将一个 <code>val</code> 项插入到集合中，即使该项已经存在。如果该项不存在，则返回 <code>true</code> ，否则返回 <code>false</code> 。</li>\n\t<li><code>bool remove(int val)</code>&nbsp;如果存在，从集合中移除一个 <code>val</code> 项。如果该项存在，则返回 <code>true</code> ，否则返回 <code>false</code> 。注意，如果 <code>val</code> 在集合中出现多次，我们只删除其中一个。</li>\n\t<li><code>int getRandom()</code> 从当前的多个元素集合中返回一个随机元素。每个元素被返回的概率与集合中包含的相同值的数量 <strong>线性相关</strong> 。</li>\n</ul>\n\n<p>您必须实现类的函数，使每个函数的 <strong>平均</strong> 时间复杂度为 <code>O(1)</code> 。</p>\n\n<p><strong>注意：</strong>生成测试用例时，只有在 <code>RandomizedCollection</code> 中 <strong>至少有一项</strong> 时，才会调用 <code>getRandom</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"]\n[[], [1], [1], [2], [], [1], []]\n<strong>输出</strong>\n[null, true, false, true, 2, true, 1]\n\n<strong>解释</strong>\nRandomizedCollection collection = new RandomizedCollection();// 初始化一个空的集合。\ncollection.insert(1);   // 返回 true，因为集合不包含 1。\n                        // 将 1 插入到集合中。\ncollection.insert(1);   // 返回 false，因为集合包含 1。\n&nbsp;                       // 将另一个 1 插入到集合中。集合现在包含 [1,1]。\ncollection.insert(2);   // 返回 true，因为集合不包含 2。\n&nbsp;                       // 将 2 插入到集合中。集合现在包含 [1,1,2]。\ncollection.getRandom(); // getRandom 应当:\n&nbsp;                       // 有 2/3 的概率返回 1,\n&nbsp;                       // 1/3 的概率返回 2。\ncollection.remove(1);   // 返回 true，因为集合包含 1。\n&nbsp;                       // 从集合中移除 1。集合现在包含 [1,2]。\ncollection.getRandom(); // getRandom 应该返回 1 或 2，两者的可能性相同。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n\t<li><code>insert</code>,&nbsp;<code>remove</code>&nbsp;和&nbsp;<code>getRandom</code>&nbsp;最多 <strong>总共</strong> 被调用&nbsp;<code>2 * 10<sup>5</sup></code>&nbsp;次</li>\n\t<li>当调用 <code>getRandom</code> 时，数据结构中 <strong>至少有一个</strong> 元素</li>\n</ul>\n", "en": "<p><code>RandomizedCollection</code> is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element.</p>\n\n<p>Implement the <code>RandomizedCollection</code> class:</p>\n\n<ul>\n\t<li><code>RandomizedCollection()</code> Initializes the empty <code>RandomizedCollection</code> object.</li>\n\t<li><code>bool insert(int val)</code> Inserts an item <code>val</code> into the multiset, even if the item is already present. Returns <code>true</code> if the item is not present, <code>false</code> otherwise.</li>\n\t<li><code>bool remove(int val)</code> Removes an item <code>val</code> from the multiset if present. Returns <code>true</code> if the item is present, <code>false</code> otherwise. Note that if <code>val</code> has multiple occurrences in the multiset, we only remove one of them.</li>\n\t<li><code>int getRandom()</code> Returns a random element from the current multiset of elements. The probability of each element being returned is <strong>linearly related</strong> to the number of the same values the multiset contains.</li>\n</ul>\n\n<p>You must implement the functions of the class such that each function works on <strong>average</strong> <code>O(1)</code> time complexity.</p>\n\n<p><strong>Note:</strong> The test cases are generated such that <code>getRandom</code> will only be called if there is <strong>at least one</strong> item in the <code>RandomizedCollection</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;RandomizedCollection&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;getRandom&quot;]\n[[], [1], [1], [2], [], [1], []]\n<strong>Output</strong>\n[null, true, false, true, 2, true, 1]\n\n<strong>Explanation</strong>\nRandomizedCollection randomizedCollection = new RandomizedCollection();\nrandomizedCollection.insert(1);   // return true since the collection does not contain 1.\n                                  // Inserts 1 into the collection.\nrandomizedCollection.insert(1);   // return false since the collection contains 1.\n                                  // Inserts another 1 into the collection. Collection now contains [1,1].\nrandomizedCollection.insert(2);   // return true since the collection does not contain 2.\n                                  // Inserts 2 into the collection. Collection now contains [1,1,2].\nrandomizedCollection.getRandom(); // getRandom should:\n                                  // - return 1 with probability 2/3, or\n                                  // - return 2 with probability 1/3.\nrandomizedCollection.remove(1);   // return true since the collection contains 1.\n                                  // Removes 1 from the collection. Collection now contains [1,2].\nrandomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>At most <code>2 * 10<sup>5</sup></code> calls <strong>in total</strong> will be made to <code>insert</code>, <code>remove</code>, and <code>getRandom</code>.</li>\n\t<li>There will be <strong>at least one</strong> element in the data structure when <code>getRandom</code> is called.</li>\n</ul>\n"}}, "382": {"__typename": "QuestionLightNode", "acRate": 0.7265080954038997, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "382", "isFavor": false, "solutionNum": 471, "title": "Linked List Random Node", "titleCn": "链表随机节点", "titleSlug": "linked-list-random-node", "topicTags": [{"id": "veg8i", "name": "Reservoir Sampling", "slug": "reservoir-sampling", "nameTranslated": "水塘抽样", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "xp2m6at", "name": "Randomized", "slug": "randomized", "nameTranslated": "随机化", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 36, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点<strong> 被选中的概率一样</strong> 。</p>\n\n<p>实现 <code>Solution</code> 类：</p>\n\n<ul>\n\t<li><code>Solution(ListNode head)</code> 使用整数数组初始化对象。</li>\n\t<li><code>int getRandom()</code> 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/16/getrand-linked-list.jpg\" style=\"width: 302px; height: 62px;\" />\n<pre>\n<strong>输入</strong>\n[\"Solution\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\"]\n[[[1, 2, 3]], [], [], [], [], []]\n<strong>输出</strong>\n[null, 1, 3, 2, 2, 3]\n\n<strong>解释</strong>\nSolution solution = new Solution([1, 2, 3]);\nsolution.getRandom(); // 返回 1\nsolution.getRandom(); // 返回 3\nsolution.getRandom(); // 返回 2\nsolution.getRandom(); // 返回 2\nsolution.getRandom(); // 返回 3\n// getRandom() 方法应随机返回 1、2、3中的一个，每个元素被返回的概率相等。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表中的节点数在范围 <code>[1, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>至多调用&nbsp;<code>getRandom</code> 方法 <code>10<sup>4</sup></code> 次</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>如果链表非常大且长度未知，该怎么处理？</li>\n\t<li>你能否在不使用额外空间的情况下解决此问题？</li>\n</ul>\n", "en": "<p>Given a singly linked list, return a random node&#39;s value from the linked list. Each node must have the <strong>same probability</strong> of being chosen.</p>\n\n<p>Implement the <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution(ListNode head)</code> Initializes the object with the head of the singly-linked list <code>head</code>.</li>\n\t<li><code>int getRandom()</code> Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/16/getrand-linked-list.jpg\" style=\"width: 302px; height: 62px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;Solution&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;]\n[[[1, 2, 3]], [], [], [], [], []]\n<strong>Output</strong>\n[null, 1, 3, 2, 2, 3]\n\n<strong>Explanation</strong>\nSolution solution = new Solution([1, 2, 3]);\nsolution.getRandom(); // return 1\nsolution.getRandom(); // return 3\nsolution.getRandom(); // return 2\nsolution.getRandom(); // return 2\nsolution.getRandom(); // return 3\n// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the linked list will be in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>getRandom</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>What if the linked list is extremely large and its length is unknown to you?</li>\n\t<li>Could you solve this efficiently without using extra space?</li>\n</ul>\n"}}, "383": {"__typename": "QuestionLightNode", "acRate": 0.6400551336100793, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "383", "isFavor": false, "solutionNum": 3602, "title": "Ransom Note", "titleCn": "赎金信", "titleSlug": "ransom-note", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "pxpqcm", "name": "Counting", "slug": "counting", "nameTranslated": "计数", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 40, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p>\n\n<p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p>\n\n<p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>ransomNote = \"a\", magazine = \"b\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>ransomNote = \"aa\", magazine = \"ab\"\n<strong>输出：</strong>false\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>ransomNote = \"aa\", magazine = \"aab\"\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li>\n</ul>\n", "en": "<p>Given two strings <code>ransomNote</code> and <code>magazine</code>, return <code>true</code><em> if </em><code>ransomNote</code><em> can be constructed by using the letters from </em><code>magazine</code><em> and </em><code>false</code><em> otherwise</em>.</p>\n\n<p>Each letter in <code>magazine</code> can only be used once in <code>ransomNote</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> ransomNote = \"a\", magazine = \"b\"\n<strong>Output:</strong> false\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> ransomNote = \"aa\", magazine = \"ab\"\n<strong>Output:</strong> false\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> ransomNote = \"aa\", magazine = \"aab\"\n<strong>Output:</strong> true\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>ransomNote</code> and <code>magazine</code> consist of lowercase English letters.</li>\n</ul>\n"}}, "384": {"__typename": "QuestionLightNode", "acRate": 0.6179828086154309, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "384", "isFavor": false, "solutionNum": 621, "title": "Shuffle an Array", "titleCn": "打乱数组", "titleSlug": "shuffle-an-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "xp2m6at", "name": "Randomized", "slug": "randomized", "nameTranslated": "随机化", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 69, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是&nbsp;<strong>等可能</strong>&nbsp;的。</p>\n\n<p>实现 <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution(int[] nums)</code> 使用整数数组 <code>nums</code> 初始化对象</li>\n\t<li><code>int[] reset()</code> 重设数组到它的初始状态并返回</li>\n\t<li><code>int[] shuffle()</code> 返回数组随机打乱后的结果</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"]\n[[[1, 2, 3]], [], [], []]\n<strong>输出</strong>\n[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n\n<strong>解释</strong>\nSolution solution = new Solution([1, 2, 3]);\nsolution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]\nsolution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]\nsolution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>nums</code> 中的所有元素都是 <strong>唯一的</strong></li>\n\t<li>最多可以调用 <code>10<sup>4</sup></code> 次 <code>reset</code> 和 <code>shuffle</code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code>, design an algorithm to randomly shuffle the array. All permutations of the array should be <strong>equally likely</strong> as a result of the shuffling.</p>\n\n<p>Implement the <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li>\n\t<li><code>int[] reset()</code> Resets the array to its original configuration and returns it.</li>\n\t<li><code>int[] shuffle()</code> Returns a random shuffling of the array.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Solution&quot;, &quot;shuffle&quot;, &quot;reset&quot;, &quot;shuffle&quot;]\n[[[1, 2, 3]], [], [], []]\n<strong>Output</strong>\n[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n\n<strong>Explanation</strong>\nSolution solution = new Solution([1, 2, 3]);\nsolution.shuffle();    // Shuffle the array [1,2,3] and return its result.\n                       // Any permutation of [1,2,3] must be equally likely to be returned.\n                       // Example: return [3, 1, 2]\nsolution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]\nsolution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]\n\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li>All the elements of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li>At most <code>10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>reset</code> and <code>shuffle</code>.</li>\n</ul>\n"}}, "385": {"__typename": "QuestionLightNode", "acRate": 0.549152877905538, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "385", "isFavor": false, "solutionNum": 314, "title": "Mini Parser", "titleCn": "迷你语法分析器", "titleSlug": "mini-parser", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 19, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果&nbsp;<code>NestedInteger</code> 。</p>\n\n<p>列表中的每个元素只可能是整数或整数嵌套列表</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"324\",\n<strong>输出：</strong>324\n<strong>解释：</strong>你应该返回一个 NestedInteger 对象，其中只包含整数值 324。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"[123,[456,[789]]]\",\n<strong>输出：</strong>[123,[456,[789]]]\n<strong>解释：</strong>返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：\n1. 一个 integer 包含值 123\n2. 一个包含两个元素的嵌套列表：\n    i.  一个 integer 包含值 456\n    ii. 一个包含一个元素的嵌套列表\n         a. 一个 integer 包含值 789\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> 由数字、方括号&nbsp;<code>\"[]\"</code>、负号&nbsp;<code>'-'</code>&nbsp;、逗号&nbsp;<code>','</code>组成</li>\n\t<li>用例保证&nbsp;<code>s</code> 是可解析的&nbsp;<code>NestedInteger</code></li>\n\t<li>输入中的所有值的范围是&nbsp;<code>[-10<sup>6</sup>, 10<sup>6</sup>]</code></li>\n</ul>\n", "en": "<p>Given a string s represents the serialization of a nested list, implement a parser to deserialize it and return <em>the deserialized</em> <code>NestedInteger</code>.</p>\n\n<p>Each element is either an integer or a list whose elements may also be integers or other lists.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;324&quot;\n<strong>Output:</strong> 324\n<strong>Explanation:</strong> You should return a NestedInteger object which contains a single integer 324.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;[123,[456,[789]]]&quot;\n<strong>Output:</strong> [123,[456,[789]]]\n<strong>Explanation:</strong> Return a NestedInteger object containing a nested list with 2 elements:\n1. An integer containing value 123.\n2. A nested list containing two elements:\n    i.  An integer containing value 456.\n    ii. A nested list with one element:\n         a. An integer containing value 789\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of digits, square brackets <code>&quot;[]&quot;</code>, negative sign <code>&#39;-&#39;</code>, and commas <code>&#39;,&#39;</code>.</li>\n\t<li><code>s</code> is the serialization of valid <code>NestedInteger</code>.</li>\n\t<li>All the values in the input are in the range <code>[-10<sup>6</sup>, 10<sup>6</sup>]</code>.</li>\n</ul>\n"}}, "386": {"__typename": "QuestionLightNode", "acRate": 0.7460575388862242, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "386", "isFavor": false, "solutionNum": 691, "title": "Lexicographical Numbers", "titleCn": "字典序排数", "titleSlug": "lexicographical-numbers", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 29, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数 <code>n</code> ，按字典序返回范围 <code>[1, n]</code> 内所有整数。</p>\n\n<p>你必须设计一个时间复杂度为 <code>O(n)</code> 且使用 <code>O(1)</code> 额外空间的算法。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 13\n<strong>输出：</strong>[1,10,11,12,13,2,3,4,5,6,7,8,9]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given an integer <code>n</code>, return all the numbers in the range <code>[1, n]</code> sorted in lexicographical order.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time and uses <code>O(1)</code> extra space.&nbsp;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 13\n<strong>Output:</strong> [1,10,11,12,13,2,3,4,5,6,7,8,9]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 2\n<strong>Output:</strong> [1,2]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n</ul>\n"}}, "387": {"__typename": "QuestionLightNode", "acRate": 0.5642571009202895, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "387", "isFavor": false, "solutionNum": 2318, "title": "First Unique Character in a String", "titleCn": "字符串中的第一个唯一字符", "titleSlug": "first-unique-character-in-a-string", "topicTags": [{"id": "vxfk6", "name": "Queue", "slug": "queue", "nameTranslated": "队列", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "pxpqcm", "name": "Counting", "slug": "counting", "nameTranslated": "计数", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 77, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个字符串&nbsp;<code>s</code>&nbsp;，找到 <em>它的第一个不重复的字符，并返回它的索引</em> 。如果不存在，则返回 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"leetcode\"\n<strong>输出:</strong> 0\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"loveleetcode\"\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"aabb\"\n<strong>输出:</strong> -1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含小写字母</li>\n</ul>\n", "en": "<p>Given a string <code>s</code>, <em>find the first non-repeating character in it and return its index</em>. If it does not exist, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"leetcode\"\n<strong>Output:</strong> 0\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"loveleetcode\"\n<strong>Output:</strong> 2\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> s = \"aabb\"\n<strong>Output:</strong> -1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of only lowercase English letters.</li>\n</ul>\n"}}, "388": {"__typename": "QuestionLightNode", "acRate": 0.6377941742140784, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "388", "isFavor": false, "solutionNum": 536, "title": "Longest Absolute File Path", "titleCn": "文件的最长绝对路径", "titleSlug": "longest-absolute-file-path", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 28, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mdir.jpg\" style=\"height: 142px; width: 300px;\" /></p>\n\n<p>这里将 <code>dir</code> 作为根目录中的唯一目录。<code>dir</code> 包含两个子目录 <code>subdir1</code> 和 <code>subdir2</code> 。<code>subdir1</code> 包含文件 <code>file1.ext</code> 和子目录 <code>subsubdir1</code>；<code>subdir2</code> 包含子目录 <code>subsubdir2</code>，该子目录下包含文件 <code>file2.ext</code> 。</p>\n\n<p>在文本格式中，如下所示(⟶表示制表符)：</p>\n\n<pre>\ndir\n⟶ subdir1\n⟶ ⟶ file1.ext\n⟶ ⟶ subsubdir1\n⟶ subdir2\n⟶ ⟶ subsubdir2\n⟶ ⟶ ⟶ file2.ext\n</pre>\n\n<p>如果是代码表示，上面的文件系统可以写为 <code>\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"</code> 。<code>'\\n'</code> 和 <code>'\\t'</code> 分别是换行符和制表符。</p>\n\n<p>文件系统中的每个文件和文件夹都有一个唯一的 <strong>绝对路径</strong> ，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用 <code>'/'</code> 连接。上面例子中，指向 <code>file2.ext</code> 的 <strong>绝对路径</strong> 是 <code>\"dir/subdir2/subsubdir2/file2.ext\"</code> 。每个目录名由字母、数字和/或空格组成，每个文件名遵循 <code>name.extension</code> 的格式，其中<meta charset=\"UTF-8\" />&nbsp;<code>name</code>&nbsp;和<meta charset=\"UTF-8\" />&nbsp;<code>extension</code>由字母、数字和/或空格组成。</p>\n\n<p>给定一个以上述格式表示文件系统的字符串 <code>input</code> ，返回文件系统中&nbsp;<em>指向&nbsp;<strong>文件</strong>&nbsp;的 <strong>最长绝对路径</strong> 的长度</em>&nbsp;。 如果系统中没有文件，返回&nbsp;<code>0</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/dir1.jpg\" style=\"height: 101px; width: 200px;\" />\n<pre>\n<strong>输入：</strong>input = \"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\"\n<strong>输出：</strong>20\n<strong>解释：</strong>只有一个文件，绝对路径为 \"dir/subdir2/file.ext\" ，路径长度 20\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/dir2.jpg\" style=\"height: 151px; width: 300px;\" />\n<pre>\n<strong>输入：</strong>input = \"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"\n<strong>输出：</strong>32\n<strong>解释：</strong>存在两个文件：\n\"dir/subdir1/file1.ext\" ，路径长度 21\n\"dir/subdir2/subsubdir2/file2.ext\" ，路径长度 32\n返回 32 ，因为这是最长的路径</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>input = \"a\"\n<strong>输出：</strong>0\n<strong>解释：</strong>不存在任何文件</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>input = \"file1.txt\\nfile2.txt\\nlongfile.txt\"\n<strong>输出：</strong>12\n<strong>解释：</strong>根目录下有 3 个文件。\n因为根目录中任何东西的绝对路径只是名称本身，所以答案是 \"longfile.txt\" ，路径长度为 12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= input.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>input</code> 可能包含小写或大写的英文字母，一个换行符 <code>'\\n'</code>，一个制表符 <code>'\\t'</code>，一个点 <code>'.'</code>，一个空格 <code>' '</code>，和数字。</li>\n</ul>\n", "en": "<p>Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:</p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/mdir.jpg\" style=\"width: 681px; height: 322px;\" /></p>\n\n<p>Here, we have <code>dir</code> as the only directory in the root. <code>dir</code> contains two subdirectories, <code>subdir1</code> and <code>subdir2</code>. <code>subdir1</code> contains a file <code>file1.ext</code> and subdirectory <code>subsubdir1</code>. <code>subdir2</code> contains a subdirectory <code>subsubdir2</code>, which contains a file <code>file2.ext</code>.</p>\n\n<p>In text form, it looks like this (with ⟶ representing the tab character):</p>\n\n<pre>\ndir\n⟶ subdir1\n⟶ ⟶ file1.ext\n⟶ ⟶ subsubdir1\n⟶ subdir2\n⟶ ⟶ subsubdir2\n⟶ ⟶ ⟶ file2.ext\n</pre>\n\n<p>If we were to write this representation in code, it will look like this: <code>&quot;dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext&quot;</code>. Note that the <code>&#39;\\n&#39;</code> and <code>&#39;\\t&#39;</code> are the new-line and tab characters.</p>\n\n<p>Every file and directory has a unique <strong>absolute path</strong> in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by <code>&#39;/&#39;s</code>. Using the above example, the <strong>absolute path</strong> to <code>file2.ext</code> is <code>&quot;dir/subdir2/subsubdir2/file2.ext&quot;</code>. Each directory name consists of letters, digits, and/or spaces. Each file name is of the form <code>name.extension</code>, where <code>name</code> and <code>extension</code> consist of letters, digits, and/or spaces.</p>\n\n<p>Given a string <code>input</code> representing the file system in the explained format, return <em>the length of the <strong>longest absolute path</strong> to a <strong>file</strong> in the abstracted file system</em>. If there is no file in the system, return <code>0</code>.</p>\n\n<p><strong>Note</strong> that the testcases are generated such that the file system is valid and no file or directory name has length 0.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/dir1.jpg\" style=\"width: 401px; height: 202px;\" />\n<pre>\n<strong>Input:</strong> input = &quot;dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext&quot;\n<strong>Output:</strong> 20\n<strong>Explanation:</strong> We have only one file, and the absolute path is &quot;dir/subdir2/file.ext&quot; of length 20.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/28/dir2.jpg\" style=\"width: 641px; height: 322px;\" />\n<pre>\n<strong>Input:</strong> input = &quot;dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext&quot;\n<strong>Output:</strong> 32\n<strong>Explanation:</strong> We have two files:\n&quot;dir/subdir1/file1.ext&quot; of length 21\n&quot;dir/subdir2/subsubdir2/file2.ext&quot; of length 32.\nWe return 32 since it is the longest absolute path to a file.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> input = &quot;a&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> We do not have any files, just a single directory named &quot;a&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= input.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>input</code> may contain lowercase or uppercase English letters, a new line character <code>&#39;\\n&#39;</code>, a tab character <code>&#39;\\t&#39;</code>, a dot <code>&#39;.&#39;</code>, a space <code>&#39; &#39;</code>, and digits.</li>\n\t<li>All file and directory names have <strong>positive</strong> length.</li>\n</ul>\n"}}, "389": {"__typename": "QuestionLightNode", "acRate": 0.645408414231266, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "389", "isFavor": false, "solutionNum": 1910, "title": "Find the Difference", "titleCn": "找不同", "titleSlug": "find-the-difference", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 22, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个字符串 <code>s</code> 和 <code>t</code>&nbsp;，它们只包含小写字母。</p>\n\n<p>字符串 <code>t</code>&nbsp;由字符串 <code>s</code> 随机重排，然后在随机位置添加一个字母。</p>\n\n<p>请找出在 <code>t</code>&nbsp;中被添加的字母。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", t = \"abcde\"\n<strong>输出：</strong>\"e\"\n<strong>解释：</strong>'e' 是那个被添加的字母。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"\", t = \"y\"\n<strong>输出：</strong>\"y\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>t.length == s.length + 1</code></li>\n\t<li><code>s</code> 和 <code>t</code> 只包含小写字母</li>\n</ul>\n", "en": "<p>You are given two strings <code>s</code> and <code>t</code>.</p>\n\n<p>String <code>t</code> is generated by random shuffling string <code>s</code> and then add one more letter at a random position.</p>\n\n<p>Return the letter that was added to <code>t</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcd&quot;, t = &quot;abcde&quot;\n<strong>Output:</strong> &quot;e&quot;\n<strong>Explanation:</strong> &#39;e&#39; is the letter that was added.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;&quot;, t = &quot;y&quot;\n<strong>Output:</strong> &quot;y&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>t.length == s.length + 1</code></li>\n\t<li><code>s</code> and <code>t</code> consist of lowercase English letters.</li>\n</ul>\n"}}, "390": {"__typename": "QuestionLightNode", "acRate": 0.5930872664921939, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "390", "isFavor": false, "solutionNum": 485, "title": "Elimination Game", "titleCn": "消除游戏", "titleSlug": "elimination-game", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 28, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>列表 <code>arr</code> 由在范围 <code>[1, n]</code> 中的所有整数组成，并按严格递增排序。请你对 <code>arr</code> 应用下述算法：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li>从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。</li>\n\t<li>重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。</li>\n\t<li>不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。</li>\n</ul>\n\n<p>给你整数 <code>n</code> ，返回 <code>arr</code> 最后剩下的数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 9\n<strong>输出：</strong>6\n<strong>解释：</strong>\narr = [<strong><em>1</em></strong>, 2, <em><strong>3</strong></em>, 4, <em><strong>5</strong></em>, 6, <em><strong>7</strong></em>, 8, <em><strong>9</strong></em>]\narr = [2, <em><strong>4</strong></em>, 6, <em><strong>8</strong></em>]\narr = [<em><strong>2</strong></em>, 6]\narr = [6]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>You have a list <code>arr</code> of all integers in the range <code>[1, n]</code> sorted in a strictly increasing order. Apply the following algorithm on <code>arr</code>:</p>\n\n<ul>\n\t<li>Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.</li>\n\t<li>Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.</li>\n\t<li>Keep repeating the steps again, alternating left to right and right to left, until a single number remains.</li>\n</ul>\n\n<p>Given the integer <code>n</code>, return <em>the last number that remains in</em> <code>arr</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 9\n<strong>Output:</strong> 6\n<strong>Explanation:</strong>\narr = [<u>1</u>, 2, <u>3</u>, 4, <u>5</u>, 6, <u>7</u>, 8, <u>9</u>]\narr = [2, <u>4</u>, 6, <u>8</u>]\narr = [<u>2</u>, 6]\narr = [6]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "391": {"__typename": "QuestionLightNode", "acRate": 0.45995540798485796, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "391", "isFavor": false, "solutionNum": 338, "title": "Perfect Rectangle", "titleCn": "完美矩形", "titleSlug": "perfect-rectangle", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "x54mxi3", "name": "Line Sweep", "slug": "line-sweep", "nameTranslated": "扫描线", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [x<sub>i</sub>, y<sub>i</sub>, a<sub>i</sub>, b<sub>i</sub>]</code> 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 <code>(x<sub>i</sub>, y<sub>i</sub>)</code> ，右上顶点是 <code>(a<sub>i</sub>, b<sub>i</sub>)</code> 。</p>\n\n<p>如果所有矩形一起精确覆盖了某个矩形区域，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perectrec1-plane.jpg\" style=\"height: 294px; width: 300px;\" />\n<pre>\n<strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]\n<strong>输出：</strong>true\n<strong>解释：</strong>5 个矩形一起可以精确地覆盖一个矩形区域。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfectrec2-plane.jpg\" style=\"height: 294px; width: 300px;\" />\n<pre>\n<strong>输入：</strong>rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>两个矩形之间有间隔，无法覆盖成一个矩形。</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfecrrec4-plane.jpg\" style=\"height: 294px; width: 300px;\" />\n<pre>\n<strong>输入：</strong>rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]\n<strong>输出：</strong>false\n<strong>解释：</strong>因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rectangles.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>rectangles[i].length == 4</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= x<sub>i</sub>, y<sub>i</sub>, a<sub>i</sub>, b<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>Given an array <code>rectangles</code> where <code>rectangles[i] = [x<sub>i</sub>, y<sub>i</sub>, a<sub>i</sub>, b<sub>i</sub>]</code> represents an axis-aligned rectangle. The bottom-left point of the rectangle is <code>(x<sub>i</sub>, y<sub>i</sub>)</code> and the top-right point of it is <code>(a<sub>i</sub>, b<sub>i</sub>)</code>.</p>\n\n<p>Return <code>true</code> <em>if all the rectangles together form an exact cover of a rectangular region</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perectrec1-plane.jpg\" style=\"width: 300px; height: 294px;\" />\n<pre>\n<strong>Input:</strong> rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> All 5 rectangles together form an exact cover of a rectangular region.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfectrec2-plane.jpg\" style=\"width: 300px; height: 294px;\" />\n<pre>\n<strong>Input:</strong> rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Because there is a gap between the two rectangular regions.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/27/perfecrrec4-plane.jpg\" style=\"width: 300px; height: 294px;\" />\n<pre>\n<strong>Input:</strong> rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Because two of the rectangles overlap with each other.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rectangles.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>rectangles[i].length == 4</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= x<sub>i</sub>, y<sub>i</sub>, a<sub>i</sub>, b<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "392": {"__typename": "QuestionLightNode", "acRate": 0.5242344430793354, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "392", "isFavor": false, "solutionNum": 3296, "title": "Is Subsequence", "titleCn": "判断子序列", "titleSlug": "is-subsequence", "topicTags": [{"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 60, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>\n\n<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>\"ace\"</code>是<code>\"abcde\"</code>的一个子序列，而<code>\"aec\"</code>不是）。</p>\n\n<p><strong>进阶：</strong></p>\n\n<p>如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>\n\n<p><strong>致谢：</strong></p>\n\n<p>特别感谢<strong> </strong><a href=\"https://leetcode.com/pbrother/\">@pbrother </a>添加此问题并且创建所有测试用例。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\", t = \"ahbgdc\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"axc\", t = \"ahbgdc\"\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= s.length <= 100</code></li>\n\t<li><code>0 <= t.length <= 10^4</code></li>\n\t<li>两个字符串都只由小写字符组成。</li>\n</ul>\n", "en": "<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code><em> if </em><code>s</code><em> is a <strong>subsequence</strong> of </em><code>t</code><em>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>A <strong>subsequence</strong> of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;<u>a</u>b<u>c</u>d<u>e</u>&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"abc\", t = \"ahbgdc\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"axc\", t = \"ahbgdc\"\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= t.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist only of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Suppose there are lots of incoming <code>s</code>, say <code>s<sub>1</sub>, s<sub>2</sub>, ..., s<sub>k</sub></code> where <code>k &gt;= 10<sup>9</sup></code>, and you want to check one by one to see if <code>t</code> has its subsequence. In this scenario, how would you change your code?"}}, "393": {"__typename": "QuestionLightNode", "acRate": 0.43667284700466724, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "393", "isFavor": false, "solutionNum": 505, "title": "UTF-8 Validation", "titleCn": "UTF-8 编码验证", "titleSlug": "utf-8-validation", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 28, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1710493537-jqtLQv-Palantir.png", "slug": "palantir-technologies", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个表示数据的整数数组&nbsp;<code>data</code>&nbsp;，返回它是否为有效的 <strong>UTF-8</strong> 编码。</p>\n\n<p><strong>UTF-8</strong> 中的一个字符可能的长度为 <strong>1 到 4 字节</strong>，遵循以下的规则：</p>\n\n<ol>\n\t<li>对于 <strong>1 字节</strong>&nbsp;的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。</li>\n\t<li>对于 <strong>n 字节</strong>&nbsp;的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。</li>\n</ol>\n\n<p>这是 UTF-8 编码的工作方式：</p>\n\n<pre>\n<code>      </code>Number of Bytes<code>  |        UTF-8 octet sequence\n                       |              (binary)\n   --------------------+---------------------------------------------\n            1          | 0xxxxxxx\n            2          | 110xxxxx 10xxxxxx\n            3          | 1110xxxx 10xxxxxx 10xxxxxx\n            4          | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n</code></pre>\n\n<p><code>x</code>&nbsp;表示二进制形式的一位，可以是 <code>0</code>&nbsp;或 <code>1</code>。</p>\n\n<p><strong>注意：</strong>输入是整数数组。只有每个整数的 <strong>最低 8 个有效位</strong> 用来存储数据。这意味着每个整数只表示 1 字节的数据。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>data = [197,130,1]\n<strong>输出：</strong>true\n<strong>解释：</strong>数据表示字节序列:<strong>11000101 10000010 00000001</strong>。\n这是有效的 utf-8 编码，为一个 2 字节字符，跟着一个 1 字节字符。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>data = [235,140,4]\n<strong>输出：</strong>false\n<strong>解释：</strong>数据表示 8 位的序列: <strong>11101011 10001100 00000100</strong>.\n前 3 位都是 1 ，第 4 位为 0 表示它是一个 3 字节字符。\n下一个字节是开头为 10 的延续字节，这是正确的。\n但第二个延续字节不以 10 开头，所以是不符合规则的。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= data.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= data[i] &lt;= 255</code></li>\n</ul>\n", "en": "<p>Given an integer array <code>data</code> representing the data, return whether it is a valid <strong>UTF-8</strong> encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).</p>\n\n<p>A character in <strong>UTF8</strong> can be from <strong>1 to 4 bytes</strong> long, subjected to the following rules:</p>\n\n<ol>\n\t<li>For a <strong>1-byte</strong> character, the first bit is a <code>0</code>, followed by its Unicode code.</li>\n\t<li>For an <strong>n-bytes</strong> character, the first <code>n</code> bits are all one&#39;s, the <code>n + 1</code> bit is <code>0</code>, followed by <code>n - 1</code> bytes with the most significant <code>2</code> bits being <code>10</code>.</li>\n</ol>\n\n<p>This is how the UTF-8 encoding would work:</p>\n\n<pre>\n     Number of Bytes   |        UTF-8 Octet Sequence\n                       |              (binary)\n   --------------------+-----------------------------------------\n            1          |   0xxxxxxx\n            2          |   110xxxxx 10xxxxxx\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n</pre>\n\n<p><code>x</code> denotes a bit in the binary form of a byte that may be either <code>0</code> or <code>1</code>.</p>\n\n<p><strong>Note: </strong>The input is an array of integers. Only the <strong>least significant 8 bits</strong> of each integer is used to store the data. This means each integer represents only 1 byte of data.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> data = [197,130,1]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> data represents the octet sequence: 11000101 10000010 00000001.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> data = [235,140,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> data represented the octet sequence: 11101011 10001100 00000100.\nThe first 3 bits are all one&#39;s and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that&#39;s correct.\nBut the second continuation byte does not start with 10, so it is invalid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= data.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= data[i] &lt;= 255</code></li>\n</ul>\n"}}, "394": {"__typename": "QuestionLightNode", "acRate": 0.5745222858718865, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "394", "isFavor": false, "solutionNum": 2601, "title": "Decode String", "titleCn": "字符串解码", "titleSlug": "decode-string", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 97, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>\n\n<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p>\n\n<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>\n\n<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像&nbsp;<code>3a</code>&nbsp;或&nbsp;<code>2[4]</code>&nbsp;的输入。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"3[a]2[bc]\"\n<strong>输出：</strong>\"aaabcbc\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"3[a2[c]]\"\n<strong>输出：</strong>\"accaccacc\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"2[abc]3[cd]ef\"\n<strong>输出：</strong>\"abcabccdcdcdef\"\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc3[cd]xyz\"\n<strong>输出：</strong>\"abccdcdcdxyz\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 30</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>s</code>&nbsp;由小写英文字母、数字和方括号<meta charset=\"UTF-8\" />&nbsp;<code>'[]'</code> 组成</li>\n\t<li><code>s</code>&nbsp;保证是一个&nbsp;<strong>有效</strong>&nbsp;的输入。</li>\n\t<li><code>s</code>&nbsp;中所有整数的取值范围为<meta charset=\"UTF-8\" />&nbsp;<code>[1, 300]</code>&nbsp;</li>\n</ul>\n", "en": "<p>Given an encoded string, return its decoded string.</p>\n\n<p>The encoding rule is: <code>k[encoded_string]</code>, where the <code>encoded_string</code> inside the square brackets is being repeated exactly <code>k</code> times. Note that <code>k</code> is guaranteed to be a positive integer.</p>\n\n<p>You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <code>k</code>. For example, there will not be input like <code>3a</code> or <code>2[4]</code>.</p>\n\n<p>The test cases are generated so that the length of the output will never exceed <code>10<sup>5</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;3[a]2[bc]&quot;\n<strong>Output:</strong> &quot;aaabcbc&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;3[a2[c]]&quot;\n<strong>Output:</strong> &quot;accaccacc&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;2[abc]3[cd]ef&quot;\n<strong>Output:</strong> &quot;abcabccdcdcdef&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 30</code></li>\n\t<li><code>s</code> consists of lowercase English letters, digits, and square brackets <code>&#39;[]&#39;</code>.</li>\n\t<li><code>s</code> is guaranteed to be <strong>a valid</strong> input.</li>\n\t<li>All the integers in <code>s</code> are in the range <code>[1, 300]</code>.</li>\n</ul>\n"}}, "395": {"__typename": "QuestionLightNode", "acRate": 0.5258934796788196, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "395", "isFavor": false, "solutionNum": 710, "title": "Longest Substring with At Least K Repeating Characters", "titleCn": "至少有 K 个重复字符的最长子串", "titleSlug": "longest-substring-with-at-least-k-repeating-characters", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 40, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> ，请你找出 <code>s</code> 中的最长子串，&nbsp;要求该子串中的每一字符出现次数都不少于 <code>k</code> 。返回这一子串的长度。</p>\n\n<p data-pm-slice=\"1 1 []\">如果不存在这样的子字符串，则返回 0。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaabb\", k = 3\n<strong>输出：</strong>3\n<strong>解释：</strong>最长子串为 \"aaa\" ，其中 'a' 重复了 3 次。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ababbc\", k = 2\n<strong>输出：</strong>5\n<strong>解释：</strong>最长子串为 \"ababb\" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>Given a string <code>s</code> and an integer <code>k</code>, return <em>the length of the longest substring of</em> <code>s</code> <em>such that the frequency of each character in this substring is greater than or equal to</em> <code>k</code>.</p>\n\n<p data-pm-slice=\"1 1 []\">if no such substring exists, return 0.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aaabb&quot;, k = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The longest substring is &quot;aaa&quot;, as &#39;a&#39; is repeated 3 times.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ababbc&quot;, k = 2\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The longest substring is &quot;ababb&quot;, as &#39;a&#39; is repeated 2 times and &#39;b&#39; is repeated 3 times.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of only lowercase English letters.</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "396": {"__typename": "QuestionLightNode", "acRate": 0.5278106622777891, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "396", "isFavor": false, "solutionNum": 632, "title": "Rotate Function", "titleCn": "旋转函数", "titleSlug": "rotate-function", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个长度为 <code>n</code> 的整数数组&nbsp;<code>nums</code>&nbsp;。</p>\n\n<p>假设&nbsp;<code>arr<sub>k</sub></code>&nbsp;是数组&nbsp;<code>nums</code>&nbsp;顺时针旋转 <code>k</code> 个位置后的数组，我们定义&nbsp;<code>nums</code>&nbsp;的 <strong>旋转函数</strong>&nbsp;&nbsp;<code>F</code>&nbsp;为：</p>\n\n<ul>\n\t<li><code>F(k) = 0 * arr<sub>k</sub>[0] + 1 * arr<sub>k</sub>[1] + ... + (n - 1) * arr<sub>k</sub>[n - 1]</code></li>\n</ul>\n\n<p>返回&nbsp;<em><code>F(0), F(1), ..., F(n-1)</code>中的最大值&nbsp;</em>。</p>\n\n<p>生成的测试用例让答案符合&nbsp;<strong>32 位</strong> 整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [4,3,2,6]\n<strong>输出:</strong> 26\n<strong>解释:</strong>\nF(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\nF(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\nF(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\nF(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [100]\n<strong>输出:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n", "en": "<p>You are given an integer array <code>nums</code> of length <code>n</code>.</p>\n\n<p>Assume <code>arr<sub>k</sub></code> to be an array obtained by rotating <code>nums</code> by <code>k</code> positions clock-wise. We define the <strong>rotation function</strong> <code>F</code> on <code>nums</code> as follow:</p>\n\n<ul>\n\t<li><code>F(k) = 0 * arr<sub>k</sub>[0] + 1 * arr<sub>k</sub>[1] + ... + (n - 1) * arr<sub>k</sub>[n - 1].</code></li>\n</ul>\n\n<p>Return <em>the maximum value of</em> <code>F(0), F(1), ..., F(n-1)</code>.</p>\n\n<p>The test cases are generated so that the answer fits in a <strong>32-bit</strong> integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,3,2,6]\n<strong>Output:</strong> 26\n<strong>Explanation:</strong>\nF(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\nF(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\nF(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\nF(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\nSo the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [100]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n"}}, "397": {"__typename": "QuestionLightNode", "acRate": 0.42268171578318237, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "397", "isFavor": false, "solutionNum": 742, "title": "Integer Replacement", "titleCn": "整数替换", "titleSlug": "integer-replacement", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "vhos7", "name": "Memoization", "slug": "memoization", "nameTranslated": "记忆化搜索", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 30, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个正整数&nbsp;<code>n</code> ，你可以做如下操作：</p>\n\n<ol>\n\t<li>如果&nbsp;<code>n</code><em>&nbsp;</em>是偶数，则用&nbsp;<code>n / 2</code>替换&nbsp;<code>n</code><em> </em>。</li>\n\t<li>如果&nbsp;<code>n</code><em>&nbsp;</em>是奇数，则可以用&nbsp;<code>n + 1</code>或<code>n - 1</code>替换&nbsp;<code>n</code> 。</li>\n</ol>\n\n<p>返回 <code>n</code><em>&nbsp;</em>变为 <code>1</code> 所需的 <em>最小替换次数</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 8\n<strong>输出：</strong>3\n<strong>解释：</strong>8 -&gt; 4 -&gt; 2 -&gt; 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7\n<strong>输出：</strong>4\n<strong>解释：</strong>7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1\n或 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given a positive integer <code>n</code>,&nbsp;you can apply one of the following&nbsp;operations:</p>\n\n<ol>\n\t<li>If <code>n</code> is even, replace <code>n</code> with <code>n / 2</code>.</li>\n\t<li>If <code>n</code> is odd, replace <code>n</code> with either <code>n + 1</code> or <code>n - 1</code>.</li>\n</ol>\n\n<p>Return <em>the minimum number of operations needed for</em> <code>n</code> <em>to become</em> <code>1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 8\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 8 -&gt; 4 -&gt; 2 -&gt; 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 7\n<strong>Output:</strong> 4\n<strong>Explanation: </strong>7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1\nor 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "398": {"__typename": "QuestionLightNode", "acRate": 0.689535483131909, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "398", "isFavor": false, "solutionNum": 481, "title": "Random Pick Index", "titleCn": "随机数索引", "titleSlug": "random-pick-index", "topicTags": [{"id": "veg8i", "name": "Reservoir Sampling", "slug": "reservoir-sampling", "nameTranslated": "水塘抽样", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "xp2m6at", "name": "Randomized", "slug": "randomized", "nameTranslated": "随机化", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 22, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个可能含有 <strong>重复元素</strong> 的整数数组&nbsp;<code>nums</code> ，请你随机输出给定的目标数字&nbsp;<code>target</code> 的索引。你可以假设给定的数字一定存在于数组中。</p>\n\n<p>实现 <code>Solution</code> 类：</p>\n\n<ul>\n\t<li><code>Solution(int[] nums)</code> 用数组 <code>nums</code> 初始化对象。</li>\n\t<li><code>int pick(int target)</code> 从 <code>nums</code> 中选出一个满足 <code>nums[i] == target</code> 的随机索引 <code>i</code> 。如果存在多个有效的索引，则每个索引的返回概率应当相等。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"Solution\", \"pick\", \"pick\", \"pick\"]\n[[[1, 2, 3, 3, 3]], [3], [1], [3]]\n<strong>输出</strong>\n[null, 4, 0, 2]\n\n<strong>解释</strong>\nSolution solution = new Solution([1, 2, 3, 3, 3]);\nsolution.pick(3); // 随机返回索引 2, 3 或者 4 之一。每个索引的返回概率应该相等。\nsolution.pick(1); // 返回 0 。因为只有 nums[0] 等于 1 。\nsolution.pick(3); // 随机返回索引 2, 3 或者 4 之一。每个索引的返回概率应该相等。\n</pre>\n\n<p>&nbsp;</p>\n\n<div class=\"top-view__1vxA\">\n<div class=\"original__bRMd\">\n<div>\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>target</code> 是 <code>nums</code> 中的一个整数</li>\n\t<li>最多调用 <code>pick</code> 函数 <code>10<sup>4</sup></code> 次</li>\n</ul>\n</div>\n</div>\n</div>\n\n<div class=\"fullscreen-btn-layer__2kn7\">&nbsp;</div>\n", "en": "<p>Given an integer array <code>nums</code> with possible <strong>duplicates</strong>, randomly output the index of a given <code>target</code> number. You can assume that the given target number must exist in the array.</p>\n\n<p>Implement the <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution(int[] nums)</code> Initializes the object with the array <code>nums</code>.</li>\n\t<li><code>int pick(int target)</code> Picks a random index <code>i</code> from <code>nums</code> where <code>nums[i] == target</code>. If there are multiple valid i&#39;s, then each index should have an equal probability of returning.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Solution&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;]\n[[[1, 2, 3, 3, 3]], [3], [1], [3]]\n<strong>Output</strong>\n[null, 4, 0, 2]\n\n<strong>Explanation</strong>\nSolution solution = new Solution([1, 2, 3, 3, 3]);\nsolution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\nsolution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1.\nsolution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>target</code> is an integer from <code>nums</code>.</li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>pick</code>.</li>\n</ul>\n"}}, "399": {"__typename": "QuestionLightNode", "acRate": 0.586249070426344, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "399", "isFavor": false, "solutionNum": 1037, "title": "Evaluate Division", "titleCn": "除法求值", "titleSlug": "evaluate-division", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "n6a2i", "name": "Union Find", "slug": "union-find", "nameTranslated": "并查集", "__typename": "CommonTagNode"}, {"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "48rxpj", "name": "Shortest Path", "slug": "shortest-path", "nameTranslated": "最短路", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 40, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [A<sub>i</sub>, B<sub>i</sub>]</code> 和 <code>values[i]</code> 共同表示等式 <code>A<sub>i</sub> / B<sub>i</sub> = values[i]</code> 。每个 <code>A<sub>i</sub></code> 或 <code>B<sub>i</sub></code> 是一个表示单个变量的字符串。</p>\n\n<p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [C<sub>j</sub>, D<sub>j</sub>]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>C<sub>j</sub> / D<sub>j</sub> = ?</code> 的结果作为答案。</p>\n\n<p>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 <code>-1.0</code> 替代这个答案。</p>\n\n<p><strong>注意：</strong>输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p>\n\n<p><strong>注意：</strong>未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n<strong>输出：</strong>[6.00000,0.50000,-1.00000,1.00000,-1.00000]\n<strong>解释：</strong>\n条件：<em>a / b = 2.0</em>, <em>b / c = 3.0</em>\n问题：<em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ?</em>\n结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]\n注意：x 是未定义的 =&gt; -1.0</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n<strong>输出：</strong>[3.75000,0.40000,5.00000,0.20000]\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n<strong>输出：</strong>[0.50000,2.00000,-1.00000,-1.00000]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= equations.length &lt;= 20</code></li>\n\t<li><code>equations[i].length == 2</code></li>\n\t<li><code>1 &lt;= A<sub>i</sub>.length, B<sub>i</sub>.length &lt;= 5</code></li>\n\t<li><code>values.length == equations.length</code></li>\n\t<li><code>0.0 &lt; values[i] &lt;= 20.0</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 20</code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 &lt;= C<sub>j</sub>.length, D<sub>j</sub>.length &lt;= 5</code></li>\n\t<li><code>A<sub>i</sub>, B<sub>i</sub>, C<sub>j</sub>, D<sub>j</sub></code> 由小写英文字母与数字组成</li>\n</ul>\n", "en": "<p>You are given an array of variable pairs <code>equations</code> and an array of real numbers <code>values</code>, where <code>equations[i] = [A<sub>i</sub>, B<sub>i</sub>]</code> and <code>values[i]</code> represent the equation <code>A<sub>i</sub> / B<sub>i</sub> = values[i]</code>. Each <code>A<sub>i</sub></code> or <code>B<sub>i</sub></code> is a string that represents a single variable.</p>\n\n<p>You are also given some <code>queries</code>, where <code>queries[j] = [C<sub>j</sub>, D<sub>j</sub>]</code> represents the <code>j<sup>th</sup></code> query where you must find the answer for <code>C<sub>j</sub> / D<sub>j</sub> = ?</code>.</p>\n\n<p>Return <em>the answers to all queries</em>. If a single answer cannot be determined, return <code>-1.0</code>.</p>\n\n<p><strong>Note:</strong> The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p>\n\n<p><strong>Note:&nbsp;</strong>The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]\n<strong>Output:</strong> [6.00000,0.50000,-1.00000,1.00000,-1.00000]\n<strong>Explanation:</strong> \nGiven: <em>a / b = 2.0</em>, <em>b / c = 3.0</em>\nqueries are: <em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ? </em>\nreturn: [6.0, 0.5, -1.0, 1.0, -1.0 ]\nnote: x is undefined =&gt; -1.0</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]\n<strong>Output:</strong> [3.75000,0.40000,5.00000,0.20000]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]\n<strong>Output:</strong> [0.50000,2.00000,-1.00000,-1.00000]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= equations.length &lt;= 20</code></li>\n\t<li><code>equations[i].length == 2</code></li>\n\t<li><code>1 &lt;= A<sub>i</sub>.length, B<sub>i</sub>.length &lt;= 5</code></li>\n\t<li><code>values.length == equations.length</code></li>\n\t<li><code>0.0 &lt; values[i] &lt;= 20.0</code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 20</code></li>\n\t<li><code>queries[i].length == 2</code></li>\n\t<li><code>1 &lt;= C<sub>j</sub>.length, D<sub>j</sub>.length &lt;= 5</code></li>\n\t<li><code>A<sub>i</sub>, B<sub>i</sub>, C<sub>j</sub>, D<sub>j</sub></code> consist of lower case English letters and digits.</li>\n</ul>\n"}}, "400": {"__typename": "QuestionLightNode", "acRate": 0.45565442951327595, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "400", "isFavor": false, "solutionNum": 654, "title": "Nth Digit", "titleCn": "第 N 位数字", "titleSlug": "nth-digit", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 29, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数 <code>n</code> ，请你在无限的整数序列&nbsp;<code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]</code> 中找出并返回第&nbsp;<code>n</code><em> </em>位上的数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 11\n<strong>输出：</strong>0\n<strong>解释：</strong>第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是 <strong>0 </strong>，它是 10 的一部分。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given an integer <code>n</code>, return the <code>n<sup>th</sup></code> digit of the infinite integer sequence <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 11\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The 11<sup>th</sup> digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "401": {"__typename": "QuestionLightNode", "acRate": 0.6285610582351993, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "401", "isFavor": false, "solutionNum": 928, "title": "Binary Watch", "titleCn": "二进制手表", "titleSlug": "binary-watch", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>二进制手表顶部有 4 个 LED 代表<strong> 小时（0-11）</strong>，底部的 6 个 LED 代表<strong> 分钟（0-59）</strong>。每个 LED 代表一个 0 或 1，最低位在右侧。</p>\n\n<ul>\n\t<li>例如，下面的二进制手表读取 <code>\"4:51\"</code> 。</li>\n</ul>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/08/binarywatch.jpg\" style=\"height: 300px; width\" /></p>\n\n<p>给你一个整数 <code>turnedOn</code> ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 <strong>按任意顺序</strong> 返回答案。</p>\n\n<p>小时不会以零开头：</p>\n\n<ul>\n\t<li>例如，<code>\"01:00\"</code> 是无效的时间，正确的写法应该是 <code>\"1:00\"</code> 。</li>\n</ul>\n\n<p>分钟必须由两位数组成，可能会以零开头：</p>\n\n<ul>\n\t<li>例如，<code>\"10:2\"</code> 是无效的时间，正确的写法应该是 <code>\"10:02\"</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>turnedOn = 1\n<strong>输出：</strong>[\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>turnedOn = 9\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= turnedOn &lt;= 10</code></li>\n</ul>\n", "en": "<p>A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent&nbsp;the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.</p>\n\n<ul>\n\t<li>For example, the below binary watch reads <code>&quot;4:51&quot;</code>.</li>\n</ul>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/binarywatch.jpg\" style=\"width: 500px; height: 500px;\" /></p>\n\n<p>Given an integer <code>turnedOn</code> which represents the number of LEDs that are currently on (ignoring the PM), return <em>all possible times the watch could represent</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>The hour must not contain a leading zero.</p>\n\n<ul>\n\t<li>For example, <code>&quot;01:00&quot;</code> is not valid. It should be <code>&quot;1:00&quot;</code>.</li>\n</ul>\n\n<p>The minute must&nbsp;consist of two digits and may contain a leading zero.</p>\n\n<ul>\n\t<li>For example, <code>&quot;10:2&quot;</code> is not valid. It should be <code>&quot;10:02&quot;</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> turnedOn = 1\n<strong>Output:</strong> [\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> turnedOn = 9\n<strong>Output:</strong> []\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= turnedOn &lt;= 10</code></li>\n</ul>\n"}}, "402": {"__typename": "QuestionLightNode", "acRate": 0.3189210385107525, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "402", "isFavor": false, "solutionNum": 1012, "title": "Remove K Digits", "titleCn": "移掉 K 位数字", "titleSlug": "remove-k-digits", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "xeyj5r5", "name": "Monotonic Stack", "slug": "monotonic-stack", "nameTranslated": "单调栈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 60, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code><em> </em>位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>\n \n\n<p><strong>示例 1 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"1432219\", k = 3\n<strong>输出：</strong>\"1219\"\n<strong>解释：</strong>移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。\n</pre>\n\n<p><strong>示例 2 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"10200\", k = 1\n<strong>输出：</strong>\"200\"\n<strong>解释：</strong>移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。\n</pre>\n\n<p><strong>示例 3 ：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = \"10\", k = 2\n<strong>输出：</strong>\"0\"\n<strong>解释：</strong>从原数字移除所有的数字，剩余为空就是 0 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k <= num.length <= 10<sup>5</sup></code></li>\n\t<li><code>num</code> 仅由若干位数字（0 - 9）组成</li>\n\t<li>除了 <strong>0</strong> 本身之外，<code>num</code> 不含任何前导零</li>\n</ul>\n", "en": "<p>Given string num representing a non-negative integer <code>num</code>, and an integer <code>k</code>, return <em>the smallest possible integer after removing</em> <code>k</code> <em>digits from</em> <code>num</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;1432219&quot;, k = 3\n<strong>Output:</strong> &quot;1219&quot;\n<strong>Explanation:</strong> Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;10200&quot;, k = 1\n<strong>Output:</strong> &quot;200&quot;\n<strong>Explanation:</strong> Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;10&quot;, k = 2\n<strong>Output:</strong> &quot;0&quot;\n<strong>Explanation:</strong> Remove all the digits from the number and it is left with nothing which is 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= num.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>num</code> consists of only digits.</li>\n\t<li><code>num</code> does not have any leading zeros except for the zero itself.</li>\n</ul>\n"}}, "403": {"__typename": "QuestionLightNode", "acRate": 0.46148795887578925, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "403", "isFavor": false, "solutionNum": 592, "title": "Frog Jump", "titleCn": "青蛙过河", "titleSlug": "frog-jump", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 44, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p>\n\n<p>给你石子的位置列表 <code>stones</code>（用单元格序号 <strong>升序</strong> 表示），&nbsp;请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。开始时，&nbsp;青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 <code>1</code> 个单位（即只能从单元格 1 跳至单元格 2 ）。</p>\n\n<p>如果青蛙上一步跳跃了&nbsp;<code>k</code><em>&nbsp;</em>个单位，那么它接下来的跳跃距离只能选择为&nbsp;<code>k - 1</code>、<code>k</code><em>&nbsp;</em>或&nbsp;<code>k + 1</code> 个单位。&nbsp;另请注意，青蛙只能向前方（终点的方向）跳跃。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [0,1,3,5,6,8,12,17]\n<strong>输出：</strong>true\n<strong>解释：</strong>青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>stones = [0,1,2,3,4,8,9,11]\n<strong>输出：</strong>false\n<strong>解释：</strong>这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= stones.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= stones[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>stones[0] == 0</code></li>\n\t<li><code>stones</code>&nbsp;按严格升序排列</li>\n</ul>\n", "en": "<p>A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.</p>\n\n<p>Given a list of <code>stones</code>&nbsp;positions (in units) in sorted <strong>ascending order</strong>, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be <code>1</code> unit.</p>\n\n<p>If the frog&#39;s last jump was <code>k</code> units, its next jump must be either <code>k - 1</code>, <code>k</code>, or <code>k + 1</code> units. The frog can only jump in the forward direction.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> stones = [0,1,3,5,6,8,12,17]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> stones = [0,1,2,3,4,8,9,11]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= stones.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= stones[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>stones[0] == 0</code></li>\n\t<li><code>stones</code>&nbsp;is sorted in a strictly increasing order.</li>\n</ul>\n"}}, "404": {"__typename": "QuestionLightNode", "acRate": 0.6277146247741985, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "404", "isFavor": false, "solutionNum": 2367, "title": "Sum of Left Leaves", "titleCn": "左叶子之和", "titleSlug": "sum-of-left-leaves", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 31, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定二叉树的根节点&nbsp;<code>root</code>&nbsp;，返回所有左叶子之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [3,9,20,null,null,15,7] \n<strong>输出:</strong> 24 \n<strong>解释:</strong> 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> root = [1]\n<strong>输出:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>节点数在&nbsp;<code>[1, 1000]</code>&nbsp;范围内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n", "en": "<p>Given the <code>root</code> of a binary tree, return <em>the sum of all left leaves.</em></p>\n\n<p>A <strong>leaf</strong> is a node with no children. A <strong>left leaf</strong> is a leaf that is the left child of another node.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> 24\n<strong>Explanation:</strong> There are two left leaves in the binary tree, with values 9 and 15 respectively.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n"}}, "405": {"__typename": "QuestionLightNode", "acRate": 0.5466783772733468, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "405", "isFavor": false, "solutionNum": 683, "title": "Convert a Number to Hexadecimal", "titleCn": "数字转换为十六进制数", "titleSlug": "convert-a-number-to-hexadecimal", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用&nbsp;<a href=\"https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fr=aladdin\">补码运算</a>&nbsp;方法。</p>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>十六进制中所有字母(<code>a-f</code>)都必须是小写。</li>\n\t<li>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符<code>&#39;0&#39;</code>来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。&nbsp;</li>\n\t<li>给定的数确保在32位有符号整数范围内。</li>\n\t<li><strong>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</strong></li>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n输入:\n26\n\n输出:\n&quot;1a&quot;\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n输入:\n-1\n\n输出:\n&quot;ffffffff&quot;\n</pre>\n", "en": "<p>Given an integer <code>num</code>, return <em>a string representing its hexadecimal representation</em>. For negative integers, <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" target=\"_blank\">two&rsquo;s complement</a> method is used.</p>\n\n<p>All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself.</p>\n\n<p><strong>Note:&nbsp;</strong>You are not allowed to use any built-in library method to directly solve this problem.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> num = 26\n<strong>Output:</strong> \"1a\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> num = -1\n<strong>Output:</strong> \"ffffffff\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= num &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "406": {"__typename": "QuestionLightNode", "acRate": 0.7644279580354499, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "406", "isFavor": false, "solutionNum": 1563, "title": "Queue Reconstruction by Height", "titleCn": "根据身高重建队列", "titleSlug": "queue-reconstruction-by-height", "topicTags": [{"id": "n16hs", "name": "Binary Indexed Tree", "slug": "binary-indexed-tree", "nameTranslated": "树状数组", "__typename": "CommonTagNode"}, {"id": "nytfd", "name": "Segment Tree", "slug": "segment-tree", "nameTranslated": "线段树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 42, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [h<sub>i</sub>, k<sub>i</sub>]</code> 表示第 <code>i</code> 个人的身高为 <code>h<sub>i</sub></code> ，前面 <strong>正好</strong> 有 <code>k<sub>i</sub></code><sub> </sub>个身高大于或等于 <code>h<sub>i</sub></code> 的人。</p>\n\n<p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [h<sub>j</sub>, k<sub>j</sub>]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>\n\n<p> </p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\n<strong>输出：</strong>[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n<strong>解释：</strong>\n编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。\n编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。\n编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。\n编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。\n编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。\n因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]\n<strong>输出：</strong>[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= people.length <= 2000</code></li>\n\t<li><code>0 <= h<sub>i</sub> <= 10<sup>6</sup></code></li>\n\t<li><code>0 <= k<sub>i</sub> < people.length</code></li>\n\t<li>题目数据确保队列可以被重建</li>\n</ul>\n", "en": "<p>You are given an array of people, <code>people</code>, which are the attributes of some people in a queue (not necessarily in order). Each <code>people[i] = [h<sub>i</sub>, k<sub>i</sub>]</code> represents the <code>i<sup>th</sup></code> person of height <code>h<sub>i</sub></code> with <strong>exactly</strong> <code>k<sub>i</sub></code> other people in front who have a height greater than or equal to <code>h<sub>i</sub></code>.</p>\n\n<p>Reconstruct and return <em>the queue that is represented by the input array </em><code>people</code>. The returned queue should be formatted as an array <code>queue</code>, where <code>queue[j] = [h<sub>j</sub>, k<sub>j</sub>]</code> is the attributes of the <code>j<sup>th</sup></code> person in the queue (<code>queue[0]</code> is the person at the front of the queue).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\n<strong>Output:</strong> [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]\n<strong>Explanation:</strong>\nPerson 0 has height 5 with no other people taller or the same height in front.\nPerson 1 has height 7 with no other people taller or the same height in front.\nPerson 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.\nPerson 3 has height 6 with one person taller or the same height in front, which is person 1.\nPerson 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.\nPerson 5 has height 7 with one person taller or the same height in front, which is person 1.\nHence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]\n<strong>Output:</strong> [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= people.length &lt;= 2000</code></li>\n\t<li><code>0 &lt;= h<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n\t<li><code>0 &lt;= k<sub>i</sub> &lt; people.length</code></li>\n\t<li>It is guaranteed that the queue can be reconstructed.</li>\n</ul>\n"}}, "407": {"__typename": "QuestionLightNode", "acRate": 0.5706523361695776, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "407", "isFavor": false, "solutionNum": 324, "title": "Trapping Rain Water II", "titleCn": "接雨水 II", "titleSlug": "trapping-rain-water-ii", "topicTags": [{"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 47, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个&nbsp;<code>m x n</code>&nbsp;的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\n<strong>输出:</strong> 10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>m == heightMap.length</code></li>\n\t<li><code>n == heightMap[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= heightMap[i][j] &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n", "en": "<p>Given an <code>m x n</code> integer matrix <code>heightMap</code> representing the height of each unit cell in a 2D elevation map, return <em>the volume of water it can trap after raining</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg\" style=\"width: 361px; height: 321px;\" />\n<pre>\n<strong>Input:</strong> heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> After the rain, water is trapped between the blocks.\nWe have two small ponds 1 and 3 units trapped.\nThe total volume of water trapped is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg\" style=\"width: 401px; height: 321px;\" />\n<pre>\n<strong>Input:</strong> heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\n<strong>Output:</strong> 10\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == heightMap.length</code></li>\n\t<li><code>n == heightMap[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= heightMap[i][j] &lt;= 2 * 10<sup>4</sup></code></li>\n</ul>\n"}}, "408": {"__typename": "QuestionLightNode", "acRate": 0.3617546065676839, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "408", "isFavor": false, "solutionNum": 129, "title": "Valid Word Abbreviation", "titleCn": "有效单词缩写", "titleSlug": "valid-word-abbreviation", "topicTags": [{"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 12, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "409": {"__typename": "QuestionLightNode", "acRate": 0.5564409030544488, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "409", "isFavor": false, "solutionNum": 2230, "title": "Longest Palindrome", "titleCn": "最长回文串", "titleSlug": "longest-palindrome", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 45, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个包含大写字母和小写字母的字符串<meta charset=\"UTF-8\" />&nbsp;<code>s</code>&nbsp;，返回&nbsp;<em>通过这些字母构造成的 <strong>最长的回文串</strong></em>&nbsp;。</p>\n\n<p>在构造过程中，请注意 <strong>区分大小写</strong> 。比如&nbsp;<code>\"Aa\"</code>&nbsp;不能当做一个回文字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1: </strong></p>\n\n<pre>\n<strong>输入:</strong>s = \"abccccdd\"\n<strong>输出:</strong>7\n<strong>解释:</strong>\n我们可以构造的最长的回文串是\"dccaccd\", 它的长度是 7。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong>s = \"a\"\n<strong>输出:</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入:</strong>s = \"aaaaaccc\"\n<strong>输出:</strong>7</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code>&nbsp;只由小写 <strong>和/或</strong> 大写英文字母组成</li>\n</ul>\n", "en": "<p>Given a string <code>s</code> which consists of lowercase or uppercase letters, return <em>the length of the <strong>longest palindrome</strong></em>&nbsp;that can be built with those letters.</p>\n\n<p>Letters are <strong>case sensitive</strong>, for example,&nbsp;<code>&quot;Aa&quot;</code> is not considered a palindrome here.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abccccdd&quot;\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The longest palindrome that can be built is &quot;a&quot;, whose length is 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2000</code></li>\n\t<li><code>s</code> consists of lowercase <strong>and/or</strong> uppercase English&nbsp;letters only.</li>\n</ul>\n"}}, "410": {"__typename": "QuestionLightNode", "acRate": 0.604560211503952, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "410", "isFavor": false, "solutionNum": 677, "title": "Split Array Largest Sum", "titleCn": "分割数组的最大值", "titleSlug": "split-array-largest-sum", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 43, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个非负整数数组 <code>nums</code> 和一个整数&nbsp;<code>k</code> ，你需要将这个数组分成&nbsp;<code>k</code><em>&nbsp;</em>个非空的连续子数组。</p>\n\n<p>设计一个算法使得这&nbsp;<code>k</code><em>&nbsp;</em>个子数组各自和的最大值最小。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,2,5,10,8], k = 2\n<strong>输出：</strong>18\n<strong>解释：</strong>\n一共有四种方法将 nums 分割为 2 个子数组。 \n其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。\n因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4,5], k = 2\n<strong>输出：</strong>9\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,4,4], k = 3\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= min(50, nums.length)</code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, split <code>nums</code> into <code>k</code> non-empty subarrays such that the largest sum of any subarray is <strong>minimized</strong>.</p>\n\n<p>Return <em>the minimized largest sum of the split</em>.</p>\n\n<p>A <strong>subarray</strong> is a contiguous part of the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [7,2,5,10,8], k = 2\n<strong>Output:</strong> 18\n<strong>Explanation:</strong> There are four ways to split nums into two subarrays.\nThe best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5], k = 2\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> There are four ways to split nums into two subarrays.\nThe best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= min(50, nums.length)</code></li>\n</ul>\n"}}, "411": {"__typename": "QuestionLightNode", "acRate": 0.49577628896009324, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "411", "isFavor": false, "solutionNum": 36, "title": "Minimum Unique Word Abbreviation", "titleCn": "最短独占单词缩写", "titleSlug": "minimum-unique-word-abbreviation", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 4, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "412": {"__typename": "QuestionLightNode", "acRate": 0.6940124916465327, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "412", "isFavor": false, "solutionNum": 1378, "title": "Fizz Buzz", "titleCn": "Fizz Buzz", "titleSlug": "fizz-buzz", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 72, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数 <code>n</code> ，找出从 <code>1</code> 到 <code>n</code> 各个整数的 Fizz Buzz 表示，并用字符串数组 <code>answer</code>（<strong>下标从 1 开始</strong>）返回结果，其中：</p>\n\n<ul>\n\t<li><code>answer[i] == \"FizzBuzz\"</code> 如果 <code>i</code> 同时是 <code>3</code> 和 <code>5</code> 的倍数。</li>\n\t<li><code>answer[i] == \"Fizz\"</code> 如果 <code>i</code> 是 <code>3</code> 的倍数。</li>\n\t<li><code>answer[i] == \"Buzz\"</code> 如果 <code>i</code> 是 <code>5</code> 的倍数。</li>\n\t<li><code>answer[i] == i</code> （以字符串形式）如果上述条件全不满足。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>[\"1\",\"2\",\"Fizz\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 15\n<strong>输出：</strong>[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given an integer <code>n</code>, return <em>a string array </em><code>answer</code><em> (<strong>1-indexed</strong>) where</em>:</p>\n\n<ul>\n\t<li><code>answer[i] == &quot;FizzBuzz&quot;</code> if <code>i</code> is divisible by <code>3</code> and <code>5</code>.</li>\n\t<li><code>answer[i] == &quot;Fizz&quot;</code> if <code>i</code> is divisible by <code>3</code>.</li>\n\t<li><code>answer[i] == &quot;Buzz&quot;</code> if <code>i</code> is divisible by <code>5</code>.</li>\n\t<li><code>answer[i] == i</code> (as a string) if none of the above conditions are true.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 3\n<strong>Output:</strong> [\"1\",\"2\",\"Fizz\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 5\n<strong>Output:</strong> [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> n = 15\n<strong>Output:</strong> [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "413": {"__typename": "QuestionLightNode", "acRate": 0.6949273623593055, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "413", "isFavor": false, "solutionNum": 1527, "title": "Arithmetic Slices", "titleCn": "等差数列划分", "titleSlug": "arithmetic-slices", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>如果一个数列 <strong>至少有三个元素</strong> ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>\n\n<ul>\n\t<li>例如，<code>[1,3,5,7,9]</code>、<code>[7,7,7,7]</code> 和 <code>[3,-1,-5,-9]</code> 都是等差数列。</li>\n</ul>\n\n<div class=\"original__bRMd\">\n<div>\n<p>给你一个整数数组 <code>nums</code> ，返回数组 <code>nums</code> 中所有为等差数组的 <strong>子数组</strong> 个数。</p>\n\n<p><strong>子数组</strong> 是数组中的一个连续序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>3\n<strong>解释：</strong>nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 5000</code></li>\n\t<li><code>-1000 <= nums[i] <= 1000</code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>An integer array is called arithmetic if it consists of <strong>at least three elements</strong> and if the difference between any two consecutive elements is the same.</p>\n\n<ul>\n\t<li>For example, <code>[1,3,5,7,9]</code>, <code>[7,7,7,7]</code>, and <code>[3,-1,-5,-9]</code> are arithmetic sequences.</li>\n</ul>\n\n<p>Given an integer array <code>nums</code>, return <em>the number of arithmetic <strong>subarrays</strong> of</em> <code>nums</code>.</p>\n\n<p>A <strong>subarray</strong> is a contiguous subsequence of the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n"}}, "414": {"__typename": "QuestionLightNode", "acRate": 0.40179721981098626, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "414", "isFavor": false, "solutionNum": 1855, "title": "Third Maximum Number", "titleCn": "第三大的数", "titleSlug": "third-maximum-number", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 37, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个非空数组，返回此数组中 <strong>第三大的数</strong> 。如果不存在，则返回数组中最大的数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>[3, 2, 1]\n<strong>输出：</strong>1\n<strong>解释：</strong>第三大的数是 1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>[1, 2]\n<strong>输出：</strong>2\n<strong>解释：</strong>第三大的数不存在, 所以返回最大的数 2 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>[2, 2, 3, 1]\n<strong>输出：</strong>1\n<strong>解释：</strong>注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。\n此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你能设计一个时间复杂度 <code>O(n)</code> 的解决方案吗？</p>\n", "en": "<p>Given an integer array <code>nums</code>, return <em>the <strong>third distinct maximum</strong> number in this array. If the third maximum does not exist, return the <strong>maximum</strong> number</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,3,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2&#39;s are counted together since they have the same value).\nThe third distinct maximum is 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Can you find an <code>O(n)</code> solution?"}}, "415": {"__typename": "QuestionLightNode", "acRate": 0.5451353911131489, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "415", "isFavor": false, "solutionNum": 2004, "title": "Add Strings", "titleCn": "字符串相加", "titleSlug": "add-strings", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 93, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个字符串形式的非负整数&nbsp;<code>num1</code> 和<code>num2</code>&nbsp;，计算它们的和并同样以字符串形式返回。</p>\n\n<p>你不能使用任何內建的用于处理大整数的库（比如 <code>BigInteger</code>），&nbsp;也不能直接将输入的字符串转换为整数形式。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = \"11\", num2 = \"123\"\n<strong>输出：</strong>\"134\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = \"456\", num2 = \"77\"\n<strong>输出：</strong>\"533\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = \"0\", num2 = \"0\"\n<strong>输出：</strong>\"0\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1.length, num2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>num1</code> 和<code>num2</code> 都只包含数字&nbsp;<code>0-9</code></li>\n\t<li><code>num1</code> 和<code>num2</code> 都不包含任何前导零</li>\n</ul>\n", "en": "<p>Given two non-negative integers, <code>num1</code> and <code>num2</code> represented as string, return <em>the sum of</em> <code>num1</code> <em>and</em> <code>num2</code> <em>as a string</em>.</p>\n\n<p>You must solve the problem without using any built-in library for handling large integers (such as <code>BigInteger</code>). You must also not convert the inputs to integers directly.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = &quot;11&quot;, num2 = &quot;123&quot;\n<strong>Output:</strong> &quot;134&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = &quot;456&quot;, num2 = &quot;77&quot;\n<strong>Output:</strong> &quot;533&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = &quot;0&quot;, num2 = &quot;0&quot;\n<strong>Output:</strong> &quot;0&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num1.length, num2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>num1</code> and <code>num2</code> consist of only digits.</li>\n\t<li><code>num1</code> and <code>num2</code> don&#39;t have any leading zeros except for the zero itself.</li>\n</ul>\n"}}, "416": {"__typename": "QuestionLightNode", "acRate": 0.5239198371231634, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "416", "isFavor": false, "solutionNum": 2411, "title": "Partition Equal Subset Sum", "titleCn": "分割等和子集", "titleSlug": "partition-equal-subset-sum", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 60, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个 <strong>只包含正整数 </strong>的 <strong>非空 </strong>数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,11,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>数组可以分割成 [1, 5, 5] 和 [11] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,5]\n<strong>输出：</strong>false\n<strong>解释：</strong>数组不能分割成两个元素和相等的子集。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 200</code></li>\n\t<li><code>1 <= nums[i] <= 100</code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code>, return <code>true</code> <em>if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,11,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The array can be partitioned as [1, 5, 5] and [11].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,5]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The array cannot be partitioned into equal sum subsets.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n"}}, "417": {"__typename": "QuestionLightNode", "acRate": 0.561375860769468, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "417", "isFavor": false, "solutionNum": 939, "title": "Pacific Atlantic Water Flow", "titleCn": "太平洋大西洋水流问题", "titleSlug": "pacific-atlantic-water-flow", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 31, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>有一个 <code>m × n</code> 的矩形岛屿，与 <strong>太平洋</strong> 和 <strong>大西洋</strong> 相邻。&nbsp;<strong>“太平洋”&nbsp;</strong>处于大陆的左边界和上边界，而 <strong>“大西洋”</strong> 处于大陆的右边界和下边界。</p>\n\n<p>这个岛被分割成一个由若干方形单元格组成的网格。给定一个 <code>m x n</code> 的整数矩阵&nbsp;<code>heights</code>&nbsp;，&nbsp;<code>heights[r][c]</code>&nbsp;表示坐标 <code>(r, c)</code> 上单元格 <strong>高于海平面的高度</strong> 。</p>\n\n<p>岛上雨水较多，如果相邻单元格的高度 <strong>小于或等于</strong> 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。</p>\n\n<p>返回网格坐标 <code>result</code>&nbsp;的 <strong>2D 列表</strong> ，其中&nbsp;<code>result[i] = [r<sub>i</sub>, c<sub>i</sub>]</code>&nbsp;表示雨水从单元格 <code>(ri, ci)</code> 流动 <strong>既可流向太平洋也可流向大西洋</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\n<strong>输出:</strong> [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> heights = [[2,1],[1,2]]\n<strong>输出:</strong> [[0,0],[0,1],[1,0],[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == heights.length</code></li>\n\t<li><code>n == heights[r].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= heights[r][c] &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>There is an <code>m x n</code> rectangular island that borders both the <strong>Pacific Ocean</strong> and <strong>Atlantic Ocean</strong>. The <strong>Pacific Ocean</strong> touches the island&#39;s left and top edges, and the <strong>Atlantic Ocean</strong> touches the island&#39;s right and bottom edges.</p>\n\n<p>The island is partitioned into a grid of square cells. You are given an <code>m x n</code> integer matrix <code>heights</code> where <code>heights[r][c]</code> represents the <strong>height above sea level</strong> of the cell at coordinate <code>(r, c)</code>.</p>\n\n<p>The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell&#39;s height is <strong>less than or equal to</strong> the current cell&#39;s height. Water can flow from any cell adjacent to an ocean into the ocean.</p>\n\n<p>Return <em>a <strong>2D list</strong> of grid coordinates </em><code>result</code><em> where </em><code>result[i] = [r<sub>i</sub>, c<sub>i</sub>]</code><em> denotes that rain water can flow from cell </em><code>(r<sub>i</sub>, c<sub>i</sub>)</code><em> to <strong>both</strong> the Pacific and Atlantic oceans</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg\" style=\"width: 400px; height: 400px;\" />\n<pre>\n<strong>Input:</strong> heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\n<strong>Output:</strong> [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n<strong>Explanation:</strong> The following cells can flow to the Pacific and Atlantic oceans, as shown below:\n[0,4]: [0,4] -&gt; Pacific Ocean \n&nbsp;      [0,4] -&gt; Atlantic Ocean\n[1,3]: [1,3] -&gt; [0,3] -&gt; Pacific Ocean \n&nbsp;      [1,3] -&gt; [1,4] -&gt; Atlantic Ocean\n[1,4]: [1,4] -&gt; [1,3] -&gt; [0,3] -&gt; Pacific Ocean \n&nbsp;      [1,4] -&gt; Atlantic Ocean\n[2,2]: [2,2] -&gt; [1,2] -&gt; [0,2] -&gt; Pacific Ocean \n&nbsp;      [2,2] -&gt; [2,3] -&gt; [2,4] -&gt; Atlantic Ocean\n[3,0]: [3,0] -&gt; Pacific Ocean \n&nbsp;      [3,0] -&gt; [4,0] -&gt; Atlantic Ocean\n[3,1]: [3,1] -&gt; [3,0] -&gt; Pacific Ocean \n&nbsp;      [3,1] -&gt; [4,1] -&gt; Atlantic Ocean\n[4,0]: [4,0] -&gt; Pacific Ocean \n       [4,0] -&gt; Atlantic Ocean\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> heights = [[1]]\n<strong>Output:</strong> [[0,0]]\n<strong>Explanation:</strong> The water can flow from the only cell to the Pacific and Atlantic oceans.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == heights.length</code></li>\n\t<li><code>n == heights[r].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= heights[r][c] &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "418": {"__typename": "QuestionLightNode", "acRate": 0.39453411592076304, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "418", "isFavor": false, "solutionNum": 65, "title": "Sentence Screen Fitting", "titleCn": "屏幕可显示句子的数量", "titleSlug": "sentence-screen-fitting", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 19, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/9c7ab4e2476fc53dc9e8061b1b956172a38d1842b44023aa44e51f223e7d57ac-logo.png", "slug": "yelp", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "419": {"__typename": "QuestionLightNode", "acRate": 0.7776840966577051, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "419", "isFavor": false, "solutionNum": 592, "title": "Battleships in a Board", "titleCn": "甲板上的战舰", "titleSlug": "battleships-in-a-board", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 34, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个大小为 <code>m x n</code> 的矩阵 <code>board</code> 表示甲板，其中，每个单元格可以是一艘战舰 <code>'X'</code> 或者是一个空位 <code>'.'</code> ，返回在甲板 <code>board</code> 上放置的 <strong>战舰</strong> 的数量。</p>\n\n<p><strong>战舰</strong> 只能水平或者垂直放置在 <code>board</code> 上。换句话说，战舰只能按 <code>1 x k</code>（<code>1</code> 行，<code>k</code> 列）或 <code>k x 1</code>（<code>k</code> 行，<code>1</code> 列）的形状建造，其中 <code>k</code> 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/10/battelship-grid.jpg\" style=\"width: 333px; height: 333px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = [[\".\"]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>board[i][j]</code> 是 <code>'.'</code> 或 <code>'X'</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以实现一次扫描算法，并只使用<strong> </strong><code>O(1)</code><strong> </strong>额外空间，并且不修改 <code>board</code> 的值来解决这个问题吗？</p>\n", "en": "<p>Given an <code>m x n</code> matrix <code>board</code> where each cell is a battleship <code>&#39;X&#39;</code> or empty <code>&#39;.&#39;</code>, return <em>the number of the <strong>battleships</strong> on</em> <code>board</code>.</p>\n\n<p><strong>Battleships</strong> can only be placed horizontally or vertically on <code>board</code>. In other words, they can only be made of the shape <code>1 x k</code> (<code>1</code> row, <code>k</code> columns) or <code>k x 1</code> (<code>k</code> rows, <code>1</code> column), where <code>k</code> can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/10/battelship-grid.jpg\" style=\"width: 333px; height: 333px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;X&quot;,&quot;.&quot;,&quot;.&quot;,&quot;X&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;X&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;X&quot;]]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> board = [[&quot;.&quot;]]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>board[i][j]</code> is either <code>&#39;.&#39;</code> or <code>&#39;X&#39;</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you do it in one-pass, using only <code>O(1)</code> extra memory and without modifying the values <code>board</code>?</p>\n"}}, "420": {"__typename": "QuestionLightNode", "acRate": 0.3867822539520653, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "420", "isFavor": false, "solutionNum": 168, "title": "Strong Password Checker", "titleCn": "强密码检验器", "titleSlug": "strong-password-checker", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 25, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>满足以下条件的密码被认为是强密码：</p>\n\n<ul>\n\t<li>由至少 <code>6</code> 个，至多 <code>20</code> 个字符组成。</li>\n\t<li>包含至少 <strong>一个小写 </strong>字母，至少&nbsp;<strong>一个大写</strong> 字母，和至少&nbsp;<strong>一个数字</strong> 。</li>\n\t<li>不包含连续三个重复字符 (比如 <code>\"B<em><strong>aaa</strong></em>bb0\"</code> 是弱密码, 但是&nbsp;<code>\"B<em><strong>aa</strong></em>b<em><strong>a</strong></em>0\"</code> 是强密码)。</li>\n</ul>\n\n<p>给你一个字符串 <code>password</code> ，返回&nbsp;<em>将 <code>password</code> 修改到满足强密码条件需要的最少修改步数。如果 <code>password</code> 已经是强密码，则返回 <code>0</code> 。</em></p>\n\n<p>在一步修改操作中，你可以：</p>\n\n<ul>\n\t<li>插入一个字符到 <code>password</code> ，</li>\n\t<li>从 <code>password</code> 中删除一个字符，或</li>\n\t<li>用另一个字符来替换 <code>password</code> 中的某个字符。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>password = \"a\"\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>password = \"aA1\"\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>password = \"1337C0d3\"\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= password.length &lt;= 50</code></li>\n\t<li><code>password</code> 由字母、数字、点 <code>'.'</code> 或者感叹号 <code>'!'</code> 组成</li>\n</ul>\n", "en": "<p>A password is considered strong if the below conditions are all met:</p>\n\n<ul>\n\t<li>It has at least <code>6</code> characters and at most <code>20</code> characters.</li>\n\t<li>It contains at least <strong>one lowercase</strong> letter, at least <strong>one uppercase</strong> letter, and at least <strong>one digit</strong>.</li>\n\t<li>It does not contain three repeating characters in a row (i.e., <code>&quot;B<u><strong>aaa</strong></u>bb0&quot;</code> is weak, but <code>&quot;B<strong><u>aa</u></strong>b<u><strong>a</strong></u>0&quot;</code> is strong).</li>\n</ul>\n\n<p>Given a string <code>password</code>, return <em>the minimum number of steps required to make <code>password</code> strong. if <code>password</code> is already strong, return <code>0</code>.</em></p>\n\n<p>In one step, you can:</p>\n\n<ul>\n\t<li>Insert one character to <code>password</code>,</li>\n\t<li>Delete one character from <code>password</code>, or</li>\n\t<li>Replace one character of <code>password</code> with another character.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> password = \"a\"\n<strong>Output:</strong> 5\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> password = \"aA1\"\n<strong>Output:</strong> 3\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> password = \"1337C0d3\"\n<strong>Output:</strong> 0\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= password.length &lt;= 50</code></li>\n\t<li><code>password</code> consists of letters, digits, dot&nbsp;<code>&#39;.&#39;</code> or exclamation mark <code>&#39;!&#39;</code>.</li>\n</ul>\n"}}, "421": {"__typename": "QuestionLightNode", "acRate": 0.5977266295632487, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "421", "isFavor": false, "solutionNum": 540, "title": "Maximum XOR of Two Numbers in an Array", "titleCn": "数组中两个数的最大异或值", "titleSlug": "maximum-xor-of-two-numbers-in-an-array", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 26, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> ，返回<em> </em><code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p>\n\n<p>&nbsp;</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,10,5,25,2,8]\n<strong>输出：</strong>28\n<strong>解释：</strong>最大运算结果是 5 XOR 25 = 28.</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [14,70,53,83,49,91,36,80,92,51,66,70]\n<strong>输出：</strong>127\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>Given an integer array <code>nums</code>, return <em>the maximum result of </em><code>nums[i] XOR nums[j]</code>, where <code>0 &lt;= i &lt;= j &lt; n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,10,5,25,2,8]\n<strong>Output:</strong> 28\n<strong>Explanation:</strong> The maximum result is 5 XOR 25 = 28.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [14,70,53,83,49,91,36,80,92,51,66,70]\n<strong>Output:</strong> 127\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "422": {"__typename": "QuestionLightNode", "acRate": 0.4454058810588839, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "422", "isFavor": false, "solutionNum": 119, "title": "Valid Word Square", "titleCn": "有效的单词方块", "titleSlug": "valid-word-square", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 5, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "423": {"__typename": "QuestionLightNode", "acRate": 0.6064429219114388, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "423", "isFavor": false, "solutionNum": 469, "title": "Reconstruct Original Digits from English", "titleCn": "从英文中重建数字", "titleSlug": "reconstruct-original-digits-from-english", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 24, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1604559404-lBlorc-https---i.forbesimg.com-media-lists-companies-jpmorgan-chase_416x416.jpg", "slug": "jpmorgan", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/78703b3d3d17ff1b249303bec7cd53d61ba4d1ff309f4293600ea7efe8b692ae-salesforce.png", "slug": "salesforce", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code> ，其中包含字母顺序打乱的用英文单词表示的若干数字（<code>0-9</code>）。按 <strong>升序</strong> 返回原始的数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"owoztneoer\"\n<strong>输出：</strong>\"012\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"fviefuro\"\n<strong>输出：</strong>\"45\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>[\"e\",\"g\",\"f\",\"i\",\"h\",\"o\",\"n\",\"s\",\"r\",\"u\",\"t\",\"w\",\"v\",\"x\",\"z\"]</code> 这些字符之一</li>\n\t<li><code>s</code> 保证是一个符合题目要求的字符串</li>\n</ul>\n", "en": "<p>Given a string <code>s</code> containing an out-of-order English representation of digits <code>0-9</code>, return <em>the digits in <strong>ascending</strong> order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"owoztneoer\"\n<strong>Output:</strong> \"012\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"fviefuro\"\n<strong>Output:</strong> \"45\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is one of the characters <code>[&quot;e&quot;,&quot;g&quot;,&quot;f&quot;,&quot;i&quot;,&quot;h&quot;,&quot;o&quot;,&quot;n&quot;,&quot;s&quot;,&quot;r&quot;,&quot;u&quot;,&quot;t&quot;,&quot;w&quot;,&quot;v&quot;,&quot;x&quot;,&quot;z&quot;]</code>.</li>\n\t<li><code>s</code> is <strong>guaranteed</strong> to be valid.</li>\n</ul>\n"}}, "424": {"__typename": "QuestionLightNode", "acRate": 0.5494155573339946, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "424", "isFavor": false, "solutionNum": 792, "title": "Longest Repeating Character Replacement", "titleCn": "替换后的最长重复字符", "titleSlug": "longest-repeating-character-replacement", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 43, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 <code>k</code> 次。</p>\n\n<p>在执行上述操作后，返回 <em>包含相同字母的最长子字符串的长度。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"ABAB\", k = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>用两个'A'替换为两个'B',反之亦然。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"AABABBA\", k = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>\n将中间的一个'A'替换为'B',字符串变为 \"AABBBBA\"。\n子串 \"BBBB\" 有最长重复字母, 答案为 4。\n可能存在其他的方法来得到同样的结果。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 仅由大写英文字母组成</li>\n\t<li><code>0 &lt;= k &lt;= s.length</code></li>\n</ul>\n", "en": "<p>You are given a string <code>s</code> and an integer <code>k</code>. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most <code>k</code> times.</p>\n\n<p>Return <em>the length of the longest substring containing the same letter you can get after performing the above operations</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ABAB&quot;, k = 2\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Replace the two &#39;A&#39;s with two &#39;B&#39;s or vice versa.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;AABABBA&quot;, k = 1\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Replace the one &#39;A&#39; in the middle with &#39;B&#39; and form &quot;AABBBBA&quot;.\nThe substring &quot;BBBB&quot; has the longest repeating letters, which is 4.\nThere may exists other ways to achieve this answer too.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of only uppercase English letters.</li>\n\t<li><code>0 &lt;= k &lt;= s.length</code></li>\n</ul>\n"}}, "425": {"__typename": "QuestionLightNode", "acRate": 0.6255835667600373, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "425", "isFavor": false, "solutionNum": 51, "title": "Word Squares", "titleCn": "单词方块", "titleSlug": "word-squares", "topicTags": [{"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 12, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/cf2a3ac504c38f16ee9e9e828b4f40ed444dc54e25653145bbfdf9f2f467115a-1587797765803.jpg", "slug": "oracle", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "426": {"__typename": "QuestionLightNode", "acRate": 0.680747177925103, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "426", "isFavor": false, "solutionNum": 197, "title": "Convert Binary Search Tree to Sorted Doubly Linked List", "titleCn": "将二叉搜索树转化为排序的双向链表", "titleSlug": "convert-binary-search-tree-to-sorted-doubly-linked-list", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}, {"id": "arqq05", "name": "Doubly-Linked List", "slug": "doubly-linked-list", "nameTranslated": "双向链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 31, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "427": {"__typename": "QuestionLightNode", "acRate": 0.7158184559578699, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "427", "isFavor": false, "solutionNum": 381, "title": "Construct Quad Tree", "titleCn": "建立四叉树", "titleSlug": "construct-quad-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 14, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个 <code>n * n</code> 矩阵 <code>grid</code> ，矩阵由若干 <code>0</code> 和 <code>1</code> 组成。请你用四叉树表示该矩阵 <code>grid</code> 。</p>\n\n<p>你需要返回能表示矩阵 <code>grid</code> 的 四叉树 的根结点。</p>\n\n<p>四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：</p>\n\n<ul>\n\t<li><code>val</code>：储存叶子结点所代表的区域的值。1 对应 <strong>True</strong>，0 对应 <strong>False</strong>。注意，当 <code>isLeaf</code> 为 <strong>False </strong>时，你可以把 <strong>True</strong> 或者 <strong>False</strong> 赋值给节点，两种值都会被判题机制 <strong>接受</strong> 。</li>\n\t<li><code>isLeaf</code>: 当这个节点是一个叶子结点时为 <strong>True</strong>，如果它有 4 个子节点则为 <strong>False</strong> 。</li>\n</ul>\n\n<pre>\nclass Node {\n    public boolean val;\n&nbsp; &nbsp; public boolean isLeaf;\n&nbsp; &nbsp; public Node topLeft;\n&nbsp; &nbsp; public Node topRight;\n&nbsp; &nbsp; public Node bottomLeft;\n&nbsp; &nbsp; public Node bottomRight;\n}</pre>\n\n<p>我们可以按以下步骤为二维区域构建四叉树：</p>\n\n<ol>\n\t<li>如果当前网格的值相同（即，全为 <code>0</code> 或者全为 <code>1</code>），将 <code>isLeaf</code> 设为 True ，将 <code>val</code> 设为网格相应的值，并将四个子节点都设为 Null 然后停止。</li>\n\t<li>如果当前网格的值不同，将 <code>isLeaf</code> 设为 False， 将 <code>val</code> 设为任意值，然后如下图所示，将当前网格划分为四个子网格。</li>\n\t<li>使用适当的子网格递归每个子节点。</li>\n</ol>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/new_top.png\" style=\"height: 181px; width: 777px;\" /></p>\n\n<p>如果你想了解更多关于四叉树的内容，可以参考 <a href=\"https://en.wikipedia.org/wiki/Quadtree\">wiki</a> 。</p>\n\n<p><strong>四叉树格式：</strong></p>\n\n<p>你不需要阅读本节来解决这个问题。只有当你想了解输出格式时才会这样做。输出为使用层序遍历后四叉树的序列化形式，其中 <code>null</code> 表示路径终止符，其下面不存在节点。</p>\n\n<p>它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 <code>[isLeaf, val]</code> 。</p>\n\n<p>如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 True ，则表示它在列表&nbsp;<code>[isLeaf, val]</code> 中的值为 <strong>1</strong> ；如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 False ，则表示值为 <strong>0 </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/grid1.png\" style=\"height: 99px; width: 777px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,1],[1,0]]\n<strong>输出：</strong>[[0,1],[1,0],[1,1],[1,1],[1,0]]\n<strong>解释：</strong>此示例的解释如下：\n请注意，在下面四叉树的图示中，0 表示 false，1 表示 True 。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/12/e1tree.png\" style=\"height: 186px; width: 777px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/12/e2mat.png\" style=\"height: 343px; width: 777px;\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\n<strong>输出：</strong>[[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n<strong>解释：</strong>网格中的所有值都不相同。我们将网格划分为四个子网格。\ntopLeft，bottomLeft 和 bottomRight 均具有相同的值。\ntopRight 具有不同的值，因此我们将其再分为 4 个子网格，这样每个子网格都具有相同的值。\n解释如下图所示：\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/12/e2tree.png\" style=\"height: 328px; width: 777px;\" />\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>n == 2<sup>x</sup></code> 其中 <code>0 &lt;= x &lt;= 6</code></li>\n</ol>\n", "en": "<p>Given a <code>n * n</code> matrix <code>grid</code> of <code>0&#39;s</code> and <code>1&#39;s</code> only. We want to represent <code>grid</code> with a Quad-Tree.</p>\n\n<p>Return <em>the root of the Quad-Tree representing </em><code>grid</code>.</p>\n\n<p>A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:</p>\n\n<ul>\n\t<li><code>val</code>: True if the node represents a grid of 1&#39;s or False if the node represents a grid of 0&#39;s. Notice that you can assign the <code>val</code> to True or False when <code>isLeaf</code> is False, and both are accepted in the answer.</li>\n\t<li><code>isLeaf</code>: True if the node is a leaf node on the tree or False if the node has four children.</li>\n</ul>\n\n<pre>\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}</pre>\n\n<p>We can construct a Quad-Tree from a two-dimensional area using the following steps:</p>\n\n<ol>\n\t<li>If the current grid has the same value (i.e all <code>1&#39;s</code> or all <code>0&#39;s</code>) set <code>isLeaf</code> True and set <code>val</code> to the value of the grid and set the four children to Null and stop.</li>\n\t<li>If the current grid has different values, set <code>isLeaf</code> to False and set <code>val</code> to any value and divide the current grid into four sub-grids as shown in the photo.</li>\n\t<li>Recurse for each of the children with the proper sub-grid.</li>\n</ol>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/new_top.png\" style=\"width: 777px; height: 181px;\" />\n<p>If you want to know more about the Quad-Tree, you can refer to the <a href=\"https://en.wikipedia.org/wiki/Quadtree\">wiki</a>.</p>\n\n<p><strong>Quad-Tree format:</strong></p>\n\n<p>You don&#39;t need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where <code>null</code> signifies a path terminator where no node exists below.</p>\n\n<p>It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list <code>[isLeaf, val]</code>.</p>\n\n<p>If the value of <code>isLeaf</code> or <code>val</code> is True we represent it as <strong>1</strong> in the list <code>[isLeaf, val]</code> and if the value of <code>isLeaf</code> or <code>val</code> is False we represent it as <strong>0</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/grid1.png\" style=\"width: 777px; height: 99px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,1],[1,0]]\n<strong>Output:</strong> [[0,1],[1,0],[1,1],[1,1],[1,0]]\n<strong>Explanation:</strong> The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/12/e1tree.png\" style=\"width: 777px; height: 186px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/12/e2mat.png\" style=\"width: 777px; height: 343px;\" /></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\n<strong>Output:</strong> [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n<strong>Explanation:</strong> All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/12/e2tree.png\" style=\"width: 777px; height: 328px;\" />\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>n == 2<sup>x</sup></code> where <code>0 &lt;= x &lt;= 6</code></li>\n</ul>\n"}}, "428": {"__typename": "QuestionLightNode", "acRate": 0.6963755199049316, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "428", "isFavor": false, "solutionNum": 89, "title": "Serialize and Deserialize N-ary Tree", "titleCn": "序列化和反序列化 N 叉树", "titleSlug": "serialize-and-deserialize-n-ary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 26, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "429": {"__typename": "QuestionLightNode", "acRate": 0.735849404408593, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "429", "isFavor": false, "solutionNum": 1342, "title": "N-ary Tree Level Order Traversal", "titleCn": "N 叉树的层序遍历", "titleSlug": "n-ary-tree-level-order-traversal", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 23, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p>\n\n<p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,3,2,4,null,5,6]\n<strong>输出：</strong>[[1],[3,2,4],[5,6]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>输出：</strong>[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树的高度不会超过 <code>1000</code></li>\n\t<li>树的节点总数在 <code>[0, 10^4]</code> 之间</li>\n</ul>\n", "en": "<p>Given an n-ary tree, return the <em>level order</em> traversal of its nodes&#39; values.</p>\n\n<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n<strong>Output:</strong> [[1],[3,2,4],[5,6]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>Output:</strong> [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The height of the n-ary tree is less than or equal to <code>1000</code></li>\n\t<li>The total number of nodes is between <code>[0, 10<sup>4</sup>]</code></li>\n</ul>\n"}}, "430": {"__typename": "QuestionLightNode", "acRate": 0.5953512332465871, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "430", "isFavor": false, "solutionNum": 931, "title": "Flatten a Multilevel Doubly Linked List", "titleCn": "扁平化多级双向链表", "titleSlug": "flatten-a-multilevel-doubly-linked-list", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "arqq05", "name": "Doubly-Linked List", "slug": "doubly-linked-list", "nameTranslated": "双向链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 30, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你会得到一个双链表，其中包含的节点有一个下一个指针、一个前一个指针和一个额外的 <strong>子指针</strong> 。这个子指针可能指向一个单独的双向链表，也包含这些特殊的节点。这些子列表可以有一个或多个自己的子列表，以此类推，以生成如下面的示例所示的 <strong>多层数据结构</strong> 。</p>\n\n<p>给定链表的头节点&nbsp;<font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">head</span></span></font></font>&nbsp;，将链表 <strong>扁平化</strong> ，以便所有节点都出现在单层双链表中。让 <code>curr</code> 是一个带有子列表的节点。子列表中的节点应该出现在<strong>扁平化列表</strong>中的&nbsp;<code>curr</code> <strong>之后</strong> 和&nbsp;<code>curr.next</code>&nbsp;<strong>之前</strong> 。</p>\n\n<p>返回 <em>扁平列表的 <code>head</code>&nbsp;。列表中的节点必须将其 <strong>所有</strong> 子指针设置为&nbsp;<code>null</code>&nbsp;。</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/11/09/flatten11.jpg\" style=\"height:339px; width:700px\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n<strong>输出：</strong>[1,2,3,7,8,11,12,9,10,4,5,6]\n<strong>解释：</strong>输入的多级列表如上图所示。\n扁平化后的链表如下图：\n<img src=\"https://assets.leetcode.com/uploads/2021/11/09/flatten12.jpg\" style=\"height:69px; width:1000px\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/11/09/flatten2.1jpg\" style=\"height:200px; width:200px\" /></p>\n\n<pre>\n<strong>输入：</strong>head = [1,2,null,3]\n<strong>输出：</strong>[1,3,2]\n<strong>解释：</strong>输入的多级列表如上图所示。\n扁平化后的链表如下图：\n<img src=\"https://assets.leetcode.com/uploads/2021/11/24/list.jpg\" style=\"height:87px; width:300px\" />\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>head = []\n<strong>输出：</strong>[]\n<strong>说明：</strong>输入中可能存在空列表。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>节点数目不超过 <code>1000</code></li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>如何表示测试用例中的多级链表？</strong></p>\n\n<p>以 <strong>示例 1</strong> 为例：</p>\n\n<pre>\n 1---2---3---4---5---6--NULL\n         |\n         7---8---9---10--NULL\n             |\n             11--12--NULL</pre>\n\n<p>序列化其中的每一级之后：</p>\n\n<pre>\n[1,2,3,4,5,6,null]\n[7,8,9,10,null]\n[11,12,null]\n</pre>\n\n<p>为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p>\n\n<pre>\n[1,2,3,4,5,6,null]\n[null,null,7,8,9,10,null]\n[null,11,12,null]\n</pre>\n\n<p>合并所有序列化结果，并去除末尾的 null 。</p>\n\n<pre>\n[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n</pre>\n\n<ul>\n</ul>\n", "en": "<p>You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional <strong>child pointer</strong>. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a <strong>multilevel data structure</strong> as shown in the example below.</p>\n\n<p>Given the <code>head</code> of the first level of the list, <strong>flatten</strong> the list so that all the nodes appear in a single-level, doubly linked list. Let <code>curr</code> be a node with a child list. The nodes in the child list should appear <strong>after</strong> <code>curr</code> and <strong>before</strong> <code>curr.next</code> in the flattened list.</p>\n\n<p>Return <em>the </em><code>head</code><em> of the flattened list. The nodes in the list must have <strong>all</strong> of their child pointers set to </em><code>null</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/09/flatten11.jpg\" style=\"width: 700px; height: 339px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n<strong>Output:</strong> [1,2,3,7,8,11,12,9,10,4,5,6]\n<strong>Explanation:</strong> The multilevel linked list in the input is shown.\nAfter flattening the multilevel linked list it becomes:\n<img src=\"https://assets.leetcode.com/uploads/2021/11/09/flatten12.jpg\" style=\"width: 1000px; height: 69px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/09/flatten2.1jpg\" style=\"width: 200px; height: 200px;\" />\n<pre>\n<strong>Input:</strong> head = [1,2,null,3]\n<strong>Output:</strong> [1,3,2]\n<strong>Explanation:</strong> The multilevel linked list in the input is shown.\nAfter flattening the multilevel linked list it becomes:\n<img src=\"https://assets.leetcode.com/uploads/2021/11/24/list.jpg\" style=\"width: 300px; height: 87px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There could be empty list in the input.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of Nodes will not exceed <code>1000</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>How the multilevel linked list is represented in test cases:</strong></p>\n\n<p>We use the multilevel linked list from <strong class=\"example\">Example 1</strong> above:</p>\n\n<pre>\n 1---2---3---4---5---6--NULL\n         |\n         7---8---9---10--NULL\n             |\n             11--12--NULL</pre>\n\n<p>The serialization of each level is as follows:</p>\n\n<pre>\n[1,2,3,4,5,6,null]\n[7,8,9,10,null]\n[11,12,null]\n</pre>\n\n<p>To serialize all levels together, we will add nulls in each level to signify no node connects to the upper node of the previous level. The serialization becomes:</p>\n\n<pre>\n[1,    2,    3, 4, 5, 6, null]\n             |\n[null, null, 7,    8, 9, 10, null]\n                   |\n[            null, 11, 12, null]\n</pre>\n\n<p>Merging the serialization of each level and removing trailing nulls we obtain:</p>\n\n<pre>\n[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n</pre>\n"}}, "431": {"__typename": "QuestionLightNode", "acRate": 0.7469173859432799, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "431", "isFavor": false, "solutionNum": 51, "title": "Encode N-ary Tree to Binary Tree", "titleCn": "将 N 叉树编码为二叉树", "titleSlug": "encode-n-ary-tree-to-binary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 7, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "432": {"__typename": "QuestionLightNode", "acRate": 0.4649978460212936, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "432", "isFavor": false, "solutionNum": 321, "title": "All O`one Data Structure", "titleCn": "全 O(1) 的数据结构", "titleSlug": "all-oone-data-structure", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "arqq05", "name": "Doubly-Linked List", "slug": "doubly-linked-list", "nameTranslated": "双向链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 32, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。</p>\n\n<p>实现 <code>AllOne</code> 类：</p>\n\n<ul>\n\t<li><code>AllOne()</code> 初始化数据结构的对象。</li>\n\t<li><code>inc(String key)</code> 字符串 <code>key</code> 的计数增加 <code>1</code> 。如果数据结构中尚不存在 <code>key</code> ，那么插入计数为 <code>1</code> 的 <code>key</code> 。</li>\n\t<li><code>dec(String key)</code> 字符串 <code>key</code> 的计数减少 <code>1</code> 。如果 <code>key</code> 的计数在减少后为 <code>0</code> ，那么需要将这个 <code>key</code> 从数据结构中删除。测试用例保证：在减少计数前，<code>key</code> 存在于数据结构中。</li>\n\t<li><code>getMaxKey()</code> 返回任意一个计数最大的字符串。如果没有元素存在，返回一个空字符串 <code>\"\"</code> 。</li>\n\t<li><code>getMinKey()</code> 返回任意一个计数最小的字符串。如果没有元素存在，返回一个空字符串 <code>\"\"</code> 。</li>\n</ul>\n\n<p><strong>注意：</strong>每个函数都应当满足 <code>O(1)</code> 平均时间复杂度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]\n<strong>输出</strong>\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]\n\n<strong>解释</strong>\nAllOne allOne = new AllOne();\nallOne.inc(\"hello\");\nallOne.inc(\"hello\");\nallOne.getMaxKey(); // 返回 \"hello\"\nallOne.getMinKey(); // 返回 \"hello\"\nallOne.inc(\"leet\");\nallOne.getMaxKey(); // 返回 \"hello\"\nallOne.getMinKey(); // 返回 \"leet\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= key.length &lt;= 10</code></li>\n\t<li><code>key</code> 由小写英文字母组成</li>\n\t<li>测试用例保证：在每次调用 <code>dec</code> 时，数据结构中总存在 <code>key</code></li>\n\t<li>最多调用 <code>inc</code>、<code>dec</code>、<code>getMaxKey</code> 和 <code>getMinKey</code> 方法 <code>5 * 10<sup>4</sup></code> 次</li>\n</ul>\n", "en": "<p>Design a data structure to store the strings&#39; count with the ability to return the strings with minimum and maximum counts.</p>\n\n<p>Implement the <code>AllOne</code> class:</p>\n\n<ul>\n\t<li><code>AllOne()</code> Initializes the object of the data structure.</li>\n\t<li><code>inc(String key)</code> Increments the count of the string <code>key</code> by <code>1</code>. If <code>key</code> does not exist in the data structure, insert it with count <code>1</code>.</li>\n\t<li><code>dec(String key)</code> Decrements the count of the string <code>key</code> by <code>1</code>. If the count of <code>key</code> is <code>0</code> after the decrement, remove it from the data structure. It is guaranteed that <code>key</code> exists in the data structure before the decrement.</li>\n\t<li><code>getMaxKey()</code> Returns one of the keys with the maximal count. If no element exists, return an empty string <code>&quot;&quot;</code>.</li>\n\t<li><code>getMinKey()</code> Returns one of the keys with the minimum count. If no element exists, return an empty string <code>&quot;&quot;</code>.</li>\n</ul>\n\n<p><strong>Note</strong> that each function must run in <code>O(1)</code> average time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;AllOne&quot;, &quot;inc&quot;, &quot;inc&quot;, &quot;getMaxKey&quot;, &quot;getMinKey&quot;, &quot;inc&quot;, &quot;getMaxKey&quot;, &quot;getMinKey&quot;]\n[[], [&quot;hello&quot;], [&quot;hello&quot;], [], [], [&quot;leet&quot;], [], []]\n<strong>Output</strong>\n[null, null, null, &quot;hello&quot;, &quot;hello&quot;, null, &quot;hello&quot;, &quot;leet&quot;]\n\n<strong>Explanation</strong>\nAllOne allOne = new AllOne();\nallOne.inc(&quot;hello&quot;);\nallOne.inc(&quot;hello&quot;);\nallOne.getMaxKey(); // return &quot;hello&quot;\nallOne.getMinKey(); // return &quot;hello&quot;\nallOne.inc(&quot;leet&quot;);\nallOne.getMaxKey(); // return &quot;hello&quot;\nallOne.getMinKey(); // return &quot;leet&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= key.length &lt;= 10</code></li>\n\t<li><code>key</code> consists of lowercase English letters.</li>\n\t<li>It is guaranteed that for each call to <code>dec</code>, <code>key</code> is existing in the data structure.</li>\n\t<li>At most <code>5 * 10<sup>4</sup></code>&nbsp;calls will be made to <code>inc</code>, <code>dec</code>, <code>getMaxKey</code>, and <code>getMinKey</code>.</li>\n</ul>\n"}}, "433": {"__typename": "QuestionLightNode", "acRate": 0.5446413459260011, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "433", "isFavor": false, "solutionNum": 829, "title": "Minimum Genetic Mutation", "titleCn": "最小基因变化", "titleSlug": "minimum-genetic-mutation", "topicTags": [{"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 23, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937282-qSKaPF-Unknown-4.jpeg", "slug": "twitter", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 <code>'A'</code>、<code>'C'</code>、<code>'G'</code> 和 <code>'T'</code> 之一。</p>\n\n<p>假设我们需要调查从基因序列&nbsp;<code>start</code> 变为 <code>end</code> 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。</p>\n\n<ul>\n\t<li>例如，<code>\"AACCGGTT\" --&gt; \"AACCGGTA\"</code> 就是一次基因变化。</li>\n</ul>\n\n<p>另有一个基因库 <code>bank</code> 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 <code>bank</code> 中）</p>\n\n<p>给你两个基因序列 <code>start</code> 和 <code>end</code> ，以及一个基因库 <code>bank</code> ，请你找出并返回能够使&nbsp;<code>start</code> 变化为 <code>end</code> 所需的最少变化次数。如果无法完成此基因变化，返回 <code>-1</code> 。</p>\n\n<p>注意：起始基因序列&nbsp;<code>start</code> 默认是有效的，但是它并不一定会出现在基因库中。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>start = \"AACCGGTT\", end = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>start = \"AACCGGTT\", end = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>start = \"AAAAACCC\", end = \"AACCCCCC\", bank = [\"AAAACCCC\",\"AAACCCCC\",\"AACCCCCC\"]\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>start.length == 8</code></li>\n\t<li><code>end.length == 8</code></li>\n\t<li><code>0 &lt;= bank.length &lt;= 10</code></li>\n\t<li><code>bank[i].length == 8</code></li>\n\t<li><code>start</code>、<code>end</code> 和 <code>bank[i]</code> 仅由字符 <code>['A', 'C', 'G', 'T']</code> 组成</li>\n</ul>\n", "en": "<p>A gene string can be represented by an 8-character long string, with choices from <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;T&#39;</code>.</p>\n\n<p>Suppose we need to investigate a mutation from a gene string <code>startGene</code> to a gene string <code>endGene</code> where one mutation is defined as one single character changed in the gene string.</p>\n\n<ul>\n\t<li>For example, <code>&quot;AACCGGTT&quot; --&gt; &quot;AACCGGTA&quot;</code> is one mutation.</li>\n</ul>\n\n<p>There is also a gene bank <code>bank</code> that records all the valid gene mutations. A gene must be in <code>bank</code> to make it a valid gene string.</p>\n\n<p>Given the two gene strings <code>startGene</code> and <code>endGene</code> and the gene bank <code>bank</code>, return <em>the minimum number of mutations needed to mutate from </em><code>startGene</code><em> to </em><code>endGene</code>. If there is no such a mutation, return <code>-1</code>.</p>\n\n<p>Note that the starting point is assumed to be valid, so it might not be included in the bank.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> startGene = &quot;AACCGGTT&quot;, endGene = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> startGene = &quot;AACCGGTT&quot;, endGene = &quot;AAACGGTA&quot;, bank = [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= bank.length &lt;= 10</code></li>\n\t<li><code>startGene.length == endGene.length == bank[i].length == 8</code></li>\n\t<li><code>startGene</code>, <code>endGene</code>, and <code>bank[i]</code> consist of only the characters <code>[&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;]</code>.</li>\n</ul>\n"}}, "434": {"__typename": "QuestionLightNode", "acRate": 0.3819501188182643, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "434", "isFavor": false, "solutionNum": 1234, "title": "Number of Segments in a String", "titleCn": "字符串中的单词数", "titleSlug": "number-of-segments-in-a-string", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p>\n\n<p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p>\n\n<p><strong>示例:</strong></p>\n\n<pre><strong>输入:</strong> &quot;Hello, my name is John&quot;\n<strong>输出:</strong> 5\n<strong>解释: </strong>这里的单词是指连续的不是空格的字符，所以 &quot;Hello,&quot; 算作 1 个单词。\n</pre>\n", "en": "<p>Given a string <code>s</code>, return <em>the number of segments in the string</em>.</p>\n\n<p>A <strong>segment</strong> is defined to be a contiguous sequence of <strong>non-space characters</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;Hello, my name is John&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The five segments are [&quot;Hello,&quot;, &quot;my&quot;, &quot;name&quot;, &quot;is&quot;, &quot;John&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;Hello&quot;\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s.length &lt;= 300</code></li>\n\t<li><code>s</code> consists of lowercase and uppercase English letters, digits, or one of the following characters <code>&quot;!@#$%^&amp;*()_+-=&#39;,.:&quot;</code>.</li>\n\t<li>The only space character in <code>s</code> is <code>&#39; &#39;</code>.</li>\n</ul>\n"}}, "435": {"__typename": "QuestionLightNode", "acRate": 0.5159326511663523, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "435", "isFavor": false, "solutionNum": 1843, "title": "Non-overlapping Intervals", "titleCn": "无重叠区间", "titleSlug": "non-overlapping-intervals", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 57, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个区间的集合&nbsp;<code>intervals</code>&nbsp;，其中 <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>&nbsp;。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> intervals = [[1,2],[2,3],[3,4],[1,3]]\n<strong>输出:</strong> 1\n<strong>解释:</strong> 移除 [1,3] 后，剩下的区间没有重叠。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> intervals = [ [1,2], [1,2], [1,2] ]\n<strong>输出:</strong> 2\n<strong>解释:</strong> 你需要移除两个 [1,2] 来使剩下的区间没有重叠。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> intervals = [ [1,2], [2,3] ]\n<strong>输出:</strong> 0\n<strong>解释:</strong> 你不需要移除任何区间，因为它们已经是无重叠的了。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>-5 * 10<sup>4</sup>&nbsp;&lt;= start<sub>i</sub>&nbsp;&lt; end<sub>i</sub>&nbsp;&lt;= 5 * 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given an array of intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, return <em>the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[2,3],[3,4],[1,3]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> [1,3] can be removed and the rest of the intervals are non-overlapping.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[1,2],[1,2]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You need to remove two [1,2] to make the rest of the intervals non-overlapping.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[2,3]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> You don&#39;t need to remove any of the intervals since they&#39;re already non-overlapping.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>-5 * 10<sup>4</sup> &lt;= start<sub>i</sub> &lt; end<sub>i</sub> &lt;= 5 * 10<sup>4</sup></code></li>\n</ul>\n"}}, "436": {"__typename": "QuestionLightNode", "acRate": 0.5698932211053529, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "436", "isFavor": false, "solutionNum": 599, "title": "Find Right Interval", "titleCn": "寻找右区间", "titleSlug": "find-right-interval", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 14, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/4eff6310a5e88ba78fd5dc50cb8aa75d00eecd986c7513a22cbd24c937b8f9ff-0x0ss-85.jpg", "slug": "wish", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个区间数组 <code>intervals</code> ，其中&nbsp;<code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> ，且每个&nbsp;<code>start<sub>i</sub></code> 都 <strong>不同</strong> 。</p>\n\n<p>区间 <code>i</code> 的 <strong>右侧区间</strong> 可以记作区间 <code>j</code> ，并满足 <code>start<sub>j</sub></code><code>&nbsp;&gt;= end<sub>i</sub></code> ，且 <code>start<sub>j</sub></code> <strong>最小化 </strong>。注意 <code>i</code> 可能等于 <code>j</code> 。</p>\n\n<p>返回一个由每个区间 <code>i</code> 的 <strong>右侧区间</strong> 在&nbsp;<code>intervals</code> 中对应下标组成的数组。如果某个区间 <code>i</code> 不存在对应的 <strong>右侧区间</strong> ，则下标 <code>i</code> 处的值设为 <code>-1</code> 。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,2]]\n<strong>输出：</strong>[-1]\n<strong>解释：</strong>集合中只有一个区间，所以输出-1。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[3,4],[2,3],[1,2]]\n<strong>输出：</strong>[-1,0,1]\n<strong>解释：</strong>对于 [3,4] ，没有满足条件的“右侧”区间。\n对于 [2,3] ，区间[3,4]具有最小的“右”起点;\n对于 [1,2] ，区间[2,3]具有最小的“右”起点。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>intervals = [[1,4],[2,3],[3,4]]\n<strong>输出：</strong>[-1,2,-1]\n<strong>解释：</strong>对于区间 [1,4] 和 [3,4] ，没有满足条件的“右侧”区间。\n对于 [2,3] ，区间 [3,4] 有最小的“右”起点。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;intervals.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n\t<li>每个间隔的起点都 <strong>不相同</strong></li>\n</ul>\n", "en": "<p>You are given an array of <code>intervals</code>, where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> and each <code>start<sub>i</sub></code> is <strong>unique</strong>.</p>\n\n<p>The <strong>right interval</strong> for an interval <code>i</code> is an interval <code>j</code> such that <code>start<sub>j</sub> &gt;= end<sub>i</sub></code> and <code>start<sub>j</sub></code> is <strong>minimized</strong>. Note that <code>i</code> may equal <code>j</code>.</p>\n\n<p>Return <em>an array of <strong>right interval</strong> indices for each interval <code>i</code></em>. If no <strong>right interval</strong> exists for interval <code>i</code>, then put <code>-1</code> at index <code>i</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2]]\n<strong>Output:</strong> [-1]\n<strong>Explanation:</strong> There is only one interval in the collection, so it outputs -1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[3,4],[2,3],[1,2]]\n<strong>Output:</strong> [-1,0,1]\n<strong>Explanation:</strong> There is no right interval for [3,4].\nThe right interval for [2,3] is [3,4] since start<sub>0</sub> = 3 is the smallest start that is &gt;= end<sub>1</sub> = 3.\nThe right interval for [1,2] is [2,3] since start<sub>1</sub> = 2 is the smallest start that is &gt;= end<sub>2</sub> = 2.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,4],[2,3],[3,4]]\n<strong>Output:</strong> [-1,2,-1]\n<strong>Explanation:</strong> There is no right interval for [1,4] and [3,4].\nThe right interval for [2,3] is [3,4] since start<sub>2</sub> = 3 is the smallest start that is &gt;= end<sub>1</sub> = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n\t<li>The start point of each interval is <strong>unique</strong>.</li>\n</ul>\n"}}, "437": {"__typename": "QuestionLightNode", "acRate": 0.4792993787190794, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "437", "isFavor": false, "solutionNum": 1799, "title": "Path Sum III", "titleCn": "路径总和 III", "titleSlug": "path-sum-iii", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 46, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>\n\n<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg\" style=\"width: 452px; \" /></p>\n\n<pre>\n<strong>输入：</strong>root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n<strong>输出：</strong>3\n<strong>解释：</strong>和等于 8 的路径有 3 条，如图所示。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,1000]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-10<sup>9</sup> <= Node.val <= 10<sup>9</sup></code> </li>\n\t<li><code>-1000 <= targetSum <= 1000</code> </li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>the number of paths where the sum of the values&nbsp;along the path equals</em>&nbsp;<code>targetSum</code>.</p>\n\n<p>The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg\" style=\"width: 450px; height: 386px;\" />\n<pre>\n<strong>Input:</strong> root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The paths that sum to 8 are shown.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 1000]</code>.</li>\n\t<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n"}}, "438": {"__typename": "QuestionLightNode", "acRate": 0.5350036277188595, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "438", "isFavor": false, "solutionNum": 2708, "title": "Find All Anagrams in a String", "titleCn": "找到字符串中所有字母异位词", "titleSlug": "find-all-anagrams-in-a-string", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 55, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个字符串&nbsp;<code>s</code>&nbsp;和 <code>p</code>，找到&nbsp;<code>s</code><strong>&nbsp;</strong>中所有&nbsp;<code>p</code><strong>&nbsp;</strong>的&nbsp;<strong>异位词&nbsp;</strong>的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>\n\n<p><strong>异位词 </strong>指由相同字母重排列形成的字符串（包括相同的字符串）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"cbaebabacd\", p = \"abc\"\n<strong>输出: </strong>[0,6]\n<strong>解释:</strong>\n起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。\n起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。\n</pre>\n\n<p><strong>&nbsp;示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"abab\", p = \"ab\"\n<strong>输出: </strong>[0,1,2]\n<strong>解释:</strong>\n起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。\n起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。\n起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, p.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;和&nbsp;<code>p</code>&nbsp;仅包含小写字母</li>\n</ul>\n", "en": "<p>Given two strings <code>s</code> and <code>p</code>, return <em>an array of all the start indices of </em><code>p</code><em>&#39;s anagrams in </em><code>s</code>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;\n<strong>Output:</strong> [0,6]\n<strong>Explanation:</strong>\nThe substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.\nThe substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abab&quot;, p = &quot;ab&quot;\n<strong>Output:</strong> [0,1,2]\n<strong>Explanation:</strong>\nThe substring with start index = 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.\nThe substring with start index = 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.\nThe substring with start index = 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, p.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> and <code>p</code> consist of lowercase English letters.</li>\n</ul>\n"}}, "439": {"__typename": "QuestionLightNode", "acRate": 0.6216485707954797, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "439", "isFavor": false, "solutionNum": 115, "title": "Ternary Expression Parser", "titleCn": "三元表达式解析器", "titleSlug": "ternary-expression-parser", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 5, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1710493695-BDIDDc-Pocket Gems.jpeg", "slug": "pocket-gems", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/455700859e03a769dcb90fabbcce91f17af10954d6cab1b473c341ae8511915c-snapchat_logo1-300x300.png", "slug": "snapchat", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "440": {"__typename": "QuestionLightNode", "acRate": 0.423887492907514, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "440", "isFavor": false, "solutionNum": 312, "title": "K-th Smallest in Lexicographical Order", "titleCn": "字典序的第K小数字", "titleSlug": "k-th-smallest-in-lexicographical-order", "topicTags": [{"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 27, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定整数&nbsp;<code>n</code>&nbsp;和&nbsp;<code>k</code>，返回&nbsp;&nbsp;<code>[1, n]</code>&nbsp;中字典序第&nbsp;<code>k</code>&nbsp;小的数字。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>n = 13, k = 2\n<strong>输出: </strong>10\n<strong>解释: </strong>字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 1, k = 1\n<strong>输出:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Given two integers <code>n</code> and <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>lexicographically smallest integer in the range</em> <code>[1, n]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 13, k = 2\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, k = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "441": {"__typename": "QuestionLightNode", "acRate": 0.4505583811349122, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "441", "isFavor": false, "solutionNum": 1196, "title": "Arranging Coins", "titleCn": "排列硬币", "titleSlug": "arranging-coins", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 27, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676258004-GqverQ-GoDaddy.png", "slug": "godaddy", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你总共有&nbsp;<code>n</code><em>&nbsp;</em>枚硬币，并计划将它们按阶梯状排列。对于一个由 <code>k</code> 行组成的阶梯，其第 <code>i</code><em> </em>行必须正好有 <code>i</code><em> </em>枚硬币。阶梯的最后一行 <strong>可能</strong> 是不完整的。</p>\n\n<p>给你一个数字&nbsp;<code>n</code><em> </em>，计算并返回可形成 <strong>完整阶梯行</strong> 的总行数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/arrangecoins1-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>因为第三行不完整，所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg\" style=\"width: 333px; height: 333px;\" />\n<pre>\n<strong>输入：</strong>n = 8\n<strong>输出：</strong>3\n<strong>解释：</strong>因为第四行不完整，所以返回 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>You have <code>n</code> coins and you want to build a staircase with these coins. The staircase consists of <code>k</code> rows where the <code>i<sup>th</sup></code> row has exactly <code>i</code> coins. The last row of the staircase <strong>may be</strong> incomplete.</p>\n\n<p>Given the integer <code>n</code>, return <em>the number of <strong>complete rows</strong> of the staircase you will build</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/arrangecoins1-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Because the 3<sup>rd</sup> row is incomplete, we return 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg\" style=\"width: 333px; height: 333px;\" />\n<pre>\n<strong>Input:</strong> n = 8\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Because the 4<sup>th</sup> row is incomplete, we return 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "442": {"__typename": "QuestionLightNode", "acRate": 0.7507757963725042, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "442", "isFavor": false, "solutionNum": 1094, "title": "Find All Duplicates in an Array", "titleCn": "数组中重复的数据", "titleSlug": "find-all-duplicates-in-an-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 58, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，其中 <code>nums</code> 的所有整数都在范围 <code>[1, n]</code> 内，且每个整数出现 <strong>一次</strong> 或 <strong>两次</strong> 。请你找出所有出现 <strong>两次</strong> 的整数，并以数组形式返回。</p>\n\n<p>你必须设计并实现一个时间复杂度为 <code>O(n)</code> 且仅使用常量额外空间的算法解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,3,2,7,8,2,3,1]\n<strong>输出：</strong>[2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,2]\n<strong>输出：</strong>[1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= n</code></li>\n\t<li><code>nums</code> 中的每个元素出现 <strong>一次</strong> 或 <strong>两次</strong></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> of length <code>n</code> where all the integers of <code>nums</code> are in the range <code>[1, n]</code> and each integer appears <strong>once</strong> or <strong>twice</strong>, return <em>an array of all the integers that appears <strong>twice</strong></em>.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time and uses only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [4,3,2,7,8,2,3,1]\n<strong>Output:</strong> [2,3]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1,2]\n<strong>Output:</strong> [1]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1]\n<strong>Output:</strong> []\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= n</code></li>\n\t<li>Each element in <code>nums</code> appears <strong>once</strong> or <strong>twice</strong>.</li>\n</ul>\n"}}, "443": {"__typename": "QuestionLightNode", "acRate": 0.4864177512679822, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "443", "isFavor": false, "solutionNum": 1036, "title": "String Compression", "titleCn": "压缩字符串", "titleSlug": "string-compression", "topicTags": [{"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 85, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符数组 <code>chars</code> ，请使用下述算法压缩：</p>\n\n<p>从一个空字符串 <code>s</code> 开始。对于 <code>chars</code> 中的每组 <strong>连续重复字符</strong> ：</p>\n\n<ul>\n\t<li>如果这一组长度为 <code>1</code> ，则将字符追加到 <code>s</code> 中。</li>\n\t<li>否则，需要向 <code>s</code> 追加字符，后跟这一组的长度。</li>\n</ul>\n\n<p>压缩后得到的字符串 <code>s</code> <strong>不应该直接返回</strong> ，需要转储到字符数组 <code>chars</code> 中。需要注意的是，如果组长度为 <code>10</code> 或 <code>10</code> 以上，则在 <code>chars</code> 数组中会被拆分为多个字符。</p>\n\n<p>请在 <strong>修改完输入数组后</strong> ，返回该数组的新长度。</p>\n\n<p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\n<strong>输出：</strong>返回 6 ，输入数组的前 6 个字符应该是：[\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\n<strong>解释：</strong>\"aa\" 被 \"a2\" 替代。\"bb\" 被 \"b2\" 替代。\"ccc\" 被 \"c3\" 替代。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>chars = [\"a\"]\n<strong>输出：</strong>返回 1 ，输入数组的前 1 个字符应该是：[\"a\"]\n<strong>解释：</strong>唯一的组是“a”，它保持未压缩，因为它是一个字符。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\n<strong>输出：</strong>返回 4 ，输入数组的前 4 个字符应该是：[\"a\",\"b\",\"1\",\"2\"]。\n<strong>解释：</strong>由于字符 \"a\" 不重复，所以不会被压缩。\"bbbbbbbbbbbb\" 被 “b12” 替代。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= chars.length &lt;= 2000</code></li>\n\t<li><code>chars[i]</code> 可以是小写英文字母、大写英文字母、数字或符号</li>\n</ul>\n", "en": "<p>Given an array of characters <code>chars</code>, compress it using the following algorithm:</p>\n\n<p>Begin with an empty string <code>s</code>. For each group of <strong>consecutive repeating characters</strong> in <code>chars</code>:</p>\n\n<ul>\n\t<li>If the group&#39;s length is <code>1</code>, append the character to <code>s</code>.</li>\n\t<li>Otherwise, append the character followed by the group&#39;s length.</li>\n</ul>\n\n<p>The compressed string <code>s</code> <strong>should not be returned separately</strong>, but instead, be stored <strong>in the input character array <code>chars</code></strong>. Note that group lengths that are <code>10</code> or longer will be split into multiple characters in <code>chars</code>.</p>\n\n<p>After you are done <strong>modifying the input array,</strong> return <em>the new length of the array</em>.</p>\n\n<p>You must write an algorithm that uses only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> chars = [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]\n<strong>Output:</strong> Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]\n<strong>Explanation:</strong> The groups are &quot;aa&quot;, &quot;bb&quot;, and &quot;ccc&quot;. This compresses to &quot;a2b2c3&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> chars = [&quot;a&quot;]\n<strong>Output:</strong> Return 1, and the first character of the input array should be: [&quot;a&quot;]\n<strong>Explanation:</strong> The only group is &quot;a&quot;, which remains uncompressed since it&#39;s a single character.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> chars = [&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;]\n<strong>Output:</strong> Return 4, and the first 4 characters of the input array should be: [&quot;a&quot;,&quot;b&quot;,&quot;1&quot;,&quot;2&quot;].\n<strong>Explanation:</strong> The groups are &quot;a&quot; and &quot;bbbbbbbbbbbb&quot;. This compresses to &quot;ab12&quot;.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= chars.length &lt;= 2000</code></li>\n\t<li><code>chars[i]</code> is a lowercase English letter, uppercase English letter, digit, or symbol.</li>\n</ul>\n"}}, "444": {"__typename": "QuestionLightNode", "acRate": 0.3242827868852459, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "444", "isFavor": false, "solutionNum": 89, "title": "Sequence Reconstruction", "titleCn": "序列重建", "titleSlug": "sequence-reconstruction", "topicTags": [{"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}, {"id": "ns19t", "name": "Topological Sort", "slug": "topological-sort", "nameTranslated": "拓扑排序", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 4, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/69b04f1307e68eca96bbb23e323248c381fa077af24968a7d919b45da515f802-0.png", "slug": "uipath", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "445": {"__typename": "QuestionLightNode", "acRate": 0.6100020572224332, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "445", "isFavor": false, "solutionNum": 1557, "title": "Add Two Numbers II", "titleCn": "两数相加 II", "titleSlug": "add-two-numbers-ii", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 62, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个 <strong>非空 </strong>链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>\n\n<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626420025-fZfzMX-image.png\" style=\"width: 302px; \" /></p>\n\n<pre>\n<strong>输入：</strong>l1 = [7,2,4,3], l2 = [5,6,4]\n<strong>输出：</strong>[7,8,0,7]\n</pre>\n\n<p><strong>示例2：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [2,4,3], l2 = [5,6,4]\n<strong>输出：</strong>[8,0,7]\n</pre>\n\n<p><strong>示例3：</strong></p>\n\n<pre>\n<strong>输入：</strong>l1 = [0], l2 = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>链表的长度范围为<code> [1, 100]</code></li>\n\t<li><code>0 &lt;= node.val &lt;= 9</code></li>\n\t<li>输入数据保证链表代表的数字无前导 0</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>如果输入链表不能翻转该如何解决？</p>\n", "en": "<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>\n\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/sumii-linked-list.jpg\" style=\"width: 523px; height: 342px;\" />\n<pre>\n<strong>Input:</strong> l1 = [7,2,4,3], l2 = [5,6,4]\n<strong>Output:</strong> [7,8,0,7]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [2,4,3], l2 = [5,6,4]\n<strong>Output:</strong> [8,0,7]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [0], l2 = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n\t<li>It is guaranteed that the list represents a number that does not have leading zeros.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong>&nbsp;Could you solve it without reversing the input lists?</p>\n"}}, "446": {"__typename": "QuestionLightNode", "acRate": 0.5410726829469856, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "446", "isFavor": false, "solutionNum": 227, "title": "Arithmetic Slices II - Subsequence", "titleCn": "等差数列划分 II - 子序列", "titleSlug": "arithmetic-slices-ii-subsequence", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 13, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中所有 <strong>等差子序列</strong> 的数目。</p>\n\n<p>如果一个序列中 <strong>至少有三个元素</strong> ，并且任意两个相邻元素之差相同，则称该序列为等差序列。</p>\n\n<ul>\n\t<li>例如，<code>[1, 3, 5, 7, 9]</code>、<code>[7, 7, 7, 7]</code> 和 <code>[3, -1, -5, -9]</code> 都是等差序列。</li>\n\t<li>再例如，<code>[1, 1, 2, 5, 7]</code> 不是等差序列。</li>\n</ul>\n\n<p>数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。</p>\n\n<ul>\n\t<li>例如，<code>[2,5,10]</code> 是 <code>[1,2,1,<em><strong>2</strong></em>,4,1,<strong><em>5</em></strong>,<em><strong>10</strong></em>]</code> 的一个子序列。</li>\n</ul>\n\n<p>题目数据保证答案是一个 <strong>32-bit</strong> 整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,4,6,8,10]\n<strong>输出：</strong>7\n<strong>解释：</strong>所有的等差子序列为：\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [7,7,7,7,7]\n<strong>输出：</strong>16\n<strong>解释：</strong>数组中的任意子序列都是等差子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1&nbsp; &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code>, return <em>the number of all the <strong>arithmetic subsequences</strong> of</em> <code>nums</code>.</p>\n\n<p>A sequence of numbers is called arithmetic if it consists of <strong>at least three elements</strong> and if the difference between any two consecutive elements is the same.</p>\n\n<ul>\n\t<li>For example, <code>[1, 3, 5, 7, 9]</code>, <code>[7, 7, 7, 7]</code>, and <code>[3, -1, -5, -9]</code> are arithmetic sequences.</li>\n\t<li>For example, <code>[1, 1, 2, 5, 7]</code> is not an arithmetic sequence.</li>\n</ul>\n\n<p>A <strong>subsequence</strong> of an array is a sequence that can be formed by removing some elements (possibly none) of the array.</p>\n\n<ul>\n\t<li>For example, <code>[2,5,10]</code> is a subsequence of <code>[1,2,1,<strong><u>2</u></strong>,4,1,<u><strong>5</strong></u>,<u><strong>10</strong></u>]</code>.</li>\n</ul>\n\n<p>The test cases are generated so that the answer fits in <strong>32-bit</strong> integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,4,6,8,10]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [7,7,7,7,7]\n<strong>Output:</strong> 16\n<strong>Explanation:</strong> Any subsequence of this array is arithmetic.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1&nbsp; &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "447": {"__typename": "QuestionLightNode", "acRate": 0.682052014861389, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "447", "isFavor": false, "solutionNum": 566, "title": "Number of Boomerangs", "titleCn": "回旋镖的数量", "titleSlug": "number-of-boomerangs", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定平面上<em>&nbsp;</em><code>n</code><em> </em>对 <strong>互不相同</strong> 的点&nbsp;<code>points</code> ，其中 <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 。<strong>回旋镖</strong> 是由点&nbsp;<code>(i, j, k)</code> 表示的元组 ，其中&nbsp;<code>i</code>&nbsp;和&nbsp;<code>j</code>&nbsp;之间的欧式距离和&nbsp;<code>i</code>&nbsp;和&nbsp;<code>k</code>&nbsp;之间的欧式距离相等（<strong>需要考虑元组的顺序</strong>）。</p>\n\n<p>返回平面上所有回旋镖的数量。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[0,0],[1,0],[2,0]]\n<strong>输出：</strong>2\n<strong>解释：</strong>两个回旋镖为 <strong>[[1,0],[0,0],[2,0]]</strong> 和 <strong>[[1,0],[2,0],[0,0]]</strong>\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,1],[2,2],[3,3]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,1]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n ==&nbsp;points.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>所有点都 <strong>互不相同</strong></li>\n</ul>\n", "en": "<p>You are given <code>n</code> <code>points</code> in the plane that are all <strong>distinct</strong>, where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>. A <strong>boomerang</strong> is a tuple of points <code>(i, j, k)</code> such that the distance between <code>i</code> and <code>j</code> equals the distance between <code>i</code> and <code>k</code> <strong>(the order of the tuple matters)</strong>.</p>\n\n<p>Return <em>the number of boomerangs</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> points = [[0,0],[1,0],[2,0]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> points = [[1,1],[2,2],[3,3]]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> points = [[1,1]]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == points.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n\t<li>All the points are <strong>unique</strong>.</li>\n</ul>\n"}}, "448": {"__typename": "QuestionLightNode", "acRate": 0.6579802236175, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "448", "isFavor": false, "solutionNum": 2099, "title": "Find All Numbers Disappeared in an Array", "titleCn": "找到所有数组中消失的数字", "titleSlug": "find-all-numbers-disappeared-in-an-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 34, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,3,2,7,8,2,3,1]\n<strong>输出：</strong>[5,6]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1]\n<strong>输出：</strong>[2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 <= n <= 10<sup>5</sup></code></li>\n\t<li><code>1 <= nums[i] <= n</code></li>\n</ul>\n\n<p><strong>进阶：</strong>你能在不使用额外空间且时间复杂度为<em> </em><code>O(n)</code><em> </em>的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。</p>\n", "en": "<p>Given an array <code>nums</code> of <code>n</code> integers where <code>nums[i]</code> is in the range <code>[1, n]</code>, return <em>an array of all the integers in the range</em> <code>[1, n]</code> <em>that do not appear in</em> <code>nums</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [4,3,2,7,8,2,3,1]\n<strong>Output:</strong> [5,6]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1]\n<strong>Output:</strong> [2]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= n</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you do it without extra space and in <code>O(n)</code> runtime? You may assume the returned list does not count as extra space.</p>\n"}}, "449": {"__typename": "QuestionLightNode", "acRate": 0.6225931517828851, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "449", "isFavor": false, "solutionNum": 541, "title": "Serialize and Deserialize BST", "titleCn": "序列化和反序列化二叉搜索树", "titleSlug": "serialize-and-deserialize-bst", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 37, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p>\n\n<p>设计一个算法来序列化和反序列化<strong> 二叉搜索树</strong> 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p>\n\n<p><strong>编码的字符串应尽可能紧凑。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,3]\n<strong>输出：</strong>[2,1,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = []\n<strong>输出：</strong>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数范围是 <code>[0, 10<sup>4</sup>]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>题目数据 <strong>保证</strong> 输入的树是一棵二叉搜索树。</li>\n</ul>\n", "en": "<p>Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>\n\n<p>Design an algorithm to serialize and deserialize a <b>binary search tree</b>. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.</p>\n\n<p><b>The encoded string should be as compact as possible.</b></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> [2,1,3]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>The input tree is <strong>guaranteed</strong> to be a binary search tree.</li>\n</ul>\n"}}, "450": {"__typename": "QuestionLightNode", "acRate": 0.5228828231182447, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "450", "isFavor": false, "solutionNum": 2229, "title": "Delete Node in a BST", "titleCn": "删除二叉搜索树中的节点", "titleSlug": "delete-node-in-a-bst", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 52, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/cf2a3ac504c38f16ee9e9e828b4f40ed444dc54e25653145bbfdf9f2f467115a-1587797765803.jpg", "slug": "oracle", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二叉搜索树的根节点 <strong>root </strong>和一个值 <strong>key</strong>，删除二叉搜索树中的&nbsp;<strong>key&nbsp;</strong>对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>\n\n<p>一般来说，删除节点可分为两个步骤：</p>\n\n<ol>\n\t<li>首先找到需要删除的节点；</li>\n\t<li>如果找到了，删除它。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg\" style=\"width: 800px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,3,6,2,4,null,7], key = 3\n<strong>输出：</strong>[5,4,6,2,null,null,7]\n<strong>解释：</strong>给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n另一个正确答案是 [5,2,6,null,4,null,7]。\n\n<img src=\"https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg\" style=\"width: 350px;\" />\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> root = [5,3,6,2,4,null,7], key = 0\n<strong>输出:</strong> [5,3,6,2,4,null,7]\n<strong>解释:</strong> 二叉树不包含值为 0 的节点\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> root = [], key = 0\n<strong>输出:</strong> []</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>节点数的范围&nbsp;<code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>节点值唯一</li>\n\t<li><code>root</code>&nbsp;是合法的二叉搜索树</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= key &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong> 要求算法时间复杂度为&nbsp;O(h)，h 为树的高度。</p>\n", "en": "<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return <em>the <strong>root node reference</strong> (possibly updated) of the BST</em>.</p>\n\n<p>Basically, the deletion can be divided into two stages:</p>\n\n<ol>\n\t<li>Search for a node to remove.</li>\n\t<li>If the node is found, delete the node.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg\" style=\"width: 800px; height: 214px;\" />\n<pre>\n<strong>Input:</strong> root = [5,3,6,2,4,null,7], key = 3\n<strong>Output:</strong> [5,4,6,2,null,null,7]\n<strong>Explanation:</strong> Given key to delete is 3. So we find the node with value 3 and delete it.\nOne valid answer is [5,4,6,2,null,null,7], shown in the above BST.\nPlease notice that another valid answer is [5,2,6,null,4,null,7] and it&#39;s also accepted.\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg\" style=\"width: 350px; height: 255px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [5,3,6,2,4,null,7], key = 0\n<strong>Output:</strong> [5,3,6,2,4,null,7]\n<strong>Explanation:</strong> The tree does not contain a node with value = 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [], key = 0\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>Each node has a <strong>unique</strong> value.</li>\n\t<li><code>root</code> is a valid binary search tree.</li>\n\t<li><code>-10<sup>5</sup> &lt;= key &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve it with time complexity <code>O(height of tree)</code>?</p>\n"}}, "451": {"__typename": "QuestionLightNode", "acRate": 0.7214322389999057, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "451", "isFavor": false, "solutionNum": 1417, "title": "Sort Characters By Frequency", "titleCn": "根据字符出现频率排序", "titleSlug": "sort-characters-by-frequency", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "eqnkri", "name": "Bucket Sort", "slug": "bucket-sort", "nameTranslated": "桶排序", "__typename": "CommonTagNode"}, {"id": "pxpqcm", "name": "Counting", "slug": "counting", "nameTranslated": "计数", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 47, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个字符串 <code>s</code> ，根据字符出现的 <strong>频率</strong> 对其进行 <strong>降序排序</strong> 。一个字符出现的 <strong>频率</strong> 是它出现在字符串中的次数。</p>\n\n<p>返回 <em>已排序的字符串&nbsp;</em>。如果有多个答案，返回其中任何一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"tree\"\n<strong>输出: </strong>\"eert\"\n<strong>解释: </strong>'e'出现两次，'r'和't'都只出现一次。\n因此'e'必须出现在'r'和't'之前。此外，\"eetr\"也是一个有效的答案。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"cccaaa\"\n<strong>输出: </strong>\"cccaaa\"\n<strong>解释: </strong>'c'和'a'都出现三次。此外，\"aaaccc\"也是有效的答案。\n注意\"cacaca\"是不正确的，因为相同的字母必须放在一起。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>s = \"Aabb\"\n<strong>输出: </strong>\"bbAa\"\n<strong>解释: </strong>此外，\"bbaA\"也是一个有效的答案，但\"Aabb\"是不正确的。\n注意'A'和'a'被认为是两种不同的字符。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;由大小写英文字母和数字组成</li>\n</ul>\n", "en": "<p>Given a string <code>s</code>, sort it in <strong>decreasing order</strong> based on the <strong>frequency</strong> of the characters. The <strong>frequency</strong> of a character is the number of times it appears in the string.</p>\n\n<p>Return <em>the sorted string</em>. If there are multiple answers, return <em>any of them</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;tree&quot;\n<strong>Output:</strong> &quot;eert&quot;\n<strong>Explanation:</strong> &#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.\nSo &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cccaaa&quot;\n<strong>Output:</strong> &quot;aaaccc&quot;\n<strong>Explanation:</strong> Both &#39;c&#39; and &#39;a&#39; appear three times, so both &quot;cccaaa&quot; and &quot;aaaccc&quot; are valid answers.\nNote that &quot;cacaca&quot; is incorrect, as the same characters must be together.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;Aabb&quot;\n<strong>Output:</strong> &quot;bbAa&quot;\n<strong>Explanation:</strong> &quot;bbaA&quot; is also a valid answer, but &quot;Aabb&quot; is incorrect.\nNote that &#39;A&#39; and &#39;a&#39; are treated as two different characters.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of uppercase and lowercase English letters and digits.</li>\n</ul>\n"}}, "452": {"__typename": "QuestionLightNode", "acRate": 0.5135365081302984, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "452", "isFavor": false, "solutionNum": 1821, "title": "Minimum Number of Arrows to Burst Balloons", "titleCn": "用最少数量的箭引爆气球", "titleSlug": "minimum-number-of-arrows-to-burst-balloons", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 33, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组&nbsp;<code>points</code>&nbsp;，其中<code>points[i] = [x<sub>start</sub>, x<sub>end</sub>]</code>&nbsp;表示水平直径在&nbsp;<code>x<sub>start</sub></code>&nbsp;和&nbsp;<code>x<sub>end</sub></code>之间的气球。你不知道气球的确切 y 坐标。</p>\n\n<p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>x</code><sub><code>start</code>，</sub><code>x</code><sub><code>end</code>，</sub> 且满足 &nbsp;<code>x<sub>start</sub>&nbsp;≤ x ≤ x</code><sub><code>end</code>，</sub>则该气球会被 <strong>引爆</strong>&nbsp;<sub>。</sub>可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p>\n\n<p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数&nbsp;</em>。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[10,16],[2,8],[1,6],[7,12]]\n<strong>输出：</strong>2\n<strong>解释：</strong>气球可以用2支箭来爆破:\n-在x = 6处射出箭，击破气球[2,8]和[1,6]。\n-在x = 11处发射箭，击破气球[10,16]和[7,12]。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,2],[3,4],[5,6],[7,8]]\n<strong>输出：</strong>4\n<strong>解释：</strong>每个气球需要射出一支箭，总共需要4支箭。</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>points = [[1,2],[2,3],[3,4],[4,5]]\n<strong>输出：</strong>2\n解释：气球可以用2支箭来爆破:\n- 在x = 2处发射箭，击破气球[1,2]和[2,3]。\n- 在x = 4处射出箭，击破气球[3,4]和[4,5]。</pre>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= x<sub>start</sub>&nbsp;&lt; x<sub>end</sub>&nbsp;&lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n", "en": "<p>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array <code>points</code> where <code>points[i] = [x<sub>start</sub>, x<sub>end</sub>]</code> denotes a balloon whose <strong>horizontal diameter</strong> stretches between <code>x<sub>start</sub></code> and <code>x<sub>end</sub></code>. You do not know the exact y-coordinates of the balloons.</p>\n\n<p>Arrows can be shot up <strong>directly vertically</strong> (in the positive y-direction) from different points along the x-axis. A balloon with <code>x<sub>start</sub></code> and <code>x<sub>end</sub></code> is <strong>burst</strong> by an arrow shot at <code>x</code> if <code>x<sub>start</sub> &lt;= x &lt;= x<sub>end</sub></code>. There is <strong>no limit</strong> to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</p>\n\n<p>Given the array <code>points</code>, return <em>the <strong>minimum</strong> number of arrows that must be shot to burst all balloons</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> points = [[10,16],[2,8],[1,6],[7,12]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].\n- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> points = [[1,2],[3,4],[5,6],[7,8]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> One arrow needs to be shot for each balloon for a total of 4 arrows.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> points = [[1,2],[2,3],[3,4],[4,5]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The balloons can be burst by 2 arrows:\n- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].\n- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-2<sup>31</sup> &lt;= x<sub>start</sub> &lt; x<sub>end</sub> &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "453": {"__typename": "QuestionLightNode", "acRate": 0.6139188989196389, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "453", "isFavor": false, "solutionNum": 915, "title": "Minimum Moves to Equal Array Elements", "titleCn": "最小操作次数使数组元素相等", "titleSlug": "minimum-moves-to-equal-array-elements", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 39, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/b063fd6e06ce7f408968991858ee401239d7b2232b6451a66ad3d278cb1032ef-RWDlntRx.jpeg", "slug": "coursera", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937282-qSKaPF-Unknown-4.jpeg", "slug": "twitter", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个长度为 <code>n</code> 的整数数组，每次操作将会使 <code>n - 1</code> 个元素增加 <code>1</code> 。返回让数组所有元素相等的最小操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n只需要3次操作（注意每次操作会增加两个元素的值）：\n[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>答案保证符合 <strong>32-bit</strong> 整数</li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> of size <code>n</code>, return <em>the minimum number of moves required to make all array elements equal</em>.</p>\n\n<p>In one move, you can increment <code>n - 1</code> elements of the array by <code>1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Only three moves are needed (remember each move increments two elements):\n[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>The answer is guaranteed to fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n"}}, "454": {"__typename": "QuestionLightNode", "acRate": 0.644286795217188, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "454", "isFavor": false, "solutionNum": 1463, "title": "4Sum II", "titleCn": "四数相加 II", "titleSlug": "4sum-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 24, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j, k, l &lt; n</code></li>\n\t<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n两个元组如下：\n1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p>&nbsp; <strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>n == nums3.length</code></li>\n\t<li><code>n == nums4.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>-2<sup>28</sup> &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 2<sup>28</sup></code></li>\n</ul>\n", "en": "<p>Given four integer arrays <code>nums1</code>, <code>nums2</code>, <code>nums3</code>, and <code>nums4</code> all of length <code>n</code>, return the number of tuples <code>(i, j, k, l)</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j, k, l &lt; n</code></li>\n\t<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nThe two tuples are:\n1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums1.length</code></li>\n\t<li><code>n == nums2.length</code></li>\n\t<li><code>n == nums3.length</code></li>\n\t<li><code>n == nums4.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>-2<sup>28</sup> &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 2<sup>28</sup></code></li>\n</ul>\n"}}, "455": {"__typename": "QuestionLightNode", "acRate": 0.5611737279317889, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "455", "isFavor": false, "solutionNum": 2633, "title": "Assign Cookies", "titleCn": "分发饼干", "titleSlug": "assign-cookies", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 30, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>\n\n<p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code><sub>，</sub>这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code><sub> </sub>。如果 <code>s[j] >= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>\n \n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> g = [1,2,3], s = [1,1]\n<strong>输出:</strong> 1\n<strong>解释:</strong> \n你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。\n虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。\n所以你应该输出1。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> g = [1,2], s = [1,2,3]\n<strong>输出:</strong> 2\n<strong>解释:</strong> \n你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。\n你拥有的饼干数量和尺寸都足以让所有孩子满足。\n所以你应该输出2.\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= g.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 <= s.length <= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 <= g[i], s[j] <= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.</p>\n\n<p>Each child <code>i</code> has a greed factor <code>g[i]</code>, which is the minimum size of a cookie that the child will be content with; and each cookie <code>j</code> has a size <code>s[j]</code>. If <code>s[j] &gt;= g[i]</code>, we can assign the cookie <code>j</code> to the child <code>i</code>, and the child <code>i</code> will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> g = [1,2,3], s = [1,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> g = [1,2], s = [1,2,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= g.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= s.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= g[i], s[j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "456": {"__typename": "QuestionLightNode", "acRate": 0.36461872617320223, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "456", "isFavor": false, "solutionNum": 634, "title": "132 Pattern", "titleCn": "132 模式", "titleSlug": "132-pattern", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "qwy9jd", "name": "Ordered Set", "slug": "ordered-set", "nameTranslated": "有序集合", "__typename": "CommonTagNode"}, {"id": "xeyj5r5", "name": "Monotonic Stack", "slug": "monotonic-stack", "nameTranslated": "单调栈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 28, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> ，数组中共有 <code>n</code> 个整数。<strong>132 模式的子序列</strong> 由三个整数 <code>nums[i]</code>、<code>nums[j]</code> 和 <code>nums[k]</code> 组成，并同时满足：<code>i < j < k</code> 和 <code>nums[i] < nums[k] < nums[j]</code> 。</p>\n\n<p>如果 <code>nums</code> 中存在 <strong>132 模式的子序列</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>false\n<strong>解释：</strong>序列中不存在 132 模式的子序列。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3,1,4,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>序列中有 1 个 132 模式的子序列： [1, 4, 2] 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,3,2,0]\n<strong>输出：</strong>true\n<strong>解释：</strong>序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 <= n <= 2 * 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Given an array of <code>n</code> integers <code>nums</code>, a <strong>132 pattern</strong> is a subsequence of three integers <code>nums[i]</code>, <code>nums[j]</code> and <code>nums[k]</code> such that <code>i &lt; j &lt; k</code> and <code>nums[i] &lt; nums[k] &lt; nums[j]</code>.</p>\n\n<p>Return <code>true</code><em> if there is a <strong>132 pattern</strong> in </em><code>nums</code><em>, otherwise, return </em><code>false</code><em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no 132 pattern in the sequence.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,4,2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a 132 pattern in the sequence: [1, 4, 2].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,3,2,0]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "457": {"__typename": "QuestionLightNode", "acRate": 0.43431071908486374, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "457", "isFavor": false, "solutionNum": 388, "title": "Circular Array Loop", "titleCn": "环形数组是否存在循环", "titleSlug": "circular-array-loop", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 23, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>存在一个不含 <code>0</code> 的<strong> 环形 </strong>数组&nbsp;<code>nums</code> ，每个 <code>nums[i]</code> 都表示位于下标 <code>i</code> 的角色应该向前或向后移动的下标个数：</p>\n\n<ul>\n\t<li>如果 <code>nums[i]</code> 是正数，<strong>向前</strong>（下标递增方向）移动 <code>|nums[i]|</code> 步</li>\n\t<li>如果&nbsp;<code>nums[i]</code> 是负数，<strong>向后</strong>（下标递减方向）移动 <code>|nums[i]|</code> 步</li>\n</ul>\n\n<p>因为数组是 <strong>环形</strong> 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。</p>\n\n<p>数组中的 <strong>循环</strong> 由长度为 <code>k</code> 的下标序列 <code>seq</code> 标识：</p>\n\n<ul>\n\t<li>遵循上述移动规则将导致一组重复下标序列 <code>seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...</code></li>\n\t<li>所有 <code>nums[seq[j]]</code> 应当不是 <strong>全正</strong> 就是 <strong>全负</strong></li>\n\t<li><code>k &gt; 1</code></li>\n</ul>\n\n<p>如果 <code>nums</code> 中存在循环，返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> </em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,-1,1,2,2]\n<strong>输出：</strong>true\n<strong>解释：</strong>存在循环，按下标 0 -&gt; 2 -&gt; 3 -&gt; 0 。循环长度为 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>按下标 1 -&gt; 1 -&gt; 1 ... 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-2,1,-1,-2,-2]\n<strong>输出：</strong>false\n<strong>解释：</strong>按下标 1 -&gt; 2 -&gt; 1 -&gt; ... 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。\n所有 nums[seq[j]] 应当不是全正就是全负。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums[i] != 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你能设计一个时间复杂度为 <code>O(n)</code> 且额外空间复杂度为 <code>O(1)</code> 的算法吗？</p>\n", "en": "<p>You are playing a game involving a <strong>circular</strong> array of non-zero integers <code>nums</code>. Each <code>nums[i]</code> denotes the number of indices forward/backward you must move if you are located at index <code>i</code>:</p>\n\n<ul>\n\t<li>If <code>nums[i]</code> is positive, move <code>nums[i]</code> steps <strong>forward</strong>, and</li>\n\t<li>If <code>nums[i]</code> is negative, move <code>nums[i]</code> steps <strong>backward</strong>.</li>\n</ul>\n\n<p>Since the array is <strong>circular</strong>, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.</p>\n\n<p>A <strong>cycle</strong> in the array consists of a sequence of indices <code>seq</code> of length <code>k</code> where:</p>\n\n<ul>\n\t<li>Following the movement rules above results in the repeating index sequence <code>seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...</code></li>\n\t<li>Every <code>nums[seq[j]]</code> is either <strong>all positive</strong> or <strong>all negative</strong>.</li>\n\t<li><code>k &gt; 1</code></li>\n</ul>\n\n<p>Return <code>true</code><em> if there is a <strong>cycle</strong> in </em><code>nums</code><em>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/01/img1.jpg\" style=\"width: 402px; height: 289px;\" />\n<pre>\n<strong>Input:</strong> nums = [2,-1,1,2,2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.\nWe can see the cycle 0 --&gt; 2 --&gt; 3 --&gt; 0 --&gt; ..., and all of its nodes are white (jumping in the same direction).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/01/img2.jpg\" style=\"width: 402px; height: 390px;\" />\n<pre>\n<strong>Input:</strong> nums = [-1,-2,-3,-4,-5,6]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.\nThe only cycle is of size 1, so we return false.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/09/01/img3.jpg\" style=\"width: 497px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> nums = [1,-1,5,1,4]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.\nWe can see the cycle 0 --&gt; 1 --&gt; 0 --&gt; ..., and while it is of size &gt; 1, it has a node jumping forward and a node jumping backward, so <strong>it is not a cycle</strong>.\nWe can see the cycle 3 --&gt; 4 --&gt; 3 --&gt; ..., and all of its nodes are white (jumping in the same direction).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5000</code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums[i] != 0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve it in <code>O(n)</code> time complexity and <code>O(1)</code> extra space complexity?</p>\n"}}, "458": {"__typename": "QuestionLightNode", "acRate": 0.6641947670351196, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "458", "isFavor": false, "solutionNum": 255, "title": "Poor Pigs", "titleCn": "可怜的小猪", "titleSlug": "poor-pigs", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "rwhb85", "name": "Combinatorics", "slug": "combinatorics", "nameTranslated": "组合数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 22, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>有<code> buckets</code> 桶液体，其中 <strong>正好有一桶</strong>&nbsp;含有毒药，其余装的都是水。它们从外观看起来都一样。为了弄清楚哪只水桶含有毒药，你可以喂一些猪喝，通过观察猪是否会死进行判断。不幸的是，你只有&nbsp;<code>minutesToTest</code> 分钟时间来确定哪桶液体是有毒的。</p>\n\n<p>喂猪的规则如下：</p>\n\n<ol>\n\t<li>选择若干活猪进行喂养</li>\n\t<li>可以允许小猪同时饮用任意数量的桶中的水，并且该过程不需要时间。</li>\n\t<li>小猪喝完水后，必须有 <code>minutesToDie</code> 分钟的冷却时间。在这段时间里，你只能观察，而不允许继续喂猪。</li>\n\t<li>过了 <code>minutesToDie</code> 分钟后，所有喝到毒药的猪都会死去，其他所有猪都会活下来。</li>\n\t<li>重复这一过程，直到时间用完。</li>\n</ol>\n\n<p>给你桶的数目 <code>buckets</code> ，<code>minutesToDie</code> 和 <code>minutesToTest</code> ，返回&nbsp;<em>在规定时间内判断哪个桶有毒所需的 <strong>最小</strong> 猪数</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>buckets = 1000, minutesToDie = 15, minutesToTest = 60\n<strong>输出：</strong>5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>buckets = 4, minutesToDie = 15, minutesToTest = 15\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>buckets = 4, minutesToDie = 15, minutesToTest = 30\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= buckets &lt;= 1000</code></li>\n\t<li><code>1 &lt;=&nbsp;minutesToDie &lt;=&nbsp;minutesToTest &lt;= 100</code></li>\n</ul>\n", "en": "<p>There are <code>buckets</code> buckets of liquid, where <strong>exactly one</strong> of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have <code>minutesToTest</code> minutes to determine which bucket is poisonous.</p>\n\n<p>You can feed the pigs according to these steps:</p>\n\n<ol>\n\t<li>Choose some live pigs to feed.</li>\n\t<li>For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.</li>\n\t<li>Wait for <code>minutesToDie</code> minutes. You may <strong>not</strong> feed any other pigs during this time.</li>\n\t<li>After <code>minutesToDie</code> minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.</li>\n\t<li>Repeat this process until you run out of time.</li>\n</ol>\n\n<p>Given <code>buckets</code>, <code>minutesToDie</code>, and <code>minutesToTest</code>, return <em>the <strong>minimum</strong> number of pigs needed to figure out which bucket is poisonous within the allotted time</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> buckets = 4, minutesToDie = 15, minutesToTest = 15\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\nAt time 15, there are 4 possible outcomes:\n- If only the first pig dies, then bucket 1 must be poisonous.\n- If only the second pig dies, then bucket 3 must be poisonous.\n- If both pigs die, then bucket 2 must be poisonous.\n- If neither pig dies, then bucket 4 must be poisonous.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> buckets = 4, minutesToDie = 15, minutesToTest = 30\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig bucket 1, and feed the second pig bucket 2.\nAt time 15, there are 2 possible outcomes:\n- If either pig dies, then the poisonous bucket is the one it was fed.\n- If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.\nAt time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= buckets &lt;= 1000</code></li>\n\t<li><code>1 &lt;=&nbsp;minutesToDie &lt;=&nbsp;minutesToTest &lt;= 100</code></li>\n</ul>\n"}}, "459": {"__typename": "QuestionLightNode", "acRate": 0.5139292314481017, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "459", "isFavor": false, "solutionNum": 1586, "title": "Repeated Substring Pattern", "titleCn": "重复的子字符串", "titleSlug": "repeated-substring-pattern", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "ydzvgh", "name": "String Matching", "slug": "string-matching", "nameTranslated": "字符串匹配", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 38, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个非空的字符串<meta charset=\"UTF-8\" />&nbsp;<code>s</code>&nbsp;，检查是否可以通过由它的一个子串重复多次构成。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"abab\"\n<strong>输出:</strong> true\n<strong>解释:</strong> 可由子串 \"ab\" 重复两次构成。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"aba\"\n<strong>输出:</strong> false\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> s = \"abcabcabcabc\"\n<strong>输出:</strong> true\n<strong>解释:</strong> 可由子串 \"abc\" 重复四次构成。 (或子串 \"abcabc\" 重复两次构成。)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code>&nbsp;由小写英文字母组成</li>\n</ul>\n", "en": "<p>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abab&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> It is the substring &quot;ab&quot; twice.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aba&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcabcabcabc&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> It is the substring &quot;abc&quot; four times or the substring &quot;abcabc&quot; twice.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n"}}, "460": {"__typename": "QuestionLightNode", "acRate": 0.47303610051954426, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "460", "isFavor": false, "solutionNum": 765, "title": "LFU Cache", "titleCn": "LFU 缓存", "titleSlug": "lfu-cache", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "arqq05", "name": "Doubly-Linked List", "slug": "doubly-linked-list", "nameTranslated": "双向链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 71, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>请你为 <a href=\"https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95\">最不经常使用（LFU）</a>缓存算法设计并实现数据结构。</p>\n\n<p>实现 <code>LFUCache</code> 类：</p>\n\n<ul>\n\t<li><code>LFUCache(int capacity)</code> - 用数据结构的容量&nbsp;<code>capacity</code> 初始化对象</li>\n\t<li><code>int get(int key)</code>&nbsp;- 如果键&nbsp;<code>key</code> 存在于缓存中，则获取键的值，否则返回 <code>-1</code> 。</li>\n\t<li><code>void put(int key, int value)</code>&nbsp;- 如果键&nbsp;<code>key</code> 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量&nbsp;<code>capacity</code> 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最久未使用</strong> 的键。</li>\n</ul>\n\n<p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键。</p>\n\n<p>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 put 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增。</p>\n\n<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\n<strong>输出：</strong>\n[null, null, null, 1, null, -1, 3, null, -1, 3, 4]\n\n<strong>解释：</strong>\n// cnt(x) = 键 x 的使用计数\n// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）\nLFUCache lfu = new LFUCache(2);\nlfu.put(1, 1);   // cache=[1,_], cnt(1)=1\nlfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1\nlfu.get(1);      // 返回 1\n                 // cache=[1,2], cnt(2)=1, cnt(1)=2\nlfu.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小\n                 // cache=[3,1], cnt(3)=1, cnt(1)=2\nlfu.get(2);      // 返回 -1（未找到）\nlfu.get(3);      // 返回 3\n                 // cache=[3,1], cnt(3)=2, cnt(1)=2\nlfu.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用\n                 // cache=[4,3], cnt(4)=1, cnt(3)=2\nlfu.get(1);      // 返回 -1（未找到）\nlfu.get(3);      // 返回 3\n                 // cache=[3,4], cnt(4)=1, cnt(3)=3\nlfu.get(4);      // 返回 4\n                 // cache=[3,4], cnt(4)=2, cnt(3)=3</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= capacity&nbsp;&lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= key &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>9</sup></code></li>\n\t<li>最多调用 <code>2 * 10<sup>5</sup></code> 次 <code>get</code> 和 <code>put</code> 方法</li>\n</ul>\n", "en": "<p>Design and implement a data structure for a <a href=\"https://en.wikipedia.org/wiki/Least_frequently_used\" target=\"_blank\">Least Frequently Used (LFU)</a> cache.</p>\n\n<p>Implement the <code>LFUCache</code> class:</p>\n\n<ul>\n\t<li><code>LFUCache(int capacity)</code> Initializes the object with the <code>capacity</code> of the data structure.</li>\n\t<li><code>int get(int key)</code> Gets the value of the <code>key</code> if the <code>key</code> exists in the cache. Otherwise, returns <code>-1</code>.</li>\n\t<li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if present, or inserts the <code>key</code> if not already present. When the cache reaches its <code>capacity</code>, it should invalidate and remove the <strong>least frequently used</strong> key before inserting a new item. For this problem, when there is a <strong>tie</strong> (i.e., two or more keys with the same frequency), the <strong>least recently used</strong> <code>key</code> would be invalidated.</li>\n</ul>\n\n<p>To determine the least frequently used key, a <strong>use counter</strong> is maintained for each key in the cache. The key with the smallest <strong>use counter</strong> is the least frequently used key.</p>\n\n<p>When a key is first inserted into the cache, its <strong>use counter</strong> is set to <code>1</code> (due to the <code>put</code> operation). The <strong>use counter</strong> for a key in the cache is incremented either a <code>get</code> or <code>put</code> operation is called on it.</p>\n\n<p>The functions&nbsp;<code data-stringify-type=\"code\">get</code>&nbsp;and&nbsp;<code data-stringify-type=\"code\">put</code>&nbsp;must each run in <code>O(1)</code> average time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\n<strong>Output</strong>\n[null, null, null, 1, null, -1, 3, null, -1, 3, 4]\n\n<strong>Explanation</strong>\n// cnt(x) = the use counter for key x\n// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)\nLFUCache lfu = new LFUCache(2);\nlfu.put(1, 1);   // cache=[1,_], cnt(1)=1\nlfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1\nlfu.get(1);      // return 1\n                 // cache=[1,2], cnt(2)=1, cnt(1)=2\nlfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.\n&nbsp;                // cache=[3,1], cnt(3)=1, cnt(1)=2\nlfu.get(2);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,1], cnt(3)=2, cnt(1)=2\nlfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.\n                 // cache=[4,3], cnt(4)=1, cnt(3)=2\nlfu.get(1);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,4], cnt(4)=1, cnt(3)=3\nlfu.get(4);      // return 4\n                 // cache=[4,3], cnt(4)=2, cnt(3)=3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= capacity&nbsp;&lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= key &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= value &lt;= 10<sup>9</sup></code></li>\n\t<li>At most <code>2 * 10<sup>5</sup></code>&nbsp;calls will be made to <code>get</code> and <code>put</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<span style=\"display: none;\">&nbsp;</span>"}}, "461": {"__typename": "QuestionLightNode", "acRate": 0.8185552033095522, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "461", "isFavor": false, "solutionNum": 2174, "title": "Hamming Distance", "titleCn": "汉明距离", "titleSlug": "hamming-distance", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 34, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>两个整数之间的 <a href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB\">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p>\n\n<p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 1, y = 4\n<strong>输出：</strong>2\n<strong>解释：</strong>\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n上面的箭头指出了对应二进制位不同的位置。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>x = 3, y = 1\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 <= x, y <= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>The <a href=\"https://en.wikipedia.org/wiki/Hamming_distance\" target=\"_blank\">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>\n\n<p>Given two integers <code>x</code> and <code>y</code>, return <em>the <strong>Hamming distance</strong> between them</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 1, y = 4\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\n1   (0 0 0 1)\n4   (0 1 0 0)\n       &uarr;   &uarr;\nThe above arrows point to positions where the corresponding bits are different.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> x = 3, y = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;=&nbsp;x, y &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "462": {"__typename": "QuestionLightNode", "acRate": 0.6254691659148874, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "462", "isFavor": false, "solutionNum": 544, "title": "Minimum Moves to Equal Array Elements II", "titleCn": "最小操作次数使数组元素相等 II", "titleSlug": "minimum-moves-to-equal-array-elements-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 24, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，返回使所有数组元素相等需要的最小操作数。</p>\n\n<p>在一次操作中，你可以使数组中的一个元素加 <code>1</code> 或者减 <code>1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n只需要两次操作（每次操作指南使一个元素加 1 或减 1）：\n[<strong><em>1</em></strong>,2,3]  =&gt;  [2,2,<strong><em>3</em></strong>]  =&gt;  [2,2,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,10,2,9]\n<strong>输出：</strong>16\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> of size <code>n</code>, return <em>the minimum number of moves required to make all array elements equal</em>.</p>\n\n<p>In one move, you can increment or decrement an element of the array by <code>1</code>.</p>\n\n<p>Test cases are designed so that the answer will fit in a <strong>32-bit</strong> integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nOnly two moves are needed (remember each move increments or decrements one element):\n[<u>1</u>,2,3]  =&gt;  [2,2,<u>3</u>]  =&gt;  [2,2,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,10,2,9]\n<strong>Output:</strong> 16\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "463": {"__typename": "QuestionLightNode", "acRate": 0.7013817235655646, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "463", "isFavor": false, "solutionNum": 1604, "title": "Island Perimeter", "titleCn": "岛屿的周长", "titleSlug": "island-perimeter", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 39, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code> ，其中：<code>grid[i][j] = 1</code> 表示陆地， <code>grid[i][j] = 0</code> 表示水域。</p>\n\n<p>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>\n\n<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png\" /></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\n<strong>输出：</strong>16\n<strong>解释：</strong>它的周长是上面图片中的 16 个黄色的边</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1]]\n<strong>输出：</strong>4\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[1,0]]\n<strong>输出：</strong>4\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>row == grid.length</code></li>\n\t<li><code>col == grid[i].length</code></li>\n\t<li><code>1 <= row, col <= 100</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n", "en": "<p>You are given <code>row x col</code> <code>grid</code> representing a map where <code>grid[i][j] = 1</code> represents&nbsp;land and <code>grid[i][j] = 0</code> represents water.</p>\n\n<p>Grid cells are connected <strong>horizontally/vertically</strong> (not diagonally). The <code>grid</code> is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).</p>\n\n<p>The island doesn&#39;t have &quot;lakes&quot;, meaning the water inside isn&#39;t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don&#39;t exceed 100. Determine the perimeter of the island.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/island.png\" style=\"width: 221px; height: 213px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\n<strong>Output:</strong> 16\n<strong>Explanation:</strong> The perimeter is the 16 yellow stripes in the image above.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1]]\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1,0]]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>row == grid.length</code></li>\n\t<li><code>col == grid[i].length</code></li>\n\t<li><code>1 &lt;= row, col &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code> is <code>0</code> or <code>1</code>.</li>\n\t<li>There is exactly one island in <code>grid</code>.</li>\n</ul>\n"}}, "464": {"__typename": "QuestionLightNode", "acRate": 0.40748950527678607, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "464", "isFavor": false, "solutionNum": 302, "title": "Can I Win", "titleCn": "我能赢吗", "titleSlug": "can-i-win", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "vhos7", "name": "Memoization", "slug": "memoization", "nameTranslated": "记忆化搜索", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "eeprrj", "name": "Bitmask", "slug": "bitmask", "nameTranslated": "状态压缩", "__typename": "CommonTagNode"}, {"id": "vawmlm", "name": "Game Theory", "slug": "game-theory", "nameTranslated": "博弈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 30, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>在 \"100 game\" 这个游戏中，两名玩家轮流选择从 <code>1</code> 到 <code>10</code> 的任意整数，累计整数和，先使得累计整数和 <strong>达到或超过</strong>&nbsp; 100 的玩家，即为胜者。</p>\n\n<p>如果我们将游戏规则改为 “玩家 <strong>不能</strong> 重复使用整数” 呢？</p>\n\n<p>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。</p>\n\n<p>给定两个整数&nbsp;<code>maxChoosableInteger</code>&nbsp;（整数池中可选择的最大数）和&nbsp;<code>desiredTotal</code>（累计和），若先出手的玩家能稳赢则返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。假设两位玩家游戏时都表现 <strong>最佳</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>maxChoosableInteger = 10, desiredTotal = 11\n<strong>输出：</strong>false\n<strong>解释：\n</strong>无论第一个玩家选择哪个整数，他都会失败。\n第一个玩家可以选择从 1 到 10 的整数。\n如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。\n第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.\n同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>maxChoosableInteger = 10, desiredTotal = 0\n<b>输出：</b>true\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入：</strong>maxChoosableInteger = 10, desiredTotal = 1\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= maxChoosableInteger &lt;= 20</code></li>\n\t<li><code>0 &lt;= desiredTotal &lt;= 300</code></li>\n</ul>\n", "en": "<p>In the &quot;100 game&quot; two players take turns adding, to a running total, any integer from <code>1</code> to <code>10</code>. The player who first causes the running total to <strong>reach or exceed</strong> 100 wins.</p>\n\n<p>What if we change the game so that players <strong>cannot</strong> re-use integers?</p>\n\n<p>For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total &gt;= 100.</p>\n\n<p>Given two integers <code>maxChoosableInteger</code> and <code>desiredTotal</code>, return <code>true</code> if the first player to move can force a win, otherwise, return <code>false</code>. Assume both players play <strong>optimally</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> maxChoosableInteger = 10, desiredTotal = 11\n<strong>Output:</strong> false\n<strong>Explanation:</strong>\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> maxChoosableInteger = 10, desiredTotal = 0\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> maxChoosableInteger = 10, desiredTotal = 1\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= maxChoosableInteger &lt;= 20</code></li>\n\t<li><code>0 &lt;= desiredTotal &lt;= 300</code></li>\n</ul>\n"}}, "465": {"__typename": "QuestionLightNode", "acRate": 0.550844475721323, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "465", "isFavor": false, "solutionNum": 46, "title": "Optimal Account Balancing", "titleCn": "最优账单平衡", "titleSlug": "optimal-account-balancing", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "eeprrj", "name": "Bitmask", "slug": "bitmask", "nameTranslated": "状态压缩", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "466": {"__typename": "QuestionLightNode", "acRate": 0.4163497151588633, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "466", "isFavor": false, "solutionNum": 267, "title": "Count The Repetitions", "titleCn": "统计重复个数", "titleSlug": "count-the-repetitions", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 16, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>定义 <code>str = [s, n]</code> 表示 <code>str</code> 由 <code>n</code> 个字符串 <code>s</code> 连接构成。</p>\n\n<ul>\n\t<li>例如，<code>str == [\"abc\", 3] ==\"abcabcabc\"</code> 。</li>\n</ul>\n\n<p>如果可以从 <code>s2</code><sub> </sub>中删除某些字符使其变为 <code>s1</code>，则称字符串 <code>s1</code><sub> </sub>可以从字符串 <code>s2</code> 获得。</p>\n\n<ul>\n\t<li>例如，根据定义，<code>s1 = \"abc\"</code> 可以从 <code>s2 = \"ab<em><strong>dbe</strong></em>c\"</code> 获得，仅需要删除加粗且用斜体标识的字符。</li>\n</ul>\n\n<p>现在给你两个字符串 <code>s1</code> 和 <code>s2</code> 和两个整数 <code>n1</code> 和 <code>n2</code> 。由此构造得到两个字符串，其中 <code>str1 = [s1, n1]</code>、<code>str2 = [s2, n2]</code> 。</p>\n\n<p>请你找出一个最大整数 <code>m</code> ，以满足 <code>str = [str2, m]</code> 可以从 <code>str1</code> 获得。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s1.length, s2.length <= 100</code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 由小写英文字母组成</li>\n\t<li><code>1 <= n1, n2 <= 10<sup>6</sup></code></li>\n</ul>\n", "en": "<p>We define <code>str = [s, n]</code> as the string <code>str</code> which consists of the string <code>s</code> concatenated <code>n</code> times.</p>\n\n<ul>\n\t<li>For example, <code>str == [&quot;abc&quot;, 3] ==&quot;abcabcabc&quot;</code>.</li>\n</ul>\n\n<p>We define that string <code>s1</code> can be obtained from string <code>s2</code> if we can remove some characters from <code>s2</code> such that it becomes <code>s1</code>.</p>\n\n<ul>\n\t<li>For example, <code>s1 = &quot;abc&quot;</code> can be obtained from <code>s2 = &quot;ab<strong><u>dbe</u></strong>c&quot;</code> based on our definition by removing the bolded underlined characters.</li>\n</ul>\n\n<p>You are given two strings <code>s1</code> and <code>s2</code> and two integers <code>n1</code> and <code>n2</code>. You have the two strings <code>str1 = [s1, n1]</code> and <code>str2 = [s2, n2]</code>.</p>\n\n<p>Return <em>the maximum integer </em><code>m</code><em> such that </em><code>str = [str2, m]</code><em> can be obtained from </em><code>str1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n<strong>Output:</strong> 2\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n<strong>Output:</strong> 1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 100</code></li>\n\t<li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li>\n\t<li><code>1 &lt;= n1, n2 &lt;= 10<sup>6</sup></code></li>\n</ul>\n"}}, "467": {"__typename": "QuestionLightNode", "acRate": 0.5171443862247501, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "467", "isFavor": false, "solutionNum": 394, "title": "Unique Substrings in Wraparound String", "titleCn": "环绕字符串中唯一的子字符串", "titleSlug": "unique-substrings-in-wraparound-string", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>定义字符串&nbsp;<code>base</code>&nbsp;为一个&nbsp;<code>\"abcdefghijklmnopqrstuvwxyz\"</code>&nbsp;无限环绕的字符串，所以&nbsp;<code>base</code>&nbsp;看起来是这样的：</p>\n\n<ul>\n\t<li><code>\"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\"</code>.</li>\n</ul>\n\n<p>给你一个字符串&nbsp;<code>s</code> ，请你统计并返回&nbsp;<code>s</code>&nbsp;中有多少&nbsp;<strong>不同</strong><strong>非空子串</strong>&nbsp;也在&nbsp;<code>base</code>&nbsp;中出现。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"a\"\n<strong>输出：</strong>1\n<strong>解释：</strong>字符串 s 的子字符串 \"a\" 在 base 中出现。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cac\"\n<strong>输出：</strong>2\n<strong>解释：</strong>字符串 s 有两个子字符串 (\"a\", \"c\") 在 base 中出现。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"zab\"\n<strong>输出：</strong>6\n<strong>解释：</strong>字符串 s 有六个子字符串 (\"z\", \"a\", \"b\", \"za\", \"ab\", and \"zab\") 在 base 中出现。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size: 12.6px; background-color: rgb(249, 242, 244);\">s</span></font> 由小写英文字母组成</li>\n</ul>\n", "en": "<p>We define the string <code>base</code> to be the infinite wraparound string of <code>&quot;abcdefghijklmnopqrstuvwxyz&quot;</code>, so <code>base</code> will look like this:</p>\n\n<ul>\n\t<li><code>&quot;...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....&quot;</code>.</li>\n</ul>\n\n<p>Given a string <code>s</code>, return <em>the number of <strong>unique non-empty substrings</strong> of </em><code>s</code><em> are present in </em><code>base</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Only the substring &quot;a&quot; of s is in base.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cac&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are two substrings (&quot;a&quot;, &quot;c&quot;) of s in base.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;zab&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> There are six substrings (&quot;z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;za&quot;, &quot;ab&quot;, and &quot;zab&quot;) of s in base.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n"}}, "468": {"__typename": "QuestionLightNode", "acRate": 0.2818496110630942, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "468", "isFavor": false, "solutionNum": 750, "title": "Validate IP Address", "titleCn": "验证IP地址", "titleSlug": "validate-ip-address", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 60, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/406dcf66b3185e6dc364ebb3a5d7ac733be08100707c4e29f9b6b64d7e684cbd-UUA8Cz6q_400x400.jpg", "slug": "cisco", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个字符串&nbsp;<code>queryIP</code>。如果是有效的 IPv4 地址，返回 <code>\"IPv4\"</code> ；如果是有效的 IPv6 地址，返回 <code>\"IPv6\"</code> ；如果不是上述类型的 IP 地址，返回 <code>\"Neither\"</code> 。</p>\n\n<p><strong>有效的IPv4地址</strong> 是 <code>“x1.x2.x3.x4”</code> 形式的IP地址。 其中&nbsp;<code>0 &lt;= x<sub>i</sub>&nbsp;&lt;= 255</code>&nbsp;且&nbsp;<code>x<sub>i</sub></code>&nbsp;<strong>不能包含</strong> 前导零。例如:&nbsp;<code>“192.168.1.1”</code>&nbsp;、 <code>“192.168.1.0”</code> 为有效IPv4地址， <code>“192.168.01.1”</code> 为无效IPv4地址; <code>“192.168.1.00”</code> 、 <code>“192.168@1.1”</code> 为无效IPv4地址。</p>\n\n<p><strong>一个有效的IPv6地址&nbsp;</strong>是一个格式为<code>“x1:x2:x3:x4:x5:x6:x7:x8”</code> 的IP地址，其中:</p>\n\n<ul>\n\t<li><code>1 &lt;= x<sub>i</sub>.length &lt;= 4</code></li>\n\t<li><code>x<sub>i</sub></code>&nbsp;是一个 <strong>十六进制字符串</strong> ，可以包含数字、小写英文字母( <code>'a'</code> 到 <code>'f'</code> )和大写英文字母( <code>'A'</code> 到 <code>'F'</code> )。</li>\n\t<li>在&nbsp;<code>x<sub>i</sub></code>&nbsp;中允许前导零。</li>\n</ul>\n\n<p>例如 <code>\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"</code> 和 <code>\"2001:db8:85a3:0:0:8A2E:0370:7334\"</code> 是有效的 IPv6 地址，而 <code>\"2001:0db8:85a3::8A2E:037j:7334\"</code> 和 <code>\"02001:0db8:85a3:0000:0000:8a2e:0370:7334\"</code> 是无效的 IPv6 地址。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>queryIP = \"172.16.254.1\"\n<strong>输出：</strong>\"IPv4\"\n<strong>解释：</strong>有效的 IPv4 地址，返回 \"IPv4\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"\n<strong>输出：</strong>\"IPv6\"\n<strong>解释：</strong>有效的 IPv6 地址，返回 \"IPv6\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>queryIP = \"256.256.256.256\"\n<strong>输出：</strong>\"Neither\"\n<strong>解释：</strong>既不是 IPv4 地址，又不是 IPv6 地址\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>queryIP</code> 仅由英文字母，数字，字符 <code>'.'</code> 和 <code>':'</code> 组成。</li>\n</ul>\n", "en": "<p>Given a string <code>queryIP</code>, return <code>&quot;IPv4&quot;</code> if IP is a valid IPv4 address, <code>&quot;IPv6&quot;</code> if IP is a valid IPv6 address or <code>&quot;Neither&quot;</code> if IP is not a correct IP of any type.</p>\n\n<p><strong>A valid IPv4</strong> address is an IP in the form <code>&quot;x<sub>1</sub>.x<sub>2</sub>.x<sub>3</sub>.x<sub>4</sub>&quot;</code> where <code>0 &lt;= x<sub>i</sub> &lt;= 255</code> and <code>x<sub>i</sub></code> <strong>cannot contain</strong> leading zeros. For example, <code>&quot;192.168.1.1&quot;</code> and <code>&quot;192.168.1.0&quot;</code> are valid IPv4 addresses while <code>&quot;192.168.01.1&quot;</code>, <code>&quot;192.168.1.00&quot;</code>, and <code>&quot;192.168@1.1&quot;</code> are invalid IPv4 addresses.</p>\n\n<p><strong>A valid IPv6</strong> address is an IP in the form <code>&quot;x<sub>1</sub>:x<sub>2</sub>:x<sub>3</sub>:x<sub>4</sub>:x<sub>5</sub>:x<sub>6</sub>:x<sub>7</sub>:x<sub>8</sub>&quot;</code> where:</p>\n\n<ul>\n\t<li><code>1 &lt;= x<sub>i</sub>.length &lt;= 4</code></li>\n\t<li><code>x<sub>i</sub></code> is a <strong>hexadecimal string</strong> which may contain digits, lowercase English letter (<code>&#39;a&#39;</code> to <code>&#39;f&#39;</code>) and upper-case English letters (<code>&#39;A&#39;</code> to <code>&#39;F&#39;</code>).</li>\n\t<li>Leading zeros are allowed in <code>x<sub>i</sub></code>.</li>\n</ul>\n\n<p>For example, &quot;<code>2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;</code> and &quot;<code>2001:db8:85a3:0:0:8A2E:0370:7334&quot;</code> are valid IPv6 addresses, while &quot;<code>2001:0db8:85a3::8A2E:037j:7334&quot;</code> and &quot;<code>02001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;</code> are invalid IPv6 addresses.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> queryIP = &quot;172.16.254.1&quot;\n<strong>Output:</strong> &quot;IPv4&quot;\n<strong>Explanation:</strong> This is a valid IPv4 address, return &quot;IPv4&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> queryIP = &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;\n<strong>Output:</strong> &quot;IPv6&quot;\n<strong>Explanation:</strong> This is a valid IPv6 address, return &quot;IPv6&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> queryIP = &quot;256.256.256.256&quot;\n<strong>Output:</strong> &quot;Neither&quot;\n<strong>Explanation:</strong> This is neither a IPv4 address nor a IPv6 address.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>queryIP</code> consists only of English letters, digits and the characters <code>&#39;.&#39;</code> and <code>&#39;:&#39;</code>.</li>\n</ul>\n"}}, "469": {"__typename": "QuestionLightNode", "acRate": 0.42910505836575874, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "469", "isFavor": false, "solutionNum": 37, "title": "Convex Polygon", "titleCn": "凸多边形", "titleSlug": "convex-polygon", "topicTags": [{"id": "vlt55", "name": "Geometry", "slug": "geometry", "nameTranslated": "几何", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1673523346-gJTDQc-miHoYo.png", "slug": "mihoyo", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1711018980-nuLNJY-Flexport.png", "slug": "flexport", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "470": {"__typename": "QuestionLightNode", "acRate": 0.5513165605538395, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "470", "isFavor": false, "solutionNum": 496, "title": "Implement Rand10() Using Rand7()", "titleCn": "用 Rand7() 实现 Rand10()", "titleSlug": "implement-rand10-using-rand7", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "xx7d982", "name": "Rejection Sampling", "slug": "rejection-sampling", "nameTranslated": "拒绝采样", "__typename": "CommonTagNode"}, {"id": "xp2pz2j", "name": "Probability and Statistics", "slug": "probability-and-statistics", "nameTranslated": "概率与统计", "__typename": "CommonTagNode"}, {"id": "xp2m6at", "name": "Randomized", "slug": "randomized", "nameTranslated": "随机化", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 40, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode.cn/aliyun-lc-upload/uploaded_files/2023/01/e68645fd-9dd0-46ee-b97c-f4ad64a07848/3%26fmt%3Dauto%26app%3D120%26f%3DJPEG.webp", "slug": "tencent", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定方法&nbsp;<code>rand7</code>&nbsp;可生成 <code>[1,7]</code> 范围内的均匀随机整数，试写一个方法&nbsp;<code>rand10</code>&nbsp;生成 <code>[1,10]</code> 范围内的均匀随机整数。</p>\n\n<p>你只能调用&nbsp;<code>rand7()</code>&nbsp;且不能调用其他方法。请不要使用系统的&nbsp;<code>Math.random()</code>&nbsp;方法。</p>\n\n<ol>\n</ol>\n\n<p>每个测试用例将有一个内部参数 <code>n</code>，即你实现的函数 <code>rand10()</code> 在测试时将被调用的次数。请注意，这不是传递给 <code>rand10()</code> 的参数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>1\n<strong>输出: </strong>[2]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入: </strong>2\n<strong>输出: </strong>[2,8]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入: </strong>3\n<strong>输出: </strong>[3,8,10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶:</strong></p>\n\n<ul>\n\t<li><code>rand7()</code>调用次数的&nbsp;<a href=\"https://en.wikipedia.org/wiki/Expected_value\" target=\"_blank\">期望值</a>&nbsp;是多少&nbsp;?</li>\n\t<li>你能否尽量少调用 <code>rand7()</code> ?</li>\n</ul>\n", "en": "<p>Given the <strong>API</strong> <code>rand7()</code> that generates a uniform random integer in the range <code>[1, 7]</code>, write a function <code>rand10()</code> that generates a uniform random integer in the range <code>[1, 10]</code>. You can only call the API <code>rand7()</code>, and you shouldn&#39;t call any other API. Please <strong>do not</strong> use a language&#39;s built-in random API.</p>\n\n<p>Each test case will have one <strong>internal</strong> argument <code>n</code>, the number of times that your implemented function <code>rand10()</code> will be called while testing. Note that this is <strong>not an argument</strong> passed to <code>rand10()</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 1\n<strong>Output:</strong> [2]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 2\n<strong>Output:</strong> [2,8]\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> n = 3\n<strong>Output:</strong> [3,8,10]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>What is the <a href=\"https://en.wikipedia.org/wiki/Expected_value\" target=\"_blank\">expected value</a> for the number of calls to <code>rand7()</code> function?</li>\n\t<li>Could you minimize the number of calls to <code>rand7()</code>?</li>\n</ul>\n"}}, "471": {"__typename": "QuestionLightNode", "acRate": 0.5892591806410529, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "471", "isFavor": false, "solutionNum": 46, "title": "Encode String with Shortest Length", "titleCn": "编码最短长度的字符串", "titleSlug": "encode-string-with-shortest-length", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 12, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "472": {"__typename": "QuestionLightNode", "acRate": 0.5196336494429019, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "472", "isFavor": false, "solutionNum": 279, "title": "Concatenated Words", "titleCn": "连接词", "titleSlug": "concatenated-words", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 27, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/455700859e03a769dcb90fabbcce91f17af10954d6cab1b473c341ae8511915c-snapchat_logo1-300x300.png", "slug": "snapchat", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个 <strong>不含重复 </strong>单词的字符串数组 <code>words</code> ，请你找出并返回 <code>words</code> 中的所有 <strong>连接词</strong> 。</p>\n\n<p><strong>连接词</strong> 定义为：一个完全由给定数组中的至少两个较短单词（不一定是不同的两个单词）组成的字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n<strong>输出：</strong>[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\n<strong>解释：</strong>\"catsdogcats\" 由 \"cats\", \"dog\" 和 \"cats\" 组成; \n     \"dogcatsdog\" 由 \"dog\", \"cats\" 和 \"dog\" 组成; \n     \"ratcatdogcat\" 由 \"rat\", \"cat\", \"dog\" 和 \"cat\" 组成。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"cat\",\"dog\",\"catdog\"]\n<strong>输出：</strong>[\"catdog\"]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code>&nbsp;仅由小写英文字母组成。&nbsp;</li>\n\t<li><code>words</code>&nbsp;中的所有字符串都是 <strong>唯一</strong> 的。</li>\n\t<li><code>1 &lt;= sum(words[i].length) &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>Given an array of strings <code>words</code> (<strong>without duplicates</strong>), return <em>all the <strong>concatenated words</strong> in the given list of</em> <code>words</code>.</p>\n\n<p>A <strong>concatenated word</strong> is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct)&nbsp;in the given array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;cat&quot;,&quot;cats&quot;,&quot;catsdogcats&quot;,&quot;dog&quot;,&quot;dogcatsdog&quot;,&quot;hippopotamuses&quot;,&quot;rat&quot;,&quot;ratcatdogcat&quot;]\n<strong>Output:</strong> [&quot;catsdogcats&quot;,&quot;dogcatsdog&quot;,&quot;ratcatdogcat&quot;]\n<strong>Explanation:</strong> &quot;catsdogcats&quot; can be concatenated by &quot;cats&quot;, &quot;dog&quot; and &quot;cats&quot;; \n&quot;dogcatsdog&quot; can be concatenated by &quot;dog&quot;, &quot;cats&quot; and &quot;dog&quot;; \n&quot;ratcatdogcat&quot; can be concatenated by &quot;rat&quot;, &quot;cat&quot;, &quot;dog&quot; and &quot;cat&quot;.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;cat&quot;,&quot;dog&quot;,&quot;catdog&quot;]\n<strong>Output:</strong> [&quot;catdog&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code> consists of only lowercase English letters.</li>\n\t<li>All the strings of <code>words</code> are <strong>unique</strong>.</li>\n\t<li><code>1 &lt;= sum(words[i].length) &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "473": {"__typename": "QuestionLightNode", "acRate": 0.46711867277137, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "473", "isFavor": false, "solutionNum": 544, "title": "Matchsticks to Square", "titleCn": "火柴拼正方形", "titleSlug": "matchsticks-to-square", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "eeprrj", "name": "Bitmask", "slug": "bitmask", "nameTranslated": "状态压缩", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 27, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676258062-Lqtrvc-pdd.png", "slug": "pinduoduo", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你将得到一个整数数组 <code>matchsticks</code> ，其中 <code>matchsticks[i]</code> 是第 <code>i</code>&nbsp;个火柴棒的长度。你要用 <strong>所有的火柴棍</strong>&nbsp;拼成一个正方形。你 <strong>不能折断</strong> 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 <strong>使用一次</strong> 。</p>\n\n<p>如果你能使这个正方形，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/09/matchsticks1-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> matchsticks = [1,1,2,2,2]\n<strong>输出:</strong> true\n<strong>解释:</strong> 能拼成一个边长为2的正方形，每边两根火柴。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> matchsticks = [3,3,3,3,4]\n<strong>输出:</strong> false\n<strong>解释:</strong> 不能用所有火柴拼成一个正方形。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= matchsticks.length &lt;= 15</code></li>\n\t<li><code>1 &lt;= matchsticks[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n", "en": "<p>You are given an integer array <code>matchsticks</code> where <code>matchsticks[i]</code> is the length of the <code>i<sup>th</sup></code> matchstick. You want to use <strong>all the matchsticks</strong> to make one square. You <strong>should not break</strong> any stick, but you can link them up, and each matchstick must be used <strong>exactly one time</strong>.</p>\n\n<p>Return <code>true</code> if you can make this square and <code>false</code> otherwise.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/09/matchsticks1-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> matchsticks = [1,1,2,2,2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> You can form a square with length 2, one side of the square came two sticks with length 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> matchsticks = [3,3,3,3,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> You cannot find a way to form a square with all the matchsticks.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= matchsticks.length &lt;= 15</code></li>\n\t<li><code>1 &lt;= matchsticks[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n"}}, "474": {"__typename": "QuestionLightNode", "acRate": 0.6598206199421544, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "474", "isFavor": false, "solutionNum": 1213, "title": "Ones and Zeroes", "titleCn": "一和零", "titleSlug": "ones-and-zeroes", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 23, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p>\n\n<div class=\"MachineTrans-Lines\">\n<p class=\"MachineTrans-lang-zh-CN\">请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p>\n\n<p class=\"MachineTrans-lang-zh-CN\">如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"], m = 5, n = 3\n<strong>输出：</strong>4\n<strong>解释：</strong>最多有 5 个 0 和 3 个 1 的最大子集是 {\"10\",\"0001\",\"1\",\"0\"} ，因此答案是 4 。\n其他满足题意但较小的子集包括 {\"0001\",\"1\"} 和 {\"10\",\"1\",\"0\"} 。{\"111001\"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>strs = [\"10\", \"0\", \"1\"], m = 1, n = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>最大的子集是 {\"0\", \"1\"} ，所以答案是 2 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 600</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code>&nbsp;仅由&nbsp;<code>'0'</code> 和&nbsp;<code>'1'</code> 组成</li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n</ul>\n", "en": "<p>You are given an array of binary strings <code>strs</code> and two integers <code>m</code> and <code>n</code>.</p>\n\n<p>Return <em>the size of the largest subset of <code>strs</code> such that there are <strong>at most</strong> </em><code>m</code><em> </em><code>0</code><em>&#39;s and </em><code>n</code><em> </em><code>1</code><em>&#39;s in the subset</em>.</p>\n\n<p>A set <code>x</code> is a <strong>subset</strong> of a set <code>y</code> if all elements of <code>x</code> are also elements of <code>y</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> strs = [&quot;10&quot;,&quot;0001&quot;,&quot;111001&quot;,&quot;1&quot;,&quot;0&quot;], m = 5, n = 3\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The largest subset with at most 5 0&#39;s and 3 1&#39;s is {&quot;10&quot;, &quot;0001&quot;, &quot;1&quot;, &quot;0&quot;}, so the answer is 4.\nOther valid but smaller subsets include {&quot;0001&quot;, &quot;1&quot;} and {&quot;10&quot;, &quot;1&quot;, &quot;0&quot;}.\n{&quot;111001&quot;} is an invalid subset because it contains 4 1&#39;s, greater than the maximum of 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> strs = [&quot;10&quot;,&quot;0&quot;,&quot;1&quot;], m = 1, n = 1\n<strong>Output:</strong> 2\n<b>Explanation:</b> The largest subset is {&quot;0&quot;, &quot;1&quot;}, so the answer is 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 600</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 100</code></li>\n\t<li><code>strs[i]</code> consists only of digits <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code>.</li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n</ul>\n"}}, "475": {"__typename": "QuestionLightNode", "acRate": 0.41315824277558577, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "475", "isFavor": false, "solutionNum": 733, "title": "Heaters", "titleCn": "供暖器", "titleSlug": "heaters", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 30, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/d2e85988beccb271af4b1a8f4767e4bdf4c085aaf5aaef093347d778e4e138d7-20.png", "slug": "huawei", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>冬季已经来临。&nbsp;你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</p>\n\n<p>在加热器的加热半径范围内的每个房屋都可以获得供暖。</p>\n\n<p>现在，给出位于一条水平线上的房屋&nbsp;<code>houses</code> 和供暖器&nbsp;<code>heaters</code> 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。</p>\n\n<p><b>注意</b>：所有供暖器 <code>heaters</code> 都遵循你的半径标准，加热的半径也一样。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> houses = [1,2,3], heaters = [2]\n<strong>输出:</strong> 1\n<strong>解释:</strong> 仅在位置 2 上有一个供暖器。如果我们将加热半径设为 1，那么所有房屋就都能得到供暖。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> houses = [1,2,3,4], heaters = [1,4]\n<strong>输出:</strong> 1\n<strong>解释:</strong> 在位置 1, 4 上有两个供暖器。我们需要将加热半径设为 1，这样所有房屋就都能得到供暖。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>houses = [1,5], heaters = [2]\n<strong>输出：</strong>3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= houses.length, heaters.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= houses[i], heaters[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.</p>\n\n<p>Every house can be warmed, as long as the house is within the heater&#39;s warm radius range.&nbsp;</p>\n\n<p>Given the positions of <code>houses</code> and <code>heaters</code> on a horizontal line, return <em>the minimum radius standard of heaters&nbsp;so that those heaters could cover all houses.</em></p>\n\n<p><strong>Notice</strong> that&nbsp;all the <code>heaters</code> follow your radius standard, and the warm radius will the same.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> houses = [1,2,3], heaters = [2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> houses = [1,2,3,4], heaters = [1,4]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The two heaters were placed at positions 1 and 4. We need to use a radius 1 standard, then all the houses can be warmed.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> houses = [1,5], heaters = [2]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= houses.length, heaters.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= houses[i], heaters[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "476": {"__typename": "QuestionLightNode", "acRate": 0.6941767319606984, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "476", "isFavor": false, "solutionNum": 1158, "title": "Number Complement", "titleCn": "数字的补数", "titleSlug": "number-complement", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 28, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>对整数的二进制表示取反（<code>0</code> 变 <code>1</code> ，<code>1</code> 变 <code>0</code>）后，再转换为十进制表示，可以得到这个整数的补数。</p>\n\n<ul>\n\t<li>例如，整数 <code>5</code> 的二进制表示是 <code>\"101\"</code> ，取反后得到 <code>\"010\"</code> ，再转回十进制表示得到补数 <code>2</code> 。</li>\n</ul>\n\n<p>给你一个整数 <code>num</code> ，输出它的补数。</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 5\n<strong>输出：</strong>2\n<strong>解释：</strong>5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt; 2<sup>31</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与 1009 <a href=\"https://leetcode-cn.com/problems/complement-of-base-10-integer/\">https://leetcode-cn.com/problems/complement-of-base-10-integer/</a> 相同</p>\n", "en": "<p>The <strong>complement</strong> of an integer is the integer you get when you flip all the <code>0</code>&#39;s to <code>1</code>&#39;s and all the <code>1</code>&#39;s to <code>0</code>&#39;s in its binary representation.</p>\n\n<ul>\n\t<li>For example, The integer <code>5</code> is <code>&quot;101&quot;</code> in binary and its <strong>complement</strong> is <code>&quot;010&quot;</code> which is the integer <code>2</code>.</li>\n</ul>\n\n<p>Given an integer <code>num</code>, return <em>its complement</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 5\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 1\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt; 2<sup>31</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as 1009: <a href=\"https://leetcode.com/problems/complement-of-base-10-integer/\" target=\"_blank\">https://leetcode.com/problems/complement-of-base-10-integer/</a></p>\n"}}, "477": {"__typename": "QuestionLightNode", "acRate": 0.6062731636942517, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "477", "isFavor": false, "solutionNum": 399, "title": "Total Hamming Distance", "titleCn": "汉明距离总和", "titleSlug": "total-hamming-distance", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 13, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>两个整数的&nbsp;<a href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/475174?fr=aladdin\">汉明距离</a> 指的是这两个数字的二进制数对应位不同的数量。</p>\n\n<p>给你一个整数数组 <code>nums</code>，请你计算并返回 <code>nums</code> 中任意两个数之间 <strong>汉明距离的总和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,14,2]\n<strong>输出：</strong>6\n<strong>解释：</strong>在二进制表示中，4 表示为 0100 ，14 表示为 1110 ，2表示为 0010 。（这样表示是为了体现后四位之间关系）\n所以答案为：\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,14,4]\n<strong>输出：</strong>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>给定输入的对应答案符合 <strong>32-bit</strong> 整数范围</li>\n</ul>\n", "en": "<p>The <a href=\"https://en.wikipedia.org/wiki/Hamming_distance\" target=\"_blank\">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>\n\n<p>Given an integer array <code>nums</code>, return <em>the sum of <strong>Hamming distances</strong> between all the pairs of the integers in</em> <code>nums</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,14,2]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\nshowing the four bits relevant in this case).\nThe answer will be:\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,14,4]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li>The answer for the given input will fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n"}}, "478": {"__typename": "QuestionLightNode", "acRate": 0.48304756594334214, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "478", "isFavor": false, "solutionNum": 192, "title": "Generate Random Point in a Circle", "titleCn": "在圆内随机生成点", "titleSlug": "generate-random-point-in-a-circle", "topicTags": [{"id": "vlt55", "name": "Geometry", "slug": "geometry", "nameTranslated": "几何", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "xx7d982", "name": "Rejection Sampling", "slug": "rejection-sampling", "nameTranslated": "拒绝采样", "__typename": "CommonTagNode"}, {"id": "xp2m6at", "name": "Randomized", "slug": "randomized", "nameTranslated": "随机化", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2020/04/a29f4ff2-772d-4e94-b034-fe2815298cc9/%E7%BD%91%E6%98%93logo-%E6%96%B9.png", "slug": "netease", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定圆的半径和圆心的位置，实现函数 <code>randPoint</code> ，在圆中产生均匀随机点。</p>\n\n<p>实现&nbsp;<code>Solution</code>&nbsp;类:</p>\n\n<ul>\n\t<li><code>Solution(double radius, double x_center, double y_center)</code>&nbsp;用圆的半径&nbsp;<code>radius</code>&nbsp;和圆心的位置<code> (x_center, y_center)</code> 初始化对象</li>\n\t<li><code>randPoint()</code>&nbsp;返回圆内的一个随机点。圆周上的一点被认为在圆内。答案作为数组返回 <code>[x, y]</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入: \n</strong>[\"Solution\",\"randPoint\",\"randPoint\",\"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]\n<strong>输出: </strong>[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n<strong>解释:</strong>\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint ();//返回[-0.02493，-0.38077]\nsolution.randPoint ();//返回[0.82314,0.38945]\nsolution.randPoint ();//返回[0.36572,0.17248]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;&nbsp;radius &lt;= 10<sup>8</sup></code></li>\n\t<li><code>-10<sup>7</sup>&nbsp;&lt;= x_center, y_center &lt;= 10<sup>7</sup></code></li>\n\t<li><code>randPoint</code> 最多被调用&nbsp;<code>3 * 10<sup>4</sup></code>&nbsp;次</li>\n</ul>\n", "en": "<p>Given the radius and the position of the center of a circle, implement the function <code>randPoint</code> which generates a uniform random point inside the circle.</p>\n\n<p>Implement the <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution(double radius, double x_center, double y_center)</code> initializes the object with the radius of the circle <code>radius</code> and the position of the center <code>(x_center, y_center)</code>.</li>\n\t<li><code>randPoint()</code> returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array <code>[x, y]</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Solution&quot;, &quot;randPoint&quot;, &quot;randPoint&quot;, &quot;randPoint&quot;]\n[[1.0, 0.0, 0.0], [], [], []]\n<strong>Output</strong>\n[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n\n<strong>Explanation</strong>\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint(); // return [-0.02493, -0.38077]\nsolution.randPoint(); // return [0.82314, 0.38945]\nsolution.randPoint(); // return [0.36572, 0.17248]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;&nbsp;radius &lt;= 10<sup>8</sup></code></li>\n\t<li><code>-10<sup>7</sup> &lt;= x_center, y_center &lt;= 10<sup>7</sup></code></li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>randPoint</code>.</li>\n</ul>\n"}}, "479": {"__typename": "QuestionLightNode", "acRate": 0.6214074359963978, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "479", "isFavor": false, "solutionNum": 181, "title": "Largest Palindrome Product", "titleCn": "最大回文数乘积", "titleSlug": "largest-palindrome-product", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 12, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个整数 n ，返回 <em>可表示为两个 <code>n</code>&nbsp;位整数乘积的 <strong>最大回文整数</strong></em> 。因为答案可能非常大，所以返回它对 <code>1337</code> <strong>取余</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<b>输入：</b>n = 2\n<b>输出：</b>987\n<strong>解释：</strong>99 x 91 = 9009, 9009 % 1337 = 987\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入：</strong> n = 1\n<strong>输出：</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n", "en": "<p>Given an integer n, return <em>the <strong>largest palindromic integer</strong> that can be represented as the product of two <code>n</code>-digits integers</em>. Since the answer can be very large, return it <strong>modulo</strong> <code>1337</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 987\nExplanation: 99 x 91 = 9009, 9009 % 1337 = 987\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n"}}, "480": {"__typename": "QuestionLightNode", "acRate": 0.4238595178064923, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "480", "isFavor": false, "solutionNum": 549, "title": "Sliding Window Median", "titleCn": "滑动窗口中位数", "titleSlug": "sliding-window-median", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 40, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。</p>\n\n<p>例如：</p>\n\n<ul>\n\t<li><code>[2,3,4]</code>，中位数是 <code>3</code></li>\n\t<li><code>[2,3]</code>，中位数是 <code>(2 + 3) / 2 = 2.5</code></li>\n</ul>\n\n<p>给你一个数组 <em>nums</em>，有一个长度为 <em>k</em> 的窗口从最左端滑动到最右端。窗口中有 <em>k</em> 个数，每次窗口向右移动 <em>1</em> 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<p>给出 <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>，以及 <em>k</em> = 3。</p>\n\n<pre>\n窗口位置                      中位数\n---------------               -----\n[1  3  -1] -3  5  3  6  7       1\n 1 [3  -1  -3] 5  3  6  7      -1\n 1  3 [-1  -3  5] 3  6  7      -1\n 1  3  -1 [-3  5  3] 6  7       3\n 1  3  -1  -3 [5  3  6] 7       5\n 1  3  -1  -3  5 [3  6  7]      6\n</pre>\n\n<p> 因此，返回该滑动窗口的中位数数组 <code>[1,-1,-1,3,5,6]</code>。</p>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>你可以假设 <code>k</code> 始终有效，即：<code>k</code> 始终小于等于输入的非空数组的元素个数。</li>\n\t<li>与真实值误差在 <code>10 ^ -5</code> 以内的答案将被视作正确答案。</li>\n</ul>\n", "en": "<p>The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.</p>\n\n<ul>\n\t<li>For examples, if <code>arr = [2,<u>3</u>,4]</code>, the median is <code>3</code>.</li>\n\t<li>For examples, if <code>arr = [1,<u>2,3</u>,4]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</li>\n</ul>\n\n<p>You are given an integer array <code>nums</code> and an integer <code>k</code>. There is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>Return <em>the median array for each window in the original array</em>. Answers within <code>10<sup>-5</sup></code> of the actual value will be accepted.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3\n<strong>Output:</strong> [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\n<strong>Explanation:</strong> \nWindow position                Median\n---------------                -----\n[<strong>1  3  -1</strong>] -3  5  3  6  7        1\n 1 [<strong>3  -1  -3</strong>] 5  3  6  7       -1\n 1  3 [<strong>-1  -3  5</strong>] 3  6  7       -1\n 1  3  -1 [<strong>-3  5  3</strong>] 6  7        3\n 1  3  -1  -3 [<strong>5  3  6</strong>] 7        5\n 1  3  -1  -3  5 [<strong>3  6  7</strong>]       6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,2,3,1,4,2], k = 3\n<strong>Output:</strong> [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "481": {"__typename": "QuestionLightNode", "acRate": 0.6387137132906149, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "481", "isFavor": false, "solutionNum": 487, "title": "Magical String", "titleCn": "神奇字符串", "titleSlug": "magical-string", "topicTags": [{"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 10, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>神奇字符串 <code>s</code> 仅由 <code>'1'</code> 和 <code>'2'</code> 组成，并需要遵守下面的规则：</p>\n\n<ul>\n\t<li>神奇字符串 s 的神奇之处在于，串联字符串中 <code>'1'</code> 和 <code>'2'</code> 的连续出现次数可以生成该字符串。</li>\n</ul>\n\n<p><code>s</code> 的前几个元素是 <code>s = \"1221121221221121122……\"</code> 。如果将 <code>s</code> 中连续的若干 <code>1</code> 和 <code>2</code> 进行分组，可以得到 <code>\"1 22 11 2 1 22 1 22 11 2 11 22 ......\"</code> 。每组中 <code>1</code> 或者 <code>2</code> 的出现次数分别是 <code>\"1 2 2 1 1 2 1 2 2 1 2 2 ......\"</code> 。上面的出现次数正是 <code>s</code> 自身。</p>\n\n<p>给你一个整数 <code>n</code> ，返回在神奇字符串 <code>s</code> 的前 <code>n</code> 个数字中 <code>1</code> 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 6\n<strong>输出：</strong>3\n<strong>解释：</strong>神奇字符串 s 的前 6 个元素是 “<code>122112</code>”，它包含三个 1，因此返回 3 。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>A magical string <code>s</code> consists of only <code>&#39;1&#39;</code> and <code>&#39;2&#39;</code> and obeys the following rules:</p>\n\n<ul>\n\t<li>The string s is magical because concatenating the number of contiguous occurrences of characters <code>&#39;1&#39;</code> and <code>&#39;2&#39;</code> generates the string <code>s</code> itself.</li>\n</ul>\n\n<p>The first few elements of <code>s</code> is <code>s = &quot;1221121221221121122&hellip;&hellip;&quot;</code>. If we group the consecutive <code>1</code>&#39;s and <code>2</code>&#39;s in <code>s</code>, it will be <code>&quot;1 22 11 2 1 22 1 22 11 2 11 22 ......&quot;</code> and the occurrences of <code>1</code>&#39;s or <code>2</code>&#39;s in each group are <code>&quot;1 2 2 1 1 2 1 2 2 1 2 2 ......&quot;</code>. You can see that the occurrence sequence is <code>s</code> itself.</p>\n\n<p>Given an integer <code>n</code>, return the number of <code>1</code>&#39;s in the first <code>n</code> number in the magical string <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 6\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The first 6 elements of magical string s is &quot;122112&quot; and it contains three 1&#39;s, so return 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "482": {"__typename": "QuestionLightNode", "acRate": 0.4672858124048138, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "482", "isFavor": false, "solutionNum": 634, "title": "License Key Formatting", "titleCn": "密钥格式化", "titleSlug": "license-key-formatting", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1711090840-jlSkmv-capital one.png", "slug": "capital-one", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个许可密钥字符串 <code>s</code>，仅由字母、数字字符和破折号组成。字符串由 <code>n</code> 个破折号分成 <code>n + 1</code> 组。你也会得到一个整数 <code>k</code> 。</p>\n\n<p>我们想要重新格式化字符串&nbsp;<code>s</code>，使每一组包含 <code>k</code> 个字符，除了第一组，它可以比 <code>k</code> 短，但仍然必须包含至少一个字符。此外，两组之间必须插入破折号，并且应该将所有小写字母转换为大写字母。</p>\n\n<p>返回 <em>重新格式化的许可密钥</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>S = \"5F3Z-2e-9-w\", k = 4\n<strong>输出：</strong>\"5F3Z-2E9W\"\n<strong>解释：</strong>字符串 S 被分成了两个部分，每部分 4 个字符；\n&nbsp;    注意，两个额外的破折号需要删掉。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>S = \"2-5g-3-J\", k = 2\n<strong>输出：</strong>\"2-5G-3J\"\n<strong>解释：</strong>字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code>&nbsp;只包含字母、数字和破折号&nbsp;<code>'-'</code>.</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>You are given a license key represented as a string <code>s</code> that consists of only alphanumeric characters and dashes. The string is separated into <code>n + 1</code> groups by <code>n</code> dashes. You are also given an integer <code>k</code>.</p>\n\n<p>We want to reformat the string <code>s</code> such that each group contains exactly <code>k</code> characters, except for the first group, which could be shorter than <code>k</code> but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.</p>\n\n<p>Return <em>the reformatted license key</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;5F3Z-2e-9-w&quot;, k = 4\n<strong>Output:</strong> &quot;5F3Z-2E9W&quot;\n<strong>Explanation:</strong> The string s has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;2-5g-3-J&quot;, k = 2\n<strong>Output:</strong> &quot;2-5G-3J&quot;\n<strong>Explanation:</strong> The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of English letters, digits, and dashes <code>&#39;-&#39;</code>.</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "483": {"__typename": "QuestionLightNode", "acRate": 0.5868335787923417, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "483", "isFavor": false, "solutionNum": 153, "title": "Smallest Good Base", "titleCn": "最小好进制", "titleSlug": "smallest-good-base", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 5, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>以字符串的形式给出 <code>n</code>&nbsp;, 以字符串的形式返回<em> <code>n</code> 的最小 <strong>好进制</strong> </em>&nbsp;。</p>\n\n<p>如果 <code>n</code> 的 &nbsp;<code>k(k&gt;=2)</code>&nbsp;进制数的所有数位全为1，则称&nbsp;<code>k(k&gt;=2)</code>&nbsp;是 <code>n</code> 的一个&nbsp;<strong>好进制&nbsp;</strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = \"13\"\n<strong>输出：</strong>\"3\"\n<strong>解释：</strong>13 的 3 进制是 111。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = \"4681\"\n<strong>输出：</strong>\"8\"\n<strong>解释：</strong>4681 的 8 进制是 11111。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = \"1000000000000000000\"\n<strong>输出：</strong>\"999999999999999999\"\n<strong>解释：</strong>1000000000000000000 的 999999999999999999 进制是 11。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n</code> 的取值范围是&nbsp;<code>[3, 10<sup>18</sup>]</code></li>\n\t<li><code>n</code> 没有前导 0</li>\n</ul>\n", "en": "<p>Given an integer <code>n</code> represented as a string, return <em>the smallest <strong>good base</strong> of</em> <code>n</code>.</p>\n\n<p>We call <code>k &gt;= 2</code> a <strong>good base</strong> of <code>n</code>, if all digits of <code>n</code> base <code>k</code> are <code>1</code>&#39;s.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = &quot;13&quot;\n<strong>Output:</strong> &quot;3&quot;\n<strong>Explanation:</strong> 13 base 3 is 111.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = &quot;4681&quot;\n<strong>Output:</strong> &quot;8&quot;\n<strong>Explanation:</strong> 4681 base 8 is 11111.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = &quot;1000000000000000000&quot;\n<strong>Output:</strong> &quot;999999999999999999&quot;\n<strong>Explanation:</strong> 1000000000000000000 base 999999999999999999 is 11.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n</code> is an integer in the range <code>[3, 10<sup>18</sup>]</code>.</li>\n\t<li><code>n</code> does not contain any leading zeros.</li>\n</ul>\n"}}, "484": {"__typename": "QuestionLightNode", "acRate": 0.6022829678582157, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "484", "isFavor": false, "solutionNum": 68, "title": "Find Permutation", "titleCn": "寻找排列", "titleSlug": "find-permutation", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 4, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1598249949-DcnvwI-2295e083cb0eda207cc56e4ba6aadf55.jpg", "slug": "roblox", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "485": {"__typename": "QuestionLightNode", "acRate": 0.6119762327340073, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "485", "isFavor": false, "solutionNum": 1812, "title": "Max Consecutive Ones", "titleCn": "最大连续 1 的个数", "titleSlug": "max-consecutive-ones", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 28, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二进制数组 <code>nums</code> ， 计算其中最大连续 <code>1</code> 的个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,0,1,1,1]\n<strong>输出：</strong>3\n<strong>解释：</strong>开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>nums = [1,0,1,1,0,1]\n<b>输出：</b>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code>&nbsp;不是&nbsp;<code>0</code>&nbsp;就是&nbsp;<code>1</code>.</li>\n</ul>\n", "en": "<p>Given a binary array <code>nums</code>, return <em>the maximum number of consecutive </em><code>1</code><em>&#39;s in the array</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,0,1,1,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,1,1,0,1]\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> is either <code>0</code> or <code>1</code>.</li>\n</ul>\n"}}, "486": {"__typename": "QuestionLightNode", "acRate": 0.59395337922403, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "486", "isFavor": false, "solutionNum": 606, "title": "Predict the Winner", "titleCn": "预测赢家", "titleSlug": "predict-the-winner", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "vawmlm", "name": "Game Theory", "slug": "game-theory", "nameTranslated": "博弈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 40, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/406dcf66b3185e6dc364ebb3a5d7ac733be08100707c4e29f9b6b64d7e684cbd-UUA8Cz6q_400x400.jpg", "slug": "cisco", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。</p>\n\n<p>玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 <code>0</code> 。每一回合，玩家从数组的任意一端取一个数字（即，<code>nums[0]</code> 或 <code>nums[nums.length - 1]</code>），取到的数字将会从数组中移除（数组长度减 <code>1</code> ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。</p>\n\n<p>如果玩家 1 能成为赢家，返回 <code>true</code> 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 <code>true</code> 。你可以假设每个玩家的玩法都会使他的分数最大化。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,2]\n<strong>输出：</strong>false\n<strong>解释：</strong>一开始，玩家 1 可以从 1 和 2 中进行选择。\n如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。 \n所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。\n因此，玩家 1 永远不会成为赢家，返回 false 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,5,233,7]\n<strong>输出：</strong>true\n<strong>解释：</strong>玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。\n最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 true，表示玩家 1 可以成为赢家。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n", "en": "<p>You are given an integer array <code>nums</code>. Two players are playing a game with this array: player 1 and player 2.</p>\n\n<p>Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of <code>0</code>. At each turn, the player takes one of the numbers from either end of the array (i.e., <code>nums[0]</code> or <code>nums[nums.length - 1]</code>) which reduces the size of the array by <code>1</code>. The player adds the chosen number to their score. The game ends when there are no more elements in the array.</p>\n\n<p>Return <code>true</code> if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return <code>true</code>. You may assume that both players are playing optimally.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,2]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Initially, player 1 can choose between 1 and 2. \nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \nHence, player 1 will never be the winner and you need to return false.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,233,7]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n</ul>\n"}}, "487": {"__typename": "QuestionLightNode", "acRate": 0.5711636375897764, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "487", "isFavor": false, "solutionNum": 258, "title": "Max Consecutive Ones II", "titleCn": "最大连续1的个数 II", "titleSlug": "max-consecutive-ones-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676258097-UAvdFV-Zoom.png", "slug": "zoom", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "488": {"__typename": "QuestionLightNode", "acRate": 0.47050546112438857, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "488", "isFavor": false, "solutionNum": 188, "title": "Zuma Game", "titleCn": "祖玛游戏", "titleSlug": "zuma-game", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "vhos7", "name": "Memoization", "slug": "memoization", "nameTranslated": "记忆化搜索", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 16, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/78703b3d3d17ff1b249303bec7cd53d61ba4d1ff309f4293600ea7efe8b692ae-salesforce.png", "slug": "salesforce", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你正在参与祖玛游戏的一个变种。</p>\n\n<p>在这个祖玛游戏变体中，桌面上有 <strong>一排</strong> 彩球，每个球的颜色可能是：红色 <code>'R'</code>、黄色 <code>'Y'</code>、蓝色 <code>'B'</code>、绿色 <code>'G'</code> 或白色 <code>'W'</code> 。你的手中也有一些彩球。</p>\n\n<p>你的目标是 <strong>清空</strong> 桌面上所有的球。每一回合：</p>\n\n<ul>\n\t<li>从你手上的彩球中选出 <strong>任意一颗</strong> ，然后将其插入桌面上那一排球中：两球之间或这一排球的任一端。</li>\n\t<li>接着，如果有出现 <strong>三个或者三个以上</strong> 且 <strong>颜色相同</strong> 的球相连的话，就把它们移除掉。\n\t<ul>\n\t\t<li>如果这种移除操作同样导致出现三个或者三个以上且颜色相同的球相连，则可以继续移除这些球，直到不再满足移除条件。</li>\n\t</ul>\n\t</li>\n\t<li>如果桌面上所有球都被移除，则认为你赢得本场游戏。</li>\n\t<li>重复这个过程，直到你赢了游戏或者手中没有更多的球。</li>\n</ul>\n\n<p>给你一个字符串 <code>board</code> ，表示桌面上最开始的那排球。另给你一个字符串 <code>hand</code> ，表示手里的彩球。请你按上述操作步骤移除掉桌上所有球，计算并返回所需的 <strong>最少</strong> 球数。如果不能移除桌上所有的球，返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = \"WRRBBW\", hand = \"RB\"\n<strong>输出：</strong>-1\n<strong>解释：</strong>无法移除桌面上的所有球。可以得到的最好局面是：\n- 插入一个 'R' ，使桌面变为 WRR<em><strong>R</strong></em>BBW 。W<em><strong>RRR</strong></em>BBW -&gt; WBBW\n- 插入一个 'B' ，使桌面变为 WBB<em><strong>B</strong></em>W 。W<em><strong>BBB</strong></em>W -&gt; WW\n桌面上还剩着球，没有其他球可以插入。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = \"WWRRBBWW\", hand = \"WRBRW\"\n<strong>输出：</strong>2\n<strong>解释：</strong>要想清空桌面上的球，可以按下述步骤：\n- 插入一个 'R' ，使桌面变为 WWRR<strong><em>R</em></strong>BBWW 。WW<em><strong>RRR</strong></em>BBWW -&gt; WWBBWW\n- 插入一个 'B' ，使桌面变为 WWBB<em><strong>B</strong></em>WW 。WW<em><strong>BBB</strong></em>WW -&gt; <em><strong>WWWW</strong></em> -&gt; empty\n只需从手中出 2 个球就可以清空桌面。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = \"G\", hand = \"GGGGG\"\n<strong>输出：</strong>2\n<strong>解释：</strong>要想清空桌面上的球，可以按下述步骤：\n- 插入一个 'G' ，使桌面变为 G<em><strong>G</strong></em> 。\n- 插入一个 'G' ，使桌面变为 GG<em><strong>G</strong></em> 。<em><strong>GGG</strong></em> -&gt; empty\n只需从手中出 2 个球就可以清空桌面。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>board = \"RBYYBBRRB\", hand = \"YRBGB\"\n<strong>输出：</strong>3\n<strong>解释：</strong>要想清空桌面上的球，可以按下述步骤：\n- 插入一个 'Y' ，使桌面变为 RBYY<em><strong>Y</strong></em>BBRRB 。RB<em><strong>YYY</strong></em>BBRRB -&gt; R<em><strong>BBB</strong></em>RRB -&gt; <em><strong>RRR</strong></em>B -&gt; B\n- 插入一个 'B' ，使桌面变为 B<em><strong>B</strong></em> 。\n- 插入一个 'B' ，使桌面变为 BB<em><strong>B</strong></em> 。<em><strong>BBB</strong></em> -&gt; empty\n只需从手中出 3 个球就可以清空桌面。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= board.length &lt;= 16</code></li>\n\t<li><code>1 &lt;= hand.length &lt;= 5</code></li>\n\t<li><code>board</code> 和 <code>hand</code> 由字符 <code>'R'</code>、<code>'Y'</code>、<code>'B'</code>、<code>'G'</code> 和 <code>'W'</code> 组成</li>\n\t<li>桌面上一开始的球中，不会有三个及三个以上颜色相同且连着的球</li>\n</ul>\n", "en": "<p>You are playing a variation of the game Zuma.</p>\n\n<p>In this variation of Zuma, there is a <strong>single row</strong> of colored balls on a board, where each ball can be colored red <code>&#39;R&#39;</code>, yellow <code>&#39;Y&#39;</code>, blue <code>&#39;B&#39;</code>, green <code>&#39;G&#39;</code>, or white <code>&#39;W&#39;</code>. You also have several colored balls in your hand.</p>\n\n<p>Your goal is to <strong>clear all</strong> of the balls from the board. On each turn:</p>\n\n<ul>\n\t<li>Pick <strong>any</strong> ball from your hand and insert it in between two balls in the row or on either end of the row.</li>\n\t<li>If there is a group of <strong>three or more consecutive balls</strong> of the <strong>same color</strong>, remove the group of balls from the board.\n\t<ul>\n\t\t<li>If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.</li>\n\t</ul>\n\t</li>\n\t<li>If there are no more balls on the board, then you win the game.</li>\n\t<li>Repeat this process until you either win or do not have any more balls in your hand.</li>\n</ul>\n\n<p>Given a string <code>board</code>, representing the row of balls on the board, and a string <code>hand</code>, representing the balls in your hand, return <em>the <strong>minimum</strong> number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return </em><code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> board = &quot;WRRBBW&quot;, hand = &quot;RB&quot;\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> It is impossible to clear all the balls. The best you can do is:\n- Insert &#39;R&#39; so the board becomes WRR<u>R</u>BBW. W<u>RRR</u>BBW -&gt; WBBW.\n- Insert &#39;B&#39; so the board becomes WBB<u>B</u>W. W<u>BBB</u>W -&gt; WW.\nThere are still balls remaining on the board, and you are out of balls to insert.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> board = &quot;WWRRBBWW&quot;, hand = &quot;WRBRW&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> To make the board empty:\n- Insert &#39;R&#39; so the board becomes WWRR<u>R</u>BBWW. WW<u>RRR</u>BBWW -&gt; WWBBWW.\n- Insert &#39;B&#39; so the board becomes WWBB<u>B</u>WW. WW<u>BBB</u>WW -&gt; <u>WWWW</u> -&gt; empty.\n2 balls from your hand were needed to clear the board.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> board = &quot;G&quot;, hand = &quot;GGGGG&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> To make the board empty:\n- Insert &#39;G&#39; so the board becomes G<u>G</u>.\n- Insert &#39;G&#39; so the board becomes GG<u>G</u>. <u>GGG</u> -&gt; empty.\n2 balls from your hand were needed to clear the board.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= board.length &lt;= 16</code></li>\n\t<li><code>1 &lt;= hand.length &lt;= 5</code></li>\n\t<li><code>board</code> and <code>hand</code> consist of the characters <code>&#39;R&#39;</code>, <code>&#39;Y&#39;</code>, <code>&#39;B&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;W&#39;</code>.</li>\n\t<li>The initial row of balls on the board will <strong>not</strong> have any groups of three or more consecutive balls of the same color.</li>\n</ul>\n"}}, "489": {"__typename": "QuestionLightNode", "acRate": 0.738484677570972, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "489", "isFavor": false, "solutionNum": 40, "title": "Robot Room Cleaner", "titleCn": "扫地机器人", "titleSlug": "robot-room-cleaner", "topicTags": [{"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "0qo9zm", "name": "Interactive", "slug": "interactive", "nameTranslated": "交互", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 23, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "490": {"__typename": "QuestionLightNode", "acRate": 0.5142104272539055, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "490", "isFavor": false, "solutionNum": 154, "title": "The Maze", "titleCn": "迷宫", "titleSlug": "the-maze", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 31, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "491": {"__typename": "QuestionLightNode", "acRate": 0.5182395837278615, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "491", "isFavor": false, "solutionNum": 1044, "title": "Non-decreasing Subsequences", "titleCn": "非递减子序列", "titleSlug": "non-decreasing-subsequences", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 26, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n\n<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,6,7,7]\n<strong>输出：</strong>[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [4,4,3,2,1]\n<strong>输出：</strong>[[4,4]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 15</code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code>, return <em>all the different possible non-decreasing subsequences of the given array with at least two elements</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,6,7,7]\n<strong>Output:</strong> [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,4,3,2,1]\n<strong>Output:</strong> [[4,4]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 15</code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n"}}, "492": {"__typename": "QuestionLightNode", "acRate": 0.6183163810503819, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "492", "isFavor": false, "solutionNum": 562, "title": "Construct the Rectangle", "titleCn": "构造矩形", "titleSlug": "construct-the-rectangle", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 所以，现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：</p>\n\n<ol>\n\t<li>你设计的矩形页面必须等于给定的目标面积。</li>\n\t<li>宽度 <code>W</code>&nbsp;不应大于长度 <code>L</code> ，换言之，要求 <code>L &gt;= W </code>。</li>\n\t<li>长度 <code>L</code> 和宽度 <code>W</code>&nbsp;之间的差距应当尽可能小。</li>\n</ol>\n\n<p>返回一个&nbsp;<em>数组</em>&nbsp;<code>[L, W]</code>，其中 <em><code>L</code> 和 <code>W</code> 是你按照顺序设计的网页的长度和宽度</em>。<br />\n&nbsp;</p>\n\n<p><strong>示例1：</strong></p>\n\n<pre>\n<strong>输入:</strong> 4\n<strong>输出:</strong> [2, 2]\n<strong>解释:</strong> 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。\n但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> area = 37\n<strong>输出:</strong> [37,1]\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> area = 122122\n<strong>输出:</strong> [427,286]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= area &lt;= 10<sup>7</sup></code></li>\n</ul>\n", "en": "<p>A web developer needs to know how to design a web page&#39;s size. So, given a specific rectangular web page&rsquo;s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:</p>\n\n<ol>\n\t<li>The area of the rectangular web page you designed must equal to the given target area.</li>\n\t<li>The width <code>W</code> should not be larger than the length <code>L</code>, which means <code>L &gt;= W</code>.</li>\n\t<li>The difference between length <code>L</code> and width <code>W</code> should be as small as possible.</li>\n</ol>\n\n<p>Return <em>an array <code>[L, W]</code> where <code>L</code> and <code>W</code> are the length and width of the&nbsp;web page you designed in sequence.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> area = 4\n<strong>Output:</strong> [2,2]\n<strong>Explanation:</strong> The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. \nBut according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> area = 37\n<strong>Output:</strong> [37,1]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> area = 122122\n<strong>Output:</strong> [427,286]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= area &lt;= 10<sup>7</sup></code></li>\n</ul>\n"}}, "493": {"__typename": "QuestionLightNode", "acRate": 0.36965941797249763, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "493", "isFavor": false, "solutionNum": 440, "title": "Reverse Pairs", "titleCn": "翻转对", "titleSlug": "reverse-pairs", "topicTags": [{"id": "n16hs", "name": "Binary Indexed Tree", "slug": "binary-indexed-tree", "nameTranslated": "树状数组", "__typename": "CommonTagNode"}, {"id": "nytfd", "name": "Segment Tree", "slug": "segment-tree", "nameTranslated": "线段树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "qwy9jd", "name": "Ordered Set", "slug": "ordered-set", "nameTranslated": "有序集合", "__typename": "CommonTagNode"}, {"id": "xp2r1vv", "name": "Merge Sort", "slug": "merge-sort", "nameTranslated": "归并排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 34, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个数组&nbsp;<code>nums</code>&nbsp;，如果&nbsp;<code>i &lt; j</code>&nbsp;且&nbsp;<code>nums[i] &gt; 2*nums[j]</code>&nbsp;我们就将&nbsp;<code>(i, j)</code>&nbsp;称作一个<strong><em>重要翻转对</em></strong>。</p>\n\n<p>你需要返回给定数组中的重要翻转对的数量。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入</strong>: [1,3,2,3,1]\n<strong>输出</strong>: 2\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入</strong>: [2,4,3,5,1]\n<strong>输出</strong>: 3\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>给定数组的长度不会超过<code>50000</code>。</li>\n\t<li>输入数组中的所有数字都在32位整数的表示范围内。</li>\n</ol>\n", "en": "<p>Given an integer array <code>nums</code>, return <em>the number of <strong>reverse pairs</strong> in the array</em>.</p>\n\n<p>A <strong>reverse pair</strong> is a pair <code>(i, j)</code> where:</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; nums.length</code> and</li>\n\t<li><code>nums[i] &gt; 2 * nums[j]</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,2,3,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The reverse pairs are:\n(1, 4) --&gt; nums[1] = 3, nums[4] = 1, 3 &gt; 2 * 1\n(3, 4) --&gt; nums[3] = 3, nums[4] = 1, 3 &gt; 2 * 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,4,3,5,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The reverse pairs are:\n(1, 4) --&gt; nums[1] = 4, nums[4] = 1, 4 &gt; 2 * 1\n(2, 4) --&gt; nums[2] = 3, nums[4] = 1, 3 &gt; 2 * 1\n(3, 4) --&gt; nums[3] = 5, nums[4] = 1, 5 &gt; 2 * 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "494": {"__typename": "QuestionLightNode", "acRate": 0.4829362257788987, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "494", "isFavor": false, "solutionNum": 2225, "title": "Target Sum", "titleCn": "目标和", "titleSlug": "target-sum", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 44, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>\n\n<p>向数组中的每个整数前添加&nbsp;<code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>\n\n<ul>\n\t<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>\"+2-1\"</code> 。</li>\n</ul>\n\n<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,1,1], target = 3\n<strong>输出：</strong>5\n<strong>解释：</strong>一共有 5 种方法让最终目标和为 3 。\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1], target = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n</ul>\n", "en": "<p>You are given an integer array <code>nums</code> and an integer <code>target</code>.</p>\n\n<p>You want to build an <strong>expression</strong> out of nums by adding one of the symbols <code>&#39;+&#39;</code> and <code>&#39;-&#39;</code> before each integer in nums and then concatenate all the integers.</p>\n\n<ul>\n\t<li>For example, if <code>nums = [2, 1]</code>, you can add a <code>&#39;+&#39;</code> before <code>2</code> and a <code>&#39;-&#39;</code> before <code>1</code> and concatenate them to build the expression <code>&quot;+2-1&quot;</code>.</li>\n</ul>\n\n<p>Return the number of different <strong>expressions</strong> that you can build, which evaluates to <code>target</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1,1,1], target = 3\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> There are 5 ways to assign symbols to make the sum of nums be target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1], target = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 20</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n</ul>\n"}}, "495": {"__typename": "QuestionLightNode", "acRate": 0.593551846198456, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "495", "isFavor": false, "solutionNum": 1393, "title": "Teemo Attacking", "titleCn": "提莫攻击", "titleSlug": "teemo-attacking", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 16, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。</p>\n\n<p>当提莫攻击艾希，艾希的中毒状态正好持续&nbsp;<code>duration</code> 秒。</p>\n\n<p>正式地讲，提莫在 <code>t</code> 发起攻击意味着艾希在时间区间 <code>[t, t + duration - 1]</code>（含 <code>t</code> 和 <code>t + duration - 1</code>）处于中毒状态。如果提莫在中毒影响结束 <strong>前</strong> 再次攻击，中毒状态计时器将会 <strong>重置</strong> ，在新的攻击之后，中毒影响将会在 <code>duration</code> 秒后结束。</p>\n\n<p>给你一个 <strong>非递减</strong> 的整数数组 <code>timeSeries</code> ，其中 <code>timeSeries[i]</code> 表示提莫在 <code>timeSeries[i]</code> 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 <code>duration</code> 。</p>\n\n<p>返回艾希处于中毒状态的 <strong>总</strong> 秒数。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>timeSeries = [1,4], duration = 2\n<strong>输出：</strong>4\n<strong>解释：</strong>提莫攻击对艾希的影响如下：\n- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。\n- 第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。\n艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>timeSeries = [1,2], duration = 2\n<strong>输出：</strong>3\n<strong>解释：</strong>提莫攻击对艾希的影响如下：\n- 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。\n- 第 2 秒，提莫再次攻击艾希，并重置中毒计时器，艾希中毒状态需要持续 2 秒，即第 2 秒和第 3 秒。\n艾希在第 1、2、3 秒处于中毒状态，所以总中毒秒数是 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= timeSeries.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= timeSeries[i], duration &lt;= 10<sup>7</sup></code></li>\n\t<li><code>timeSeries</code> 按 <strong>非递减</strong> 顺序排列</li>\n</ul>\n", "en": "<p>Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly <code>duration</code> seconds. More formally, an attack at second <code>t</code> will mean Ashe is poisoned during the <strong>inclusive</strong> time interval <code>[t, t + duration - 1]</code>. If Teemo attacks again <strong>before</strong> the poison effect ends, the timer for it is <strong>reset</strong>, and the poison effect will end <code>duration</code> seconds after the new attack.</p>\n\n<p>You are given a <strong>non-decreasing</strong> integer array <code>timeSeries</code>, where <code>timeSeries[i]</code> denotes that Teemo attacks Ashe at second <code>timeSeries[i]</code>, and an integer <code>duration</code>.</p>\n\n<p>Return <em>the <strong>total</strong> number of seconds that Ashe is poisoned</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> timeSeries = [1,4], duration = 2\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Teemo&#39;s attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.\nAshe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> timeSeries = [1,2], duration = 2\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Teemo&#39;s attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.\nAshe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= timeSeries.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= timeSeries[i], duration &lt;= 10<sup>7</sup></code></li>\n\t<li><code>timeSeries</code> is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n"}}, "496": {"__typename": "QuestionLightNode", "acRate": 0.7192675888603884, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "496", "isFavor": false, "solutionNum": 2628, "title": "Next Greater Element I", "titleCn": "下一个更大元素 I", "titleSlug": "next-greater-element-i", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "xeyj5r5", "name": "Monotonic Stack", "slug": "monotonic-stack", "nameTranslated": "单调栈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 37, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><code>nums1</code>&nbsp;中数字&nbsp;<code>x</code>&nbsp;的 <strong>下一个更大元素</strong> 是指&nbsp;<code>x</code>&nbsp;在&nbsp;<code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比&nbsp;<code>x</code><strong>&nbsp;</strong>大的元素。</p>\n\n<p>给你两个<strong> 没有重复元素</strong> 的数组&nbsp;<code>nums1</code> 和&nbsp;<code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code>&nbsp;是&nbsp;<code>nums2</code>&nbsp;的子集。</p>\n\n<p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p>\n\n<p>返回一个长度为&nbsp;<code>nums1.length</code> 的数组<em> </em><code>ans</code><em> </em>作为答案，满足<em> </em><code>ans[i]</code><em> </em>是如上所述的 <strong>下一个更大元素</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [4,1,2], nums2 = [1,3,4,2].\n<strong>输出：</strong>[-1,3,-1]\n<strong>解释：</strong>nums1 中每个值的下一个更大元素如下所述：\n- 4 ，用加粗斜体标识，nums2 = [1,3,<strong>4</strong>,2]。不存在下一个更大元素，所以答案是 -1 。\n- 1 ，用加粗斜体标识，nums2 = [<em><strong>1</strong></em>,3,4,2]。下一个更大元素是 3 。\n- 2 ，用加粗斜体标识，nums2 = [1,3,4,<em><strong>2</strong></em>]。不存在下一个更大元素，所以答案是 -1 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [2,4], nums2 = [1,2,3,4].\n<strong>输出：</strong>[3,-1]\n<strong>解释：</strong>nums1 中每个值的下一个更大元素如下所述：\n- 2 ，用加粗斜体标识，nums2 = [1,<em><strong>2</strong></em>,3,4]。下一个更大元素是 3 。\n- 4 ，用加粗斜体标识，nums2 = [1,2,3,<em><strong>4</strong></em>]。不存在下一个更大元素，所以答案是 -1 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>\n\t<li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(nums1.length + nums2.length)</code> 的解决方案吗？</p>\n", "en": "<p>The <strong>next greater element</strong> of some element <code>x</code> in an array is the <strong>first greater</strong> element that is <strong>to the right</strong> of <code>x</code> in the same array.</p>\n\n<p>You are given two <strong>distinct 0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code>, where <code>nums1</code> is a subset of <code>nums2</code>.</p>\n\n<p>For each <code>0 &lt;= i &lt; nums1.length</code>, find the index <code>j</code> such that <code>nums1[i] == nums2[j]</code> and determine the <strong>next greater element</strong> of <code>nums2[j]</code> in <code>nums2</code>. If there is no next greater element, then the answer for this query is <code>-1</code>.</p>\n\n<p>Return <em>an array </em><code>ans</code><em> of length </em><code>nums1.length</code><em> such that </em><code>ans[i]</code><em> is the <strong>next greater element</strong> as described above.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [4,1,2], nums2 = [1,3,4,2]\n<strong>Output:</strong> [-1,3,-1]\n<strong>Explanation:</strong> The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,<u>4</u>,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [<u>1</u>,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,<u>2</u>]. There is no next greater element, so the answer is -1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [2,4], nums2 = [1,2,3,4]\n<strong>Output:</strong> [3,-1]\n<strong>Explanation:</strong> The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,<u>2</u>,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,<u>4</u>]. There is no next greater element, so the answer is -1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>All integers in <code>nums1</code> and <code>nums2</code> are <strong>unique</strong>.</li>\n\t<li>All the integers of <code>nums1</code> also appear in <code>nums2</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you find an <code>O(nums1.length + nums2.length)</code> solution?"}}, "497": {"__typename": "QuestionLightNode", "acRate": 0.41964330319228654, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "497", "isFavor": false, "solutionNum": 221, "title": "Random Point in Non-overlapping Rectangles", "titleCn": "非重叠矩形中的随机点", "titleSlug": "random-point-in-non-overlapping-rectangles", "topicTags": [{"id": "veg8i", "name": "Reservoir Sampling", "slug": "reservoir-sampling", "nameTranslated": "水塘抽样", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "qwy9jd", "name": "Ordered Set", "slug": "ordered-set", "nameTranslated": "有序集合", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}, {"id": "xp2m6at", "name": "Randomized", "slug": "randomized", "nameTranslated": "随机化", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个由非重叠的轴对齐矩形的数组 <code>rects</code> ，其中 <code>rects[i] = [ai, bi, xi, yi]</code> 表示 <code>(ai, bi)</code> 是第 <code>i</code> 个矩形的左下角点，<code>(xi, yi)</code> 是第 <code>i</code> 个矩形的右上角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。</p>\n\n<p>在给定的矩形覆盖的空间内的任何整数点都有可能被返回。</p>\n\n<p><strong>请注意&nbsp;</strong>，整数点是具有整数坐标的点。</p>\n\n<p>实现&nbsp;<code>Solution</code>&nbsp;类:</p>\n\n<ul>\n\t<li><code>Solution(int[][] rects)</code>&nbsp;用给定的矩形数组&nbsp;<code>rects</code> 初始化对象。</li>\n\t<li><code>int[] pick()</code>&nbsp;返回一个随机的整数点 <code>[u, v]</code> 在给定的矩形所覆盖的空间内。</li>\n</ul>\n\n<ol>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/07/24/lc-pickrandomrec.jpg\" style=\"height: 539px; width: 419px;\" /></p>\n\n<pre>\n<strong>输入: \n</strong>[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]\n<strong>输出: \n</strong>[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]\n\n<strong>解释：</strong>\nSolution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);\nsolution.pick(); // 返回 [1, -2]\nsolution.pick(); // 返回 [1, -1]\nsolution.pick(); // 返回 [-1, -2]\nsolution.pick(); // 返回 [-2, -2]\nsolution.pick(); // 返回 [0, 0]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rects.length &lt;= 100</code></li>\n\t<li><code>rects[i].length == 4</code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= a<sub>i</sub>&nbsp;&lt; x<sub>i</sub>&nbsp;&lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= b<sub>i</sub>&nbsp;&lt; y<sub>i</sub>&nbsp;&lt;= 10<sup>9</sup></code></li>\n\t<li><code>x<sub>i</sub>&nbsp;- a<sub>i</sub>&nbsp;&lt;= 2000</code></li>\n\t<li><code>y<sub>i</sub>&nbsp;- b<sub>i</sub>&nbsp;&lt;= 2000</code></li>\n\t<li>所有的矩形不重叠。</li>\n\t<li><code>pick</code> 最多被调用&nbsp;<code>10<sup>4</sup></code>&nbsp;次。</li>\n</ul>\n", "en": "<p>You are given an array of non-overlapping axis-aligned rectangles <code>rects</code> where <code>rects[i] = [a<sub>i</sub>, b<sub>i</sub>, x<sub>i</sub>, y<sub>i</sub>]</code> indicates that <code>(a<sub>i</sub>, b<sub>i</sub>)</code> is the bottom-left corner point of the <code>i<sup>th</sup></code> rectangle and <code>(x<sub>i</sub>, y<sub>i</sub>)</code> is the top-right corner point of the <code>i<sup>th</sup></code> rectangle. Design an algorithm to pick a random integer point inside the space covered by one of the given rectangles. A point on the perimeter of a rectangle is included in the space covered by the rectangle.</p>\n\n<p>Any integer point inside the space covered by one of the given rectangles should be equally likely to be returned.</p>\n\n<p><strong>Note</strong> that an integer point is a point that has integer coordinates.</p>\n\n<p>Implement the <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution(int[][] rects)</code> Initializes the object with the given rectangles <code>rects</code>.</li>\n\t<li><code>int[] pick()</code> Returns a random integer point <code>[u, v]</code> inside the space covered by one of the given rectangles.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/07/24/lc-pickrandomrec.jpg\" style=\"width: 419px; height: 539px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;Solution&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;]\n[[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]\n<strong>Output</strong>\n[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]\n\n<strong>Explanation</strong>\nSolution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);\nsolution.pick(); // return [1, -2]\nsolution.pick(); // return [1, -1]\nsolution.pick(); // return [-1, -2]\nsolution.pick(); // return [-2, -2]\nsolution.pick(); // return [0, 0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= rects.length &lt;= 100</code></li>\n\t<li><code>rects[i].length == 4</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= a<sub>i</sub> &lt; x<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= b<sub>i</sub> &lt; y<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>x<sub>i</sub> - a<sub>i</sub> &lt;= 2000</code></li>\n\t<li><code>y<sub>i</sub> - b<sub>i</sub> &lt;= 2000</code></li>\n\t<li>All the rectangles do not overlap.</li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>pick</code>.</li>\n</ul>\n"}}, "498": {"__typename": "QuestionLightNode", "acRate": 0.558778591650564, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "498", "isFavor": false, "solutionNum": 1214, "title": "Diagonal Traverse", "titleCn": "对角线遍历", "titleSlug": "diagonal-traverse", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 51, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个大小为 <code>m x n</code> 的矩阵 <code>mat</code> ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg\" style=\"width: 334px; height: 334px;\" />\n<pre>\n<strong>输入：</strong>mat = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>输出：</strong>[1,2,4,7,5,3,6,8,9]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[1,2],[3,4]]\n<strong>输出：</strong>[1,2,3,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>Given an <code>m x n</code> matrix <code>mat</code>, return <em>an array of all the elements of the array in a diagonal order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg\" style=\"width: 334px; height: 334px;\" />\n<pre>\n<strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [1,2,4,7,5,3,6,8,9]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> mat = [[1,2],[3,4]]\n<strong>Output:</strong> [1,2,3,4]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "499": {"__typename": "QuestionLightNode", "acRate": 0.44716442268461853, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "499", "isFavor": false, "solutionNum": 99, "title": "The Maze III", "titleCn": "迷宫 III", "titleSlug": "the-maze-iii", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}, {"id": "48rxpj", "name": "Shortest Path", "slug": "shortest-path", "nameTranslated": "最短路", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "500": {"__typename": "QuestionLightNode", "acRate": 0.7387794211120493, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "500", "isFavor": false, "solutionNum": 1107, "title": "Keyboard Row", "titleCn": "键盘行", "titleSlug": "keyboard-row", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/e180e3e5553f722e5895940d0617f54e988e54e1e530b27e88e76576aedc553d-qw90wxxo_400x400.jpg", "slug": "mathworks", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串数组 <code>words</code> ，只返回可以使用在 <strong>美式键盘</strong> 同一行的字母打印出来的单词。键盘如下图所示。</p>\n\n<p><strong>美式键盘</strong> 中：</p>\n\n<ul>\n\t<li>第一行由字符 <code>\"qwertyuiop\"</code> 组成。</li>\n\t<li>第二行由字符 <code>\"asdfghjkl\"</code> 组成。</li>\n\t<li>第三行由字符 <code>\"zxcvbnm\"</code> 组成。</li>\n</ul>\n\n<p><img alt=\"American keyboard\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/keyboard.png\" style=\"width: 100%; max-width: 600px\" /></p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"Hello\",\"Alaska\",\"Dad\",\"Peace\"]\n<strong>输出：</strong>[\"Alaska\",\"Dad\"]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"omk\"]\n<strong>输出：</strong>[]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"adsdf\",\"sfd\"]\n<strong>输出：</strong>[\"adsdf\",\"sfd\"]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= words.length <= 20</code></li>\n\t<li><code>1 <= words[i].length <= 100</code></li>\n\t<li><code>words[i]</code> 由英文字母（小写和大写字母）组成</li>\n</ul>\n", "en": "<p>Given an array of strings <code>words</code>, return <em>the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below</em>.</p>\n\n<p>In the <strong>American keyboard</strong>:</p>\n\n<ul>\n\t<li>the first row consists of the characters <code>&quot;qwertyuiop&quot;</code>,</li>\n\t<li>the second row consists of the characters <code>&quot;asdfghjkl&quot;</code>, and</li>\n\t<li>the third row consists of the characters <code>&quot;zxcvbnm&quot;</code>.</li>\n</ul>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/10/12/keyboard.png\" style=\"width: 800px; max-width: 600px; height: 267px;\" />\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;Hello&quot;,&quot;Alaska&quot;,&quot;Dad&quot;,&quot;Peace&quot;]\n<strong>Output:</strong> [&quot;Alaska&quot;,&quot;Dad&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;omk&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;adsdf&quot;,&quot;sfd&quot;]\n<strong>Output:</strong> [&quot;adsdf&quot;,&quot;sfd&quot;]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> consists of English letters (both lowercase and uppercase).&nbsp;</li>\n</ul>\n"}}, "501": {"__typename": "QuestionLightNode", "acRate": 0.5513940918479646, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "501", "isFavor": false, "solutionNum": 1251, "title": "Find Mode in Binary Search Tree", "titleCn": "二叉搜索树中的众数", "titleSlug": "find-mode-in-binary-search-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a href=\"https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796\" target=\"_blank\">众数</a>（即，出现频率最高的元素）。</p>\n\n<p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p>\n\n<p>假定 BST 满足如下定义：</p>\n\n<ul>\n\t<li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li>\n\t<li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li>\n\t<li>左子树和右子树都是二叉搜索树</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg\" style=\"width: 142px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>root = [1,null,2,2]\n<strong>输出：</strong>[2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [0]\n<strong>输出：</strong>[0]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目在范围 <code>[1, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>\n", "en": "<p>Given the <code>root</code> of a binary search tree (BST) with duplicates, return <em>all the <a href=\"https://en.wikipedia.org/wiki/Mode_(statistics)\" target=\"_blank\">mode(s)</a> (i.e., the most frequently occurred element) in it</em>.</p>\n\n<p>If the tree has more than one mode, return them in <strong>any order</strong>.</p>\n\n<p>Assume a BST is defined as follows:</p>\n\n<ul>\n\t<li>The left subtree of a node contains only nodes with keys <strong>less than or equal to</strong> the node&#39;s key.</li>\n\t<li>The right subtree of a node contains only nodes with keys <strong>greater than or equal to</strong> the node&#39;s key.</li>\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg\" style=\"width: 142px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,2]\n<strong>Output:</strong> [2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count)."}}, "502": {"__typename": "QuestionLightNode", "acRate": 0.45249364079896587, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "502", "isFavor": false, "solutionNum": 471, "title": "IPO", "titleCn": "IPO", "titleSlug": "ipo", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 24, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/78703b3d3d17ff1b249303bec7cd53d61ba4d1ff309f4293600ea7efe8b692ae-salesforce.png", "slug": "salesforce", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>假设 力扣（LeetCode）即将开始 <strong>IPO</strong> 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 <code>k</code> 个不同的项目。帮助 力扣 设计完成最多 <code>k</code> 个不同项目后得到最大总资本的方式。</p>\n\n<p>给你 <code>n</code> 个项目。对于每个项目 <code>i</code><strong> </strong>，它都有一个纯利润 <code>profits[i]</code> ，和启动该项目需要的最小资本 <code>capital[i]</code> 。</p>\n\n<p>最初，你的资本为 <code>w</code> 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。</p>\n\n<p>总而言之，从给定项目中选择 <strong>最多</strong> <code>k</code> 个不同项目的列表，以 <strong>最大化最终资本</strong> ，并输出最终可获得的最多资本。</p>\n\n<p>答案保证在 32 位有符号整数范围内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n<strong>输出：</strong>4\n<strong>解释：\n</strong>由于你的初始资本为 0，你仅可以从 0 号项目开始。\n在完成后，你将获得 1 的利润，你的总资本将变为 1。\n此时你可以选择开始 1 号或 2 号项目。\n由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。\n因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= w &lt;= 10<sup>9</sup></code></li>\n\t<li><code>n == profits.length</code></li>\n\t<li><code>n == capital.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= profits[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= capital[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Suppose LeetCode will start its <strong>IPO</strong> soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the <strong>IPO</strong>. Since it has limited resources, it can only finish at most <code>k</code> distinct projects before the <strong>IPO</strong>. Help LeetCode design the best way to maximize its total capital after finishing at most <code>k</code> distinct projects.</p>\n\n<p>You are given <code>n</code> projects where the <code>i<sup>th</sup></code> project has a pure profit <code>profits[i]</code> and a minimum capital of <code>capital[i]</code> is needed to start it.</p>\n\n<p>Initially, you have <code>w</code> capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.</p>\n\n<p>Pick a list of <strong>at most</strong> <code>k</code> distinct projects from given projects to <strong>maximize your final capital</strong>, and return <em>the final maximized capital</em>.</p>\n\n<p>The answer is guaranteed to fit in a 32-bit signed integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\n<strong>Output:</strong> 6\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= w &lt;= 10<sup>9</sup></code></li>\n\t<li><code>n == profits.length</code></li>\n\t<li><code>n == capital.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= profits[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= capital[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "503": {"__typename": "QuestionLightNode", "acRate": 0.6738136814012526, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "503", "isFavor": false, "solutionNum": 1767, "title": "Next Greater Element II", "titleCn": "下一个更大元素 II", "titleSlug": "next-greater-element-ii", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "xeyj5r5", "name": "Monotonic Stack", "slug": "monotonic-stack", "nameTranslated": "单调栈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 40, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个循环数组&nbsp;<code>nums</code>&nbsp;（&nbsp;<code>nums[nums.length - 1]</code>&nbsp;的下一个元素是&nbsp;<code>nums[0]</code>&nbsp;），返回&nbsp;<em><code>nums</code>&nbsp;中每个元素的 <strong>下一个更大元素</strong></em> 。</p>\n\n<p>数字 <code>x</code>&nbsp;的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,1]\n<strong>输出:</strong> [2,-1,2]\n<strong>解释:</strong> 第一个 1 的下一个更大的数是 2；\n数字 2 找不到下一个更大的数； \n第二个 1 的下一个最大的数需要循环搜索，结果也是 2。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4,3]\n<strong>输出:</strong> [2,3,4,-1,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Given a circular integer array <code>nums</code> (i.e., the next element of <code>nums[nums.length - 1]</code> is <code>nums[0]</code>), return <em>the <strong>next greater number</strong> for every element in</em> <code>nums</code>.</p>\n\n<p>The <strong>next greater number</strong> of a number <code>x</code> is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn&#39;t exist, return <code>-1</code> for this number.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1]\n<strong>Output:</strong> [2,-1,2]\nExplanation: The first 1&#39;s next greater number is 2; \nThe number 2 can&#39;t find next greater number. \nThe second 1&#39;s next greater number needs to search circularly, which is also 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,3]\n<strong>Output:</strong> [2,3,4,-1,4]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "504": {"__typename": "QuestionLightNode", "acRate": 0.518379750144315, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "504", "isFavor": false, "solutionNum": 878, "title": "Base 7", "titleCn": "七进制数", "titleSlug": "base-7", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 21, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/c67f3a54aea25e5d075cd936e6a70c46792ea7484ecfaadbd2a491a58c6bc433-1578032262805.jpg", "slug": "garena", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个整数 <code>num</code>，将其转化为 <strong>7 进制</strong>，并以字符串形式输出。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> num = 100\n<strong>输出:</strong> \"202\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> num = -7\n<strong>输出:</strong> \"-10\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>-10<sup>7</sup>&nbsp;&lt;= num &lt;= 10<sup>7</sup></code></li>\n</ul>\n", "en": "<p>Given an integer <code>num</code>, return <em>a string of its <strong>base 7</strong> representation</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> num = 100\n<strong>Output:</strong> \"202\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> num = -7\n<strong>Output:</strong> \"-10\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>7</sup> &lt;= num &lt;= 10<sup>7</sup></code></li>\n</ul>\n"}}, "505": {"__typename": "QuestionLightNode", "acRate": 0.5187269372693727, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "505", "isFavor": false, "solutionNum": 131, "title": "The Maze II", "titleCn": "迷宫 II", "titleSlug": "the-maze-ii", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}, {"id": "48rxpj", "name": "Shortest Path", "slug": "shortest-path", "nameTranslated": "最短路", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 27, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "506": {"__typename": "QuestionLightNode", "acRate": 0.6553417139466756, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "506", "isFavor": false, "solutionNum": 1053, "title": "Relative Ranks", "titleCn": "相对名次", "titleSlug": "relative-ranks", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个长度为 <code>n</code> 的整数数组 <code>score</code> ，其中 <code>score[i]</code> 是第 <code>i</code> 位运动员在比赛中的得分。所有得分都 <strong>互不相同</strong> 。</p>\n\n<p>运动员将根据得分 <strong>决定名次</strong> ，其中名次第 <code>1</code> 的运动员得分最高，名次第 <code>2</code> 的运动员得分第 <code>2</code> 高，依此类推。运动员的名次决定了他们的获奖情况：</p>\n\n<ul>\n\t<li>名次第 <code>1</code> 的运动员获金牌 <code>\"Gold Medal\"</code> 。</li>\n\t<li>名次第 <code>2</code> 的运动员获银牌 <code>\"Silver Medal\"</code> 。</li>\n\t<li>名次第 <code>3</code> 的运动员获铜牌 <code>\"Bronze Medal\"</code> 。</li>\n\t<li>从名次第 <code>4</code> 到第 <code>n</code> 的运动员，只能获得他们的名次编号（即，名次第 <code>x</code> 的运动员获得编号 <code>\"x\"</code>）。</li>\n</ul>\n\n<p>使用长度为 <code>n</code> 的数组 <code>answer</code> 返回获奖，其中 <code>answer[i]</code> 是第 <code>i</code> 位运动员的获奖情况。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>score = [5,4,3,2,1]\n<strong>输出：</strong>[\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\n<strong>解释：</strong>名次为 [1<sup>st</sup>, 2<sup>nd</sup>, 3<sup>rd</sup>, 4<sup>th</sup>, 5<sup>th</sup>] 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>score = [10,3,8,9,4]\n<strong>输出：</strong>[\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\n<strong>解释：</strong>名次为 [1<sup>st</sup>, 5<sup>th</sup>, 3<sup>rd</sup>, 2<sup>nd</sup>, 4<sup>th</sup>] 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == score.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= score[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>score</code> 中的所有值 <strong>互不相同</strong></li>\n</ul>\n", "en": "<p>You are given an integer array <code>score</code> of size <code>n</code>, where <code>score[i]</code> is the score of the <code>i<sup>th</sup></code> athlete in a competition. All the scores are guaranteed to be <strong>unique</strong>.</p>\n\n<p>The athletes are <strong>placed</strong> based on their scores, where the <code>1<sup>st</sup></code> place athlete has the highest score, the <code>2<sup>nd</sup></code> place athlete has the <code>2<sup>nd</sup></code> highest score, and so on. The placement of each athlete determines their rank:</p>\n\n<ul>\n\t<li>The <code>1<sup>st</sup></code> place athlete&#39;s rank is <code>&quot;Gold Medal&quot;</code>.</li>\n\t<li>The <code>2<sup>nd</sup></code> place athlete&#39;s rank is <code>&quot;Silver Medal&quot;</code>.</li>\n\t<li>The <code>3<sup>rd</sup></code> place athlete&#39;s rank is <code>&quot;Bronze Medal&quot;</code>.</li>\n\t<li>For the <code>4<sup>th</sup></code> place to the <code>n<sup>th</sup></code> place athlete, their rank is their placement number (i.e., the <code>x<sup>th</sup></code> place athlete&#39;s rank is <code>&quot;x&quot;</code>).</li>\n</ul>\n\n<p>Return an array <code>answer</code> of size <code>n</code> where <code>answer[i]</code> is the <strong>rank</strong> of the <code>i<sup>th</sup></code> athlete.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> score = [5,4,3,2,1]\n<strong>Output:</strong> [&quot;Gold Medal&quot;,&quot;Silver Medal&quot;,&quot;Bronze Medal&quot;,&quot;4&quot;,&quot;5&quot;]\n<strong>Explanation:</strong> The placements are [1<sup>st</sup>, 2<sup>nd</sup>, 3<sup>rd</sup>, 4<sup>th</sup>, 5<sup>th</sup>].</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> score = [10,3,8,9,4]\n<strong>Output:</strong> [&quot;Gold Medal&quot;,&quot;5&quot;,&quot;Bronze Medal&quot;,&quot;Silver Medal&quot;,&quot;4&quot;]\n<strong>Explanation:</strong> The placements are [1<sup>st</sup>, 5<sup>th</sup>, 3<sup>rd</sup>, 2<sup>nd</sup>, 4<sup>th</sup>].\n\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == score.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= score[i] &lt;= 10<sup>6</sup></code></li>\n\t<li>All the values in <code>score</code> are <strong>unique</strong>.</li>\n</ul>\n"}}, "507": {"__typename": "QuestionLightNode", "acRate": 0.49160917236838336, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "507", "isFavor": false, "solutionNum": 607, "title": "Perfect Number", "titleCn": "完美数", "titleSlug": "perfect-number", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 26, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>对于一个&nbsp;<strong>正整数</strong>，如果它和除了它自身以外的所有 <strong>正因子</strong> 之和相等，我们称它为 <strong>「完美数」</strong>。</p>\n\n<p>给定一个&nbsp;<strong>整数&nbsp;</strong><code>n</code>，&nbsp;如果是完美数，返回 <code>true</code>；否则返回 <code>false</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 28\n<strong>输出：</strong>true\n<strong>解释：</strong>28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, 和 14 是 28 的所有正因子。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num = 7\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>8</sup></code></li>\n</ul>\n", "en": "<p>A <a href=\"https://en.wikipedia.org/wiki/Perfect_number\" target=\"_blank\"><strong>perfect number</strong></a> is a <strong>positive integer</strong> that is equal to the sum of its <strong>positive divisors</strong>, excluding the number itself. A <strong>divisor</strong> of an integer <code>x</code> is an integer that can divide <code>x</code> evenly.</p>\n\n<p>Given an integer <code>n</code>, return <code>true</code><em> if </em><code>n</code><em> is a perfect number, otherwise return </em><code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 28\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, and 14 are all divisors of 28.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 7\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10<sup>8</sup></code></li>\n</ul>\n"}}, "508": {"__typename": "QuestionLightNode", "acRate": 0.7561703758102111, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "508", "isFavor": false, "solutionNum": 588, "title": "Most Frequent Subtree Sum", "titleCn": "出现次数最多的子树元素和", "titleSlug": "most-frequent-subtree-sum", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 14, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个二叉树的根结点&nbsp;<code>root</code>&nbsp;，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p>\n\n<p>一个结点的&nbsp;<strong>「子树元素和」</strong>&nbsp;定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/freq1-tree.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [5,2,-3]\n<strong>输出:</strong> [2,-3,4]\n</pre>\n\n<p><strong>示例&nbsp;2：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/freq2-tree.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [5,2,-5]\n<b>输出:</b> [2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>节点数在&nbsp;<code>[1, 10<sup>4</sup>]</code>&nbsp;范围内</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree, return the most frequent <strong>subtree sum</strong>. If there is a tie, return all the values with the highest frequency in any order.</p>\n\n<p>The <strong>subtree sum</strong> of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/freq1-tree.jpg\" style=\"width: 207px; height: 183px;\" />\n<pre>\n<strong>Input:</strong> root = [5,2,-3]\n<strong>Output:</strong> [2,-3,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/freq2-tree.jpg\" style=\"width: 207px; height: 183px;\" />\n<pre>\n<strong>Input:</strong> root = [5,2,-5]\n<strong>Output:</strong> [2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "509": {"__typename": "QuestionLightNode", "acRate": 0.6589509328247688, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "509", "isFavor": false, "solutionNum": 3562, "title": "Fibonacci Number", "titleCn": "斐波那契数", "titleSlug": "fibonacci-number", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "vhos7", "name": "Memoization", "slug": "memoization", "nameTranslated": "记忆化搜索", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 90, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1604559404-lBlorc-https---i.forbesimg.com-media-lists-companies-jpmorgan-chase_416x416.jpg", "slug": "jpmorgan", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><strong>斐波那契数</strong>&nbsp;（通常用&nbsp;<code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由&nbsp;<code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>\n\n<pre>\nF(0) = 0，F(1)&nbsp;= 1\nF(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1\n</pre>\n\n<p>给定&nbsp;<code>n</code> ，请计算 <code>F(n)</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>1\n<strong>解释：</strong>F(2) = F(1) + F(0) = 1 + 0 = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3\n<strong>输出：</strong>2\n<strong>解释：</strong>F(3) = F(2) + F(1) = 1 + 1 = 2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 4\n<strong>输出：</strong>3\n<strong>解释：</strong>F(4) = F(3) + F(2) = 2 + 1 = 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 30</code></li>\n</ul>\n", "en": "<p>The <b>Fibonacci numbers</b>, commonly denoted <code>F(n)</code> form a sequence, called the <b>Fibonacci sequence</b>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p>\n\n<pre>\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n &gt; 1.\n</pre>\n\n<p>Given <code>n</code>, calculate <code>F(n)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> F(2) = F(1) + F(0) = 1 + 0 = 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> F(3) = F(2) + F(1) = 1 + 1 = 2.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> F(4) = F(3) + F(2) = 2 + 1 = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 30</code></li>\n</ul>\n"}}, "510": {"__typename": "QuestionLightNode", "acRate": 0.6084136033025359, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "510", "isFavor": false, "solutionNum": 75, "title": "Inorder Successor in BST II", "titleCn": "二叉搜索树中的中序后继 II", "titleSlug": "inorder-successor-in-bst-ii", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "511": {"__typename": "QuestionLightNode", "acRate": 0.709025550747564, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "511", "isFavor": false, "solutionNum": 457, "title": "Game Play Analysis I", "titleCn": "游戏玩法分析 I", "titleSlug": "game-play-analysis-i", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>活动表&nbsp;<code>Activity</code>：</p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| player_id    | int     |\n| device_id    | int     |\n| event_date   | date    |\n| games_played | int     |\n+--------------+---------+\n在 SQL 中，表的主键是 (player_id, event_date)。\n这张表展示了一些游戏玩家在游戏平台上的行为活动。\n每行数据记录了一名玩家在退出平台之前，当天使用同一台设备登录平台后打开的游戏的数目（可能是 0 个）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>查询每位玩家 <strong>第一次登录平台的日期</strong>。</p>\n\n<p>查询结果的格式如下所示：</p>\n\n<pre>\nActivity 表：\n+-----------+-----------+------------+--------------+\n| player_id | device_id | event_date | games_played |\n+-----------+-----------+------------+--------------+\n| 1         | 2         | 2016-03-01 | 5            |\n| 1         | 2         | 2016-05-02 | 6            |\n| 2         | 3         | 2017-06-25 | 1            |\n| 3         | 1         | 2016-03-02 | 0            |\n| 3         | 4         | 2018-07-03 | 5            |\n+-----------+-----------+------------+--------------+\n\nResult 表：\n+-----------+-------------+\n| player_id | first_login |\n+-----------+-------------+\n| 1         | 2016-03-01  |\n| 2         | 2017-06-25  |\n| 3         | 2016-03-02  |\n+-----------+-------------+\n</pre>\n", "en": "<p>Table: <code>Activity</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| player_id    | int     |\n| device_id    | int     |\n| event_date   | date    |\n| games_played | int     |\n+--------------+---------+\n(player_id, event_date) is the primary key (combination of columns with unique values) of this table.\nThis table shows the activity of players of some games.\nEach row is a record of a player who logged in and played a number of games (possibly 0) before logging out on someday using some device.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the <strong>first login date</strong> for each player.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nActivity table:\n+-----------+-----------+------------+--------------+\n| player_id | device_id | event_date | games_played |\n+-----------+-----------+------------+--------------+\n| 1         | 2         | 2016-03-01 | 5            |\n| 1         | 2         | 2016-05-02 | 6            |\n| 2         | 3         | 2017-06-25 | 1            |\n| 3         | 1         | 2016-03-02 | 0            |\n| 3         | 4         | 2018-07-03 | 5            |\n+-----------+-----------+------------+--------------+\n<strong>Output:</strong> \n+-----------+-------------+\n| player_id | first_login |\n+-----------+-------------+\n| 1         | 2016-03-01  |\n| 2         | 2017-06-25  |\n| 3         | 2016-03-02  |\n+-----------+-------------+\n</pre>\n"}}, "512": {"__typename": "QuestionLightNode", "acRate": 0.5420874964413053, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "512", "isFavor": false, "solutionNum": 250, "title": "Game Play Analysis II", "titleCn": "游戏玩法分析 II", "titleSlug": "game-play-analysis-ii", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 5, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1710493903-uuJcFg-Wayfair.png", "slug": "wayfair", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "513": {"__typename": "QuestionLightNode", "acRate": 0.7319147132124266, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "513", "isFavor": false, "solutionNum": 1723, "title": "Find Bottom Left Tree Value", "titleCn": "找树左下角的值", "titleSlug": "find-bottom-left-tree-value", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 24, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边 </strong>节点的值。</p>\n\n<p>假设二叉树中至少有一个节点。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg\" style=\"width: 182px; \" /></p>\n\n<pre>\n<strong>输入: </strong>root = [2,1,3]\n<strong>输出: </strong>1\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg\" style=\"width: 242px; \" /><strong> </strong></p>\n\n<pre>\n<strong>输入: </strong>[1,2,3,4,null,5,6,null,null,7]\n<strong>输出: </strong>7\n</pre>\n\n<p> </p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[1,10<sup>4</sup>]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-2<sup>31</sup> <= Node.val <= 2<sup>31</sup> - 1</code> </li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree, return the leftmost value in the last row of the tree.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg\" style=\"width: 302px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg\" style=\"width: 432px; height: 421px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,null,5,6,null,null,7]\n<strong>Output:</strong> 7\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "514": {"__typename": "QuestionLightNode", "acRate": 0.5426261276311394, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "514", "isFavor": false, "solutionNum": 443, "title": "Freedom Trail", "titleCn": "自由之路", "titleSlug": "freedom-trail", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 10, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/d2e85988beccb271af4b1a8f4767e4bdf4c085aaf5aaef093347d778e4e138d7-20.png", "slug": "huawei", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>电子游戏“辐射4”中，任务 <strong>“通向自由”</strong> 要求玩家到达名为 “<strong>Freedom Trail Ring”</strong> 的金属表盘，并使用表盘拼写特定关键词才能开门。</p>\n\n<p>给定一个字符串&nbsp;<code>ring</code>&nbsp;，表示刻在外环上的编码；给定另一个字符串&nbsp;<code>key</code>&nbsp;，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的<strong>最少</strong>步数。</p>\n\n<p>最初，<strong>ring&nbsp;</strong>的第一个字符与 <code>12:00</code> 方向对齐。您需要顺时针或逆时针旋转 <code>ring</code> 以使&nbsp;<strong>key&nbsp;</strong>的一个字符在 <code>12:00</code> 方向对齐，然后按下中心按钮，以此逐个拼写完&nbsp;<strong><code>key</code>&nbsp;</strong>中的所有字符。</p>\n\n<p>旋转&nbsp;<code>ring</code><strong>&nbsp;</strong>拼出 key 字符&nbsp;<code>key[i]</code><strong>&nbsp;</strong>的阶段中：</p>\n\n<ol>\n\t<li>您可以将&nbsp;<strong>ring&nbsp;</strong>顺时针或逆时针旋转&nbsp;<strong>一个位置&nbsp;</strong>，计为1步。旋转的最终目的是将字符串&nbsp;<strong><code>ring</code>&nbsp;</strong>的一个字符与 <code>12:00</code> 方向对齐，并且这个字符必须等于字符&nbsp;<strong><code>key[i]</code> 。</strong></li>\n\t<li>如果字符&nbsp;<strong><code>key[i]</code>&nbsp;</strong>已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作&nbsp;<strong>1 步</strong>。按完之后，您可以开始拼写&nbsp;<strong>key&nbsp;</strong>的下一个字符（下一阶段）, 直至完成所有拼写。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/22/ring.jpg\" style=\"height: 450px; width: 450px;\" /></p>\n\n<center>&nbsp;</center>\n\n<pre>\n<strong>输入:</strong> ring = \"godding\", key = \"gd\"\n<strong>输出:</strong> 4\n<strong>解释:</strong>\n 对于 key 的第一个字符 'g'，已经在正确的位置, 我们只需要1步来拼写这个字符。 \n 对于 key 的第二个字符 'd'，我们需要逆时针旋转 ring \"godding\" 2步使它变成 \"ddinggo\"。\n 当然, 我们还需要1步进行拼写。\n 因此最终的输出是 4。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> ring = \"godding\", key = \"godding\"\n<strong>输出:</strong> 13\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ring.length, key.length &lt;= 100</code></li>\n\t<li><code>ring</code>&nbsp;和&nbsp;<code>key</code>&nbsp;只包含小写英文字母</li>\n\t<li><strong>保证</strong> 字符串&nbsp;<code>key</code>&nbsp;一定可以由字符串 &nbsp;<code>ring</code>&nbsp;旋转拼出</li>\n</ul>\n", "en": "<p>In the video game Fallout 4, the quest <strong>&quot;Road to Freedom&quot;</strong> requires players to reach a metal dial called the <strong>&quot;Freedom Trail Ring&quot;</strong> and use the dial to spell a specific keyword to open the door.</p>\n\n<p>Given a string <code>ring</code> that represents the code engraved on the outer ring and another string <code>key</code> that represents the keyword that needs to be spelled, return <em>the minimum number of steps to spell all the characters in the keyword</em>.</p>\n\n<p>Initially, the first character of the ring is aligned at the <code>&quot;12:00&quot;</code> direction. You should spell all the characters in <code>key</code> one by one by rotating <code>ring</code> clockwise or anticlockwise to make each character of the string key aligned at the <code>&quot;12:00&quot;</code> direction and then by pressing the center button.</p>\n\n<p>At the stage of rotating the ring to spell the key character <code>key[i]</code>:</p>\n\n<ol>\n\t<li>You can rotate the ring clockwise or anticlockwise by one place, which counts as <strong>one step</strong>. The final purpose of the rotation is to align one of <code>ring</code>&#39;s characters at the <code>&quot;12:00&quot;</code> direction, where this character must equal <code>key[i]</code>.</li>\n\t<li>If the character <code>key[i]</code> has been aligned at the <code>&quot;12:00&quot;</code> direction, press the center button to spell, which also counts as <strong>one step</strong>. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/22/ring.jpg\" style=\"width: 450px; height: 450px;\" />\n<pre>\n<strong>Input:</strong> ring = &quot;godding&quot;, key = &quot;gd&quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong>\nFor the first key character &#39;g&#39;, since it is already in place, we just need 1 step to spell this character. \nFor the second key character &#39;d&#39;, we need to rotate the ring &quot;godding&quot; anticlockwise by two steps to make it become &quot;ddinggo&quot;.\nAlso, we need 1 more step for spelling.\nSo the final output is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> ring = &quot;godding&quot;, key = &quot;godding&quot;\n<strong>Output:</strong> 13\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= ring.length, key.length &lt;= 100</code></li>\n\t<li><code>ring</code> and <code>key</code> consist of only lower case English letters.</li>\n\t<li>It is guaranteed that <code>key</code> could always be spelled by rotating <code>ring</code>.</li>\n</ul>\n"}}, "515": {"__typename": "QuestionLightNode", "acRate": 0.6642612600595794, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "515", "isFavor": false, "solutionNum": 1214, "title": "Find Largest Value in Each Tree Row", "titleCn": "在每个树行中找最大值", "titleSlug": "find-largest-value-in-each-tree-row", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 31, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一棵二叉树的根节点&nbsp;<code>root</code> ，请找出该二叉树中每一层的最大值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg\" style=\"height: 172px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入: </strong>root = [1,3,2,5,3,null,9]\n<strong>输出: </strong>[1,3,9]\n</pre>\n\n<p><strong>示例2：</strong></p>\n\n<pre>\n<strong>输入: </strong>root = [1,2,3]\n<strong>输出: </strong>[1,3]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是 <code>[0,10<sup>4</sup>]</code></li>\n\t<li><meta charset=\"UTF-8\" /><code>-2<sup>31</sup>&nbsp;&lt;= Node.val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n", "en": "<p>Given the <code>root</code> of a binary tree, return <em>an array of the largest value in each row</em> of the tree <strong>(0-indexed)</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg\" style=\"width: 300px; height: 172px;\" />\n<pre>\n<strong>Input:</strong> root = [1,3,2,5,3,null,9]\n<strong>Output:</strong> [1,3,9]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,2,3]\n<strong>Output:</strong> [1,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree will be in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "516": {"__typename": "QuestionLightNode", "acRate": 0.6708639414879557, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "516", "isFavor": false, "solutionNum": 1262, "title": "Longest Palindromic Subsequence", "titleCn": "最长回文子序列", "titleSlug": "longest-palindromic-subsequence", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 65, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p>\n\n<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"bbbab\"\n<strong>输出：</strong>4\n<strong>解释：</strong>一个可能的最长回文子序列为 \"bbbb\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"cbbd\"\n<strong>输出：</strong>2\n<strong>解释：</strong>一个可能的最长回文子序列为 \"bb\" 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 1000</code></li>\n\t<li><code>s</code> 仅由小写英文字母组成</li>\n</ul>\n", "en": "<p>Given a string <code>s</code>, find <em>the longest palindromic <strong>subsequence</strong>&#39;s length in</em> <code>s</code>.</p>\n\n<p>A <strong>subsequence</strong> is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bbbab&quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> One possible longest palindromic subsequence is &quot;bbbb&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cbbd&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> One possible longest palindromic subsequence is &quot;bb&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consists only of lowercase English letters.</li>\n</ul>\n"}}, "517": {"__typename": "QuestionLightNode", "acRate": 0.5120986365188056, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "517", "isFavor": false, "solutionNum": 219, "title": "Super Washing Machines", "titleCn": "超级洗衣机", "titleSlug": "super-washing-machines", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 12, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>假设有 <code>n</code><strong>&nbsp;</strong>台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。</p>\n\n<p>在每一步操作中，你可以选择任意 <code>m</code> (<code>1 &lt;= m &lt;= n</code>) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。</p>\n\n<p>给定一个整数数组&nbsp;<code>machines</code> 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 <strong>最少的操作步数 </strong>。如果不能使每台洗衣机中衣物的数量相等，则返回 <code>-1</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>machines = [1,0,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n第一步:    1     0 &lt;-- 5    =&gt;    1     1     4\n第二步:    1 &lt;-- 1 &lt;-- 4    =&gt;    2     1     3    \n第三步:    2     1 &lt;-- 3    =&gt;    2     2     2   \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>machines = [0,3,0]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n第一步:    0 &lt;-- 3     0    =&gt;    1     2     0    \n第二步:    1     2 --&gt; 0    =&gt;    1     1     1     \n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>machines = [0,2,0]\n<strong>输出：</strong>-1\n<strong>解释：</strong>\n不可能让所有三个洗衣机同时剩下相同数量的衣物。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == machines.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= machines[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>You have <code>n</code> super washing machines on a line. Initially, each washing machine has some dresses or is empty.</p>\n\n<p>For each move, you could choose any <code>m</code> (<code>1 &lt;= m &lt;= n</code>) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.</p>\n\n<p>Given an integer array <code>machines</code> representing the number of dresses in each washing machine from left to right on the line, return <em>the minimum number of moves to make all the washing machines have the same number of dresses</em>. If it is not possible to do it, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> machines = [1,0,5]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\n1st move:    1     0 &lt;-- 5    =&gt;    1     1     4\n2nd move:    1 &lt;-- 1 &lt;-- 4    =&gt;    2     1     3\n3rd move:    2     1 &lt;-- 3    =&gt;    2     2     2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> machines = [0,3,0]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\n1st move:    0 &lt;-- 3     0    =&gt;    1     2     0\n2nd move:    1     2 --&gt; 0    =&gt;    1     1     1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> machines = [0,2,0]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong>\nIt&#39;s impossible to make all three washing machines have the same number of dresses.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == machines.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= machines[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "518": {"__typename": "QuestionLightNode", "acRate": 0.7127901734656034, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "518", "isFavor": false, "solutionNum": 1512, "title": "Coin Change II", "titleCn": "零钱兑换 II", "titleSlug": "coin-change-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 72, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>\n\n<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>\n\n<p>假设每一种面额的硬币有无限个。 </p>\n\n<p>题目数据保证结果符合 32 位带符号整数。</p>\n\n<p> </p>\n\n<ul>\n</ul>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>amount = 5, coins = [1, 2, 5]\n<strong>输出：</strong>4\n<strong>解释：</strong>有四种方式可以凑成总金额：\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>amount = 3, coins = [2]\n<strong>输出：</strong>0\n<strong>解释：</strong>只用面额 2 的硬币不能凑成总金额 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>amount = 10, coins = [10] \n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= coins.length <= 300</code></li>\n\t<li><code>1 <= coins[i] <= 5000</code></li>\n\t<li><code>coins</code> 中的所有值 <strong>互不相同</strong></li>\n\t<li><code>0 <= amount <= 5000</code></li>\n</ul>\n", "en": "<p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p>\n\n<p>Return <em>the number of combinations that make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>0</code>.</p>\n\n<p>You may assume that you have an infinite number of each kind of coin.</p>\n\n<p>The answer is <strong>guaranteed</strong> to fit into a signed <strong>32-bit</strong> integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> amount = 5, coins = [1,2,5]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> amount = 3, coins = [2]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> the amount of 3 cannot be made up just with coins of 2.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> amount = 10, coins = [10]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= coins.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= coins[i] &lt;= 5000</code></li>\n\t<li>All the values of <code>coins</code> are <strong>unique</strong>.</li>\n\t<li><code>0 &lt;= amount &lt;= 5000</code></li>\n</ul>\n"}}, "519": {"__typename": "QuestionLightNode", "acRate": 0.46179188429087986, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "519", "isFavor": false, "solutionNum": 218, "title": "Random Flip Matrix", "titleCn": "随机翻转矩阵", "titleSlug": "random-flip-matrix", "topicTags": [{"id": "veg8i", "name": "Reservoir Sampling", "slug": "reservoir-sampling", "nameTranslated": "水塘抽样", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "xp2m6at", "name": "Randomized", "slug": "randomized", "nameTranslated": "随机化", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 11, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个 <code>m x n</code> 的二元矩阵 <code>matrix</code> ，且所有值被初始化为 <code>0</code> 。请你设计一个算法，随机选取一个满足&nbsp;<code>matrix[i][j] == 0</code> 的下标&nbsp;<code>(i, j)</code> ，并将它的值变为 <code>1</code> 。所有满足 <code>matrix[i][j] == 0</code> 的下标 <code>(i, j)</code> 被选取的概率应当均等。</p>\n\n<p>尽量最少调用内置的随机函数，并且优化时间和空间复杂度。</p>\n\n<p>实现 <code>Solution</code> 类：</p>\n\n<ul>\n\t<li><code>Solution(int m, int n)</code> 使用二元矩阵的大小 <code>m</code> 和 <code>n</code> 初始化该对象</li>\n\t<li><code>int[] flip()</code> 返回一个满足&nbsp;<code>matrix[i][j] == 0</code> 的随机下标 <code>[i, j]</code> ，并将其对应格子中的值变为 <code>1</code></li>\n\t<li><code>void reset()</code> 将矩阵中所有的值重置为 <code>0</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"]\n[[3, 1], [], [], [], [], []]\n<strong>输出</strong>\n[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]\n\n<strong>解释</strong>\nSolution solution = new Solution(3, 1);\nsolution.flip();  // 返回 [1, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同\nsolution.flip();  // 返回 [2, 0]，因为 [1,0] 已经返回过了，此时返回 [2,0] 和 [0,0] 的概率应当相同\nsolution.flip();  // 返回 [0, 0]，根据前面已经返回过的下标，此时只能返回 [0,0]\nsolution.reset(); // 所有值都重置为 0 ，并可以再次选择下标返回\nsolution.flip();  // 返回 [2, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>\n\t<li>每次调用<code>flip</code> 时，矩阵中至少存在一个值为 0 的格子。</li>\n\t<li>最多调用 <code>1000</code> 次 <code>flip</code> 和 <code>reset</code> 方法。</li>\n</ul>\n", "en": "<p>There is an <code>m x n</code> binary grid <code>matrix</code> with all the values set <code>0</code> initially. Design an algorithm to randomly pick an index <code>(i, j)</code> where <code>matrix[i][j] == 0</code> and flips it to <code>1</code>. All the indices <code>(i, j)</code> where <code>matrix[i][j] == 0</code> should be equally likely to be returned.</p>\n\n<p>Optimize your algorithm to minimize the number of calls made to the <strong>built-in</strong> random function of your language and optimize the time and space complexity.</p>\n\n<p>Implement the <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution(int m, int n)</code> Initializes the object with the size of the binary matrix <code>m</code> and <code>n</code>.</li>\n\t<li><code>int[] flip()</code> Returns a random index <code>[i, j]</code> of the matrix where <code>matrix[i][j] == 0</code> and flips it to <code>1</code>.</li>\n\t<li><code>void reset()</code> Resets all the values of the matrix to be <code>0</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Solution&quot;, &quot;flip&quot;, &quot;flip&quot;, &quot;flip&quot;, &quot;reset&quot;, &quot;flip&quot;]\n[[3, 1], [], [], [], [], []]\n<strong>Output</strong>\n[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]\n\n<strong>Explanation</strong>\nSolution solution = new Solution(3, 1);\nsolution.flip();  // return [1, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.\nsolution.flip();  // return [2, 0], Since [1,0] was returned, [2,0] and [0,0]\nsolution.flip();  // return [0, 0], Based on the previously returned indices, only [0,0] can be returned.\nsolution.reset(); // All the values are reset to 0 and can be returned.\nsolution.flip();  // return [2, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>\n\t<li>There will be at least one free cell for each call to <code>flip</code>.</li>\n\t<li>At most <code>1000</code> calls will be made to <code>flip</code> and <code>reset</code>.</li>\n</ul>\n"}}, "520": {"__typename": "QuestionLightNode", "acRate": 0.5641657077100115, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "520", "isFavor": false, "solutionNum": 1431, "title": "Detect Capital", "titleCn": "检测大写字母", "titleSlug": "detect-capital", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 14, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>我们定义，在以下情况时，单词的大写用法是正确的：</p>\n\n<ul>\n\t<li>全部字母都是大写，比如 <code>\"USA\"</code> 。</li>\n\t<li>单词中所有字母都不是大写，比如 <code>\"leetcode\"</code> 。</li>\n\t<li>如果单词不只含有一个字母，只有首字母大写，&nbsp;比如&nbsp;<code>\"Google\"</code> 。</li>\n</ul>\n\n<p>给你一个字符串 <code>word</code> 。如果大写用法正确，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"USA\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>word = \"FlaG\"\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>word</code> 由小写和大写英文字母组成</li>\n</ul>\n", "en": "<p>We define the usage of capitals in a word to be right when one of the following cases holds:</p>\n\n<ul>\n\t<li>All letters in this word are capitals, like <code>&quot;USA&quot;</code>.</li>\n\t<li>All letters in this word are not capitals, like <code>&quot;leetcode&quot;</code>.</li>\n\t<li>Only the first letter in this word is capital, like <code>&quot;Google&quot;</code>.</li>\n</ul>\n\n<p>Given a string <code>word</code>, return <code>true</code> if the usage of capitals in it is right.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> word = \"USA\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> word = \"FlaG\"\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>word</code> consists of lowercase and uppercase English letters.</li>\n</ul>\n"}}, "521": {"__typename": "QuestionLightNode", "acRate": 0.7367284816821744, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "521", "isFavor": false, "solutionNum": 590, "title": "Longest Uncommon Subsequence I", "titleCn": "最长特殊序列 Ⅰ", "titleSlug": "longest-uncommon-subsequence-i", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 13, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个字符串&nbsp;<code>a</code>&nbsp;和&nbsp;<code>b</code>，请返回 <em>这两个字符串中 <strong>最长的特殊序列</strong>&nbsp;</em> 的长度。如果不存在，则返回 <code>-1</code>&nbsp;。</p>\n\n<p><strong>「最长特殊序列」</strong>&nbsp;定义如下：该序列为&nbsp;<strong>某字符串独有的最长<span data-keyword=\"subsequence-array\">子序列</span>（即不能是其他字符串的子序列）</strong>&nbsp;。</p>\n\n<p>字符串&nbsp;<code>s</code>&nbsp;的子序列是在从&nbsp;<code>s</code>&nbsp;中删除任意数量的字符后可以获得的字符串。</p>\n\n<ul>\n\t<li>例如，<code>\"abc\"</code> 是 <code>\"aebdc\"</code> 的子序列，因为删除 <code>\"a<em><strong>e</strong></em>b<strong><em>d</em></strong>c\"</code> 中斜体加粗的字符可以得到 <code>\"abc\"</code> 。 <code>\"aebdc\"</code> 的子序列还包括 <code>\"aebdc\"</code> 、 <code>\"aeb\"</code> 和 <code>\"\"</code> (空字符串)。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> a = \"aba\", b = \"cdc\"\n<strong>输出:</strong> 3\n<strong>解释:</strong> 最长特殊序列可为 \"aba\" (或 \"cdc\")，两者均为自身的子序列且不是对方的子序列。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = \"aaa\", b = \"bbb\"\n<strong>输出：</strong>3\n<strong>解释:</strong> 最长特殊序列是 \"aaa\" 和 \"bbb\" 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>a = \"aaa\", b = \"aaa\"\n<strong>输出：</strong>-1\n<strong>解释:</strong> 字符串 a 的每个子序列也是字符串 b 的每个子序列。同样，字符串 b 的每个子序列也是字符串 a 的子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 100</code></li>\n\t<li><code>a</code>&nbsp;和&nbsp;<code>b</code>&nbsp;由小写英文字母组成</li>\n</ul>\n", "en": "<p>Given two strings <code>a</code> and <code>b</code>, return <em>the length of the <strong>longest uncommon subsequence</strong> between </em><code>a</code> <em>and</em> <code>b</code>. <em>If no such uncommon subsequence exists, return</em> <code>-1</code><em>.</em></p>\n\n<p>An <strong>uncommon subsequence</strong> between two strings is a string that is a <strong><span data-keyword=\"subsequence-string\">subsequence</span> of exactly one of them</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = &quot;aba&quot;, b = &quot;cdc&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> One longest uncommon subsequence is &quot;aba&quot; because &quot;aba&quot; is a subsequence of &quot;aba&quot; but not &quot;cdc&quot;.\nNote that &quot;cdc&quot; is also a longest uncommon subsequence.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = &quot;aaa&quot;, b = &quot;bbb&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>&nbsp;The longest uncommon subsequences are &quot;aaa&quot; and &quot;bbb&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = &quot;aaa&quot;, b = &quot;aaa&quot;\n<strong>Output:</strong> -1\n<strong>Explanation:</strong>&nbsp;Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a. So the answer would be <code>-1</code>.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 100</code></li>\n\t<li><code>a</code> and <code>b</code> consist of lower-case English letters.</li>\n</ul>\n"}}, "522": {"__typename": "QuestionLightNode", "acRate": 0.4883824267182685, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "522", "isFavor": false, "solutionNum": 369, "title": "Longest Uncommon Subsequence II", "titleCn": "最长特殊序列 II", "titleSlug": "longest-uncommon-subsequence-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/c0becdcc322c6ffa7de04f9429fea3cbaa045735fa1771c637d79828358dc8ef-41MVF9VYURL.png", "slug": "yahoo", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定字符串列表&nbsp;<code>strs</code> ，返回其中 <strong>最长的特殊序列</strong>&nbsp;的长度。如果最长特殊序列不存在，返回 <code>-1</code> 。</p>\n\n<p><strong>特殊序列</strong> 定义如下：该序列为某字符串 <strong>独有的子序列（即不能是其他字符串的子序列）</strong>。</p>\n\n<p>&nbsp;<code>s</code>&nbsp;的&nbsp;<strong>子序列</strong>可以通过删去字符串&nbsp;<code>s</code>&nbsp;中的某些字符实现。</p>\n\n<ul>\n\t<li>例如，<code>\"abc\"</code>&nbsp;是 <code>\"aebdc\"</code>&nbsp;的子序列，因为您可以删除<code>\"a<u>e</u>b<u>d</u>c\"</code>中的下划线字符来得到 <code>\"abc\"</code>&nbsp;。<code>\"aebdc\"</code>的子序列还包括<code>\"aebdc\"</code>、 <code>\"aeb\"</code>&nbsp;和 <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size: 12.6px; background-color: rgb(249, 242, 244);\">\"\"</span></font>&nbsp;(空字符串)。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = [\"aba\",\"cdc\",\"eae\"]\n<strong>输出:</strong> 3\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> strs = [\"aaa\",\"aaa\",\"aa\"]\n<strong>输出:</strong> -1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= strs.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 10</code></li>\n\t<li><code>strs[i]</code>&nbsp;只包含小写英文字母</li>\n</ul>\n", "en": "<p>Given an array of strings <code>strs</code>, return <em>the length of the <strong>longest uncommon subsequence</strong> between them</em>. If the longest uncommon subsequence does not exist, return <code>-1</code>.</p>\n\n<p>An <strong>uncommon subsequence</strong> between an array of strings is a string that is a <strong>subsequence of one string but not the others</strong>.</p>\n\n<p>A <strong>subsequence</strong> of a string <code>s</code> is a string that can be obtained after deleting any number of characters from <code>s</code>.</p>\n\n<ul>\n\t<li>For example, <code>&quot;abc&quot;</code> is a subsequence of <code>&quot;aebdc&quot;</code> because you can delete the underlined characters in <code>&quot;a<u>e</u>b<u>d</u>c&quot;</code> to get <code>&quot;abc&quot;</code>. Other subsequences of <code>&quot;aebdc&quot;</code> include <code>&quot;aebdc&quot;</code>, <code>&quot;aeb&quot;</code>, and <code>&quot;&quot;</code> (empty string).</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> strs = [\"aba\",\"cdc\",\"eae\"]\n<strong>Output:</strong> 3\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> strs = [\"aaa\",\"aaa\",\"aa\"]\n<strong>Output:</strong> -1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= strs.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= strs[i].length &lt;= 10</code></li>\n\t<li><code>strs[i]</code> consists of lowercase English letters.</li>\n</ul>\n"}}, "523": {"__typename": "QuestionLightNode", "acRate": 0.28760493800292714, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "523", "isFavor": false, "solutionNum": 822, "title": "Continuous Subarray Sum", "titleCn": "连续的子数组和", "titleSlug": "continuous-subarray-sum", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 43, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p>\n\n<ul>\n\t<li>子数组大小 <strong>至少为 2</strong> ，且</li>\n\t<li>子数组元素总和为 <code>k</code> 的倍数。</li>\n</ul>\n\n<p>如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>如果存在一个整数 <code>n</code> ，令整数 <code>x</code> 符合 <code>x = n * k</code> ，则称 <code>x</code> 是 <code>k</code> 的一个倍数。<code>0</code> 始终视为 <code>k</code> 的一个倍数。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [23<u>,2,4</u>,6,7], k = 6\n<strong>输出：</strong>true\n<strong>解释：</strong>[2,4] 是一个大小为 2 的子数组，并且和为 6 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [<u>23,2,6,4,7</u>], k = 6\n<strong>输出：</strong>true\n<strong>解释：</strong>[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 \n42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [23,2,6,4,7], k = 13\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>0 <= nums[i] <= 10<sup>9</sup></code></li>\n\t<li><code>0 <= sum(nums[i]) <= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 <= k <= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given an integer array nums and an integer k, return <code>true</code> <em>if </em><code>nums</code><em> has a <strong>good subarray</strong> or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>A <strong>good subarray</strong> is a subarray where:</p>\n\n<ul>\n\t<li>its length is <strong>at least two</strong>, and</li>\n\t<li>the sum of the elements of the subarray is a multiple of <code>k</code>.</li>\n</ul>\n\n<p><strong>Note</strong> that:</p>\n\n<ul>\n\t<li>A <strong>subarray</strong> is a contiguous part of the array.</li>\n\t<li>An integer <code>x</code> is a multiple of <code>k</code> if there exists an integer <code>n</code> such that <code>x = n * k</code>. <code>0</code> is <strong>always</strong> a multiple of <code>k</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [23,<u>2,4</u>,6,7], k = 6\n<strong>Output:</strong> true\n<strong>Explanation:</strong> [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [<u>23,2,6,4,7</u>], k = 6\n<strong>Output:</strong> true\n<strong>Explanation:</strong> [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.\n42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [23,2,6,4,7], k = 13\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= sum(nums[i]) &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>1 &lt;= k &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "524": {"__typename": "QuestionLightNode", "acRate": 0.5023159728012154, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "524", "isFavor": false, "solutionNum": 1020, "title": "Longest Word in Dictionary through Deleting", "titleCn": "通过删除字母匹配到字典里最长单词", "titleSlug": "longest-word-in-dictionary-through-deleting", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 21, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code> 和一个字符串数组 <code>dictionary</code> ，找出并返回&nbsp;<code>dictionary</code> 中最长的字符串，该字符串可以通过删除 <code>s</code> 中的某些字符得到。</p>\n\n<p>如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abpcplea\", dictionary = [\"ale\",\"apple\",\"monkey\",\"plea\"]\n<strong>输出：</strong>\"apple\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abpcplea\", dictionary = [\"a\",\"b\",\"c\"]\n<strong>输出：</strong>\"a\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= dictionary.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 1000</code></li>\n\t<li><code>s</code> 和 <code>dictionary[i]</code> 仅由小写英文字母组成</li>\n</ul>\n", "en": "<p>Given a string <code>s</code> and a string array <code>dictionary</code>, return <em>the longest string in the dictionary that can be formed by deleting some of the given string characters</em>. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abpcplea&quot;, dictionary = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]\n<strong>Output:</strong> &quot;apple&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abpcplea&quot;, dictionary = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]\n<strong>Output:</strong> &quot;a&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= dictionary.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 1000</code></li>\n\t<li><code>s</code> and <code>dictionary[i]</code> consist of lowercase English letters.</li>\n</ul>\n"}}, "525": {"__typename": "QuestionLightNode", "acRate": 0.5454313425216948, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "525", "isFavor": false, "solutionNum": 749, "title": "Contiguous Array", "titleCn": "连续数组", "titleSlug": "contiguous-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 38, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>\n\n<p> </p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1]\n<strong>输出:</strong> 2\n<strong>说明:</strong> [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [0,1,0]\n<strong>输出:</strong> 2\n<strong>说明:</strong> [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></li>\n</ul>\n", "en": "<p>Given a binary array <code>nums</code>, return <em>the maximum length of a contiguous subarray with an equal number of </em><code>0</code><em> and </em><code>1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,0]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> is either <code>0</code> or <code>1</code>.</li>\n</ul>\n"}}, "526": {"__typename": "QuestionLightNode", "acRate": 0.7245807669518967, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "526", "isFavor": false, "solutionNum": 546, "title": "Beautiful Arrangement", "titleCn": "优美的排列", "titleSlug": "beautiful-arrangement", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "eeprrj", "name": "Bitmask", "slug": "bitmask", "nameTranslated": "状态压缩", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 28, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/e180e3e5553f722e5895940d0617f54e988e54e1e530b27e88e76576aedc553d-qw90wxxo_400x400.jpg", "slug": "mathworks", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/78703b3d3d17ff1b249303bec7cd53d61ba4d1ff309f4293600ea7efe8b692ae-salesforce.png", "slug": "salesforce", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 <code>perm</code>（<strong>下标从 1 开始</strong>），只要满足下述条件 <strong>之一</strong> ，该数组就是一个 <strong>优美的排列</strong> ：</p>\n\n<ul>\n\t<li><code>perm[i]</code> 能够被 <code>i</code> 整除</li>\n\t<li><code>i</code> 能够被 <code>perm[i]</code> 整除</li>\n</ul>\n\n<p>给你一个整数 <code>n</code> ，返回可以构造的 <strong>优美排列 </strong>的 <strong>数量</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>2\n<b>解释：</b>\n第 1 个优美的排列是 [1,2]：\n    - perm[1] = 1 能被 i = 1 整除\n    - perm[2] = 2 能被 i = 2 整除\n第 2 个优美的排列是 [2,1]:\n    - perm[1] = 2 能被 i = 1 整除\n    - i = 2 能被 perm[2] = 1 整除\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 15</code></li>\n</ul>\n", "en": "<p>Suppose you have <code>n</code> integers labeled <code>1</code> through <code>n</code>. A permutation of those <code>n</code> integers <code>perm</code> (<strong>1-indexed</strong>) is considered a <strong>beautiful arrangement</strong> if for every <code>i</code> (<code>1 &lt;= i &lt;= n</code>), <strong>either</strong> of the following is true:</p>\n\n<ul>\n\t<li><code>perm[i]</code> is divisible by <code>i</code>.</li>\n\t<li><code>i</code> is divisible by <code>perm[i]</code>.</li>\n</ul>\n\n<p>Given an integer <code>n</code>, return <em>the <strong>number</strong> of the <strong>beautiful arrangements</strong> that you can construct</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 2\n<b>Explanation:</b> \nThe first beautiful arrangement is [1,2]:\n    - perm[1] = 1 is divisible by i = 1\n    - perm[2] = 2 is divisible by i = 2\nThe second beautiful arrangement is [2,1]:\n    - perm[1] = 2 is divisible by i = 1\n    - i = 2 is divisible by perm[2] = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 15</code></li>\n</ul>\n"}}, "527": {"__typename": "QuestionLightNode", "acRate": 0.602674116942726, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "527", "isFavor": false, "solutionNum": 43, "title": "Word Abbreviation", "titleCn": "单词缩写", "titleSlug": "word-abbreviation", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/455700859e03a769dcb90fabbcce91f17af10954d6cab1b473c341ae8511915c-snapchat_logo1-300x300.png", "slug": "snapchat", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "528": {"__typename": "QuestionLightNode", "acRate": 0.48770829767702384, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "528", "isFavor": false, "solutionNum": 510, "title": "Random Pick with Weight", "titleCn": "按权重随机选择", "titleSlug": "random-pick-with-weight", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}, {"id": "xp2m6at", "name": "Randomized", "slug": "randomized", "nameTranslated": "随机化", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 61, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个 <strong>下标从 0 开始</strong> 的正整数数组&nbsp;<code>w</code> ，其中&nbsp;<code>w[i]</code> 代表第 <code>i</code> 个下标的权重。</p>\n\n<p>请你实现一个函数&nbsp;<code>pickIndex</code>&nbsp;，它可以 <strong>随机地</strong> 从范围 <code>[0, w.length - 1]</code> 内（含 <code>0</code> 和 <code>w.length - 1</code>）选出并返回一个下标。选取下标 <code>i</code>&nbsp;的 <strong>概率</strong> 为 <code>w[i] / sum(w)</code> 。</p>\n\n<ol>\n</ol>\n\n<ul>\n\t<li>例如，对于 <code>w = [1, 3]</code>，挑选下标 <code>0</code> 的概率为 <code>1 / (1 + 3)&nbsp;= 0.25</code> （即，25%），而选取下标 <code>1</code> 的概率为 <code>3 / (1 + 3)&nbsp;= 0.75</code>（即，<code>75%</code>）。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Solution\",\"pickIndex\"]\n[[[1]],[]]\n<strong>输出：</strong>\n[null,0]\n<strong>解释：</strong>\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"]\n[[[1,3]],[],[],[],[],[]]\n<strong>输出：</strong>\n[null,1,1,1,1,0]\n<strong>解释：</strong>\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。\n\n由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\n诸若此类。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= w.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= w[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pickIndex</code>&nbsp;将被调用不超过 <code>10<sup>4</sup></code>&nbsp;次</li>\n</ul>\n", "en": "<p>You are given a <strong>0-indexed</strong> array of positive integers <code>w</code> where <code>w[i]</code> describes the <strong>weight</strong> of the <code>i<sup>th</sup></code> index.</p>\n\n<p>You need to implement the function <code>pickIndex()</code>, which <strong>randomly</strong> picks an index in the range <code>[0, w.length - 1]</code> (<strong>inclusive</strong>) and returns it. The <strong>probability</strong> of picking an index <code>i</code> is <code>w[i] / sum(w)</code>.</p>\n\n<ul>\n\t<li>For example, if <code>w = [1, 3]</code>, the probability of picking index <code>0</code> is <code>1 / (1 + 3) = 0.25</code> (i.e., <code>25%</code>), and the probability of picking index <code>1</code> is <code>3 / (1 + 3) = 0.75</code> (i.e., <code>75%</code>).</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Solution&quot;,&quot;pickIndex&quot;]\n[[[1]],[]]\n<strong>Output</strong>\n[null,0]\n\n<strong>Explanation</strong>\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;]\n[[[1,3]],[],[],[],[],[]]\n<strong>Output</strong>\n[null,1,1,1,1,0]\n\n<strong>Explanation</strong>\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.\n\nSince this is a randomization problem, multiple answers are allowed.\nAll of the following outputs can be considered correct:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\nand so on.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= w.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= w[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>pickIndex</code> will be called at most <code>10<sup>4</sup></code> times.</li>\n</ul>\n"}}, "529": {"__typename": "QuestionLightNode", "acRate": 0.6386308690673114, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "529", "isFavor": false, "solutionNum": 621, "title": "Minesweeper", "titleCn": "扫雷游戏", "titleSlug": "minesweeper", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 38, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>让我们一起来玩扫雷游戏！</p>\n\n<p>给你一个大小为 <code>m x n</code> 二维字符矩阵&nbsp;<code>board</code> ，表示扫雷游戏的盘面，其中：</p>\n\n<ul>\n\t<li><code>'M'</code>&nbsp;代表一个 <strong>未挖出的</strong> 地雷，</li>\n\t<li><code>'E'</code>&nbsp;代表一个<strong> 未挖出的 </strong>空方块，</li>\n\t<li><code>'B'</code><strong>&nbsp;</strong>代表没有相邻（上，下，左，右，和所有4个对角线）地雷的<strong> 已挖出的 </strong>空白方块，</li>\n\t<li><strong>数字</strong>（<code>'1'</code> 到 <code>'8'</code>）表示有多少地雷与这块<strong> 已挖出的</strong> 方块相邻，</li>\n\t<li><code>'X'</code>&nbsp;则表示一个<strong> 已挖出的</strong> 地雷。</li>\n</ul>\n\n<p>给你一个整数数组 <code>click</code> ，其中 <code>click = [click<sub>r</sub>, click<sub>c</sub>]</code> 表示在所有<strong> 未挖出的 </strong>方块（<code>'M'</code> 或者 <code>'E'</code>）中的下一个点击位置（<code>click<sub>r</sub></code> 是行下标，<code>click<sub>c</sub></code> 是列下标）。</p>\n\n<p>根据以下规则，返回相应位置被点击后对应的盘面：</p>\n\n<ol>\n\t<li>如果一个地雷（<code>'M'</code>）被挖出，游戏就结束了- 把它改为&nbsp;<code>'X'</code> 。</li>\n\t<li>如果一个<strong> 没有相邻地雷 </strong>的空方块（<code>'E'</code>）被挖出，修改它为（<code>'B'</code>），并且所有和其相邻的<strong> 未挖出 </strong>方块都应该被递归地揭露。</li>\n\t<li>如果一个<strong> 至少与一个地雷相邻</strong> 的空方块（<code>'E'</code>）被挖出，修改它为数字（<code>'1'</code> 到 <code>'8'</code> ），表示相邻地雷的数量。</li>\n\t<li>如果在此次点击中，若无更多方块可被揭露，则返回盘面。</li>\n</ol>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2023/08/09/untitled.jpeg\" style=\"width: 500px; max-width: 400px; height: 269px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]], click = [3,0]\n<strong>输出：</strong>[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2023/08/09/untitled-2.jpeg\" style=\"width: 500px; max-width: 400px; height: 275px;\" />\n<pre>\n<strong>输入：</strong>board = [[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]], click = [1,2]\n<strong>输出：</strong>[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"X\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>board[i][j]</code> 为 <code>'M'</code>、<code>'E'</code>、<code>'B'</code> 或数字 <code>'1'</code> 到 <code>'8'</code> 中的一个</li>\n\t<li><code>click.length == 2</code></li>\n\t<li><code>0 &lt;= click<sub>r</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= click<sub>c</sub> &lt; n</code></li>\n\t<li><code>board[click<sub>r</sub>][click<sub>c</sub>]</code> 为 <code>'M'</code> 或 <code>'E'</code></li>\n</ul>\n", "en": "<p>Let&#39;s play the minesweeper game (<a href=\"https://en.wikipedia.org/wiki/Minesweeper_(video_game)\" target=\"_blank\">Wikipedia</a>, <a href=\"http://minesweeperonline.com\" target=\"_blank\">online game</a>)!</p>\n\n<p>You are given an <code>m x n</code> char matrix <code>board</code> representing the game board where:</p>\n\n<ul>\n\t<li><code>&#39;M&#39;</code> represents an unrevealed mine,</li>\n\t<li><code>&#39;E&#39;</code> represents an unrevealed empty square,</li>\n\t<li><code>&#39;B&#39;</code> represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),</li>\n\t<li>digit (<code>&#39;1&#39;</code> to <code>&#39;8&#39;</code>) represents how many mines are adjacent to this revealed square, and</li>\n\t<li><code>&#39;X&#39;</code> represents a revealed mine.</li>\n</ul>\n\n<p>You are also given an integer array <code>click</code> where <code>click = [click<sub>r</sub>, click<sub>c</sub>]</code> represents the next click position among all the unrevealed squares (<code>&#39;M&#39;</code> or <code>&#39;E&#39;</code>).</p>\n\n<p>Return <em>the board after revealing this position according to the following rules</em>:</p>\n\n<ol>\n\t<li>If a mine <code>&#39;M&#39;</code> is revealed, then the game is over. You should change it to <code>&#39;X&#39;</code>.</li>\n\t<li>If an empty square <code>&#39;E&#39;</code> with no adjacent mines is revealed, then change it to a revealed blank <code>&#39;B&#39;</code> and all of its adjacent unrevealed squares should be revealed recursively.</li>\n\t<li>If an empty square <code>&#39;E&#39;</code> with at least one adjacent mine is revealed, then change it to a digit (<code>&#39;1&#39;</code> to <code>&#39;8&#39;</code>) representing the number of adjacent mines.</li>\n\t<li>Return the board when no more squares will be revealed.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2023/08/09/untitled.jpeg\" style=\"width: 500px; max-width: 400px; height: 269px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;],[&quot;E&quot;,&quot;E&quot;,&quot;M&quot;,&quot;E&quot;,&quot;E&quot;],[&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;],[&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;,&quot;E&quot;]], click = [3,0]\n<strong>Output:</strong> [[&quot;B&quot;,&quot;1&quot;,&quot;E&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;M&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2023/08/09/untitled-2.jpeg\" style=\"width: 489px; max-width: 400px; height: 269px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;B&quot;,&quot;1&quot;,&quot;E&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;M&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]], click = [1,2]\n<strong>Output:</strong> [[&quot;B&quot;,&quot;1&quot;,&quot;E&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;X&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;B&quot;],[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>board[i][j]</code> is either <code>&#39;M&#39;</code>, <code>&#39;E&#39;</code>, <code>&#39;B&#39;</code>, or a digit from <code>&#39;1&#39;</code> to <code>&#39;8&#39;</code>.</li>\n\t<li><code>click.length == 2</code></li>\n\t<li><code>0 &lt;= click<sub>r</sub> &lt; m</code></li>\n\t<li><code>0 &lt;= click<sub>c</sub> &lt; n</code></li>\n\t<li><code>board[click<sub>r</sub>][click<sub>c</sub>]</code> is either <code>&#39;M&#39;</code> or <code>&#39;E&#39;</code>.</li>\n</ul>\n"}}, "530": {"__typename": "QuestionLightNode", "acRate": 0.6280297086667713, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "530", "isFavor": false, "solutionNum": 1391, "title": "Minimum Absolute Difference in BST", "titleCn": "二叉搜索树的最小绝对差", "titleSlug": "minimum-absolute-difference-in-bst", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 24, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>\n\n<p>差值是一个正数，其数值等于两值之差的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg\" style=\"width: 292px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [4,2,6,1,3]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg\" style=\"width: 282px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [1,0,48,null,null,12,49]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目范围是 <code>[2, 10<sup>4</sup>]</code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong>本题与 783 <a href=\"https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/\">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</p>\n", "en": "<p>Given the <code>root</code> of a Binary Search Tree (BST), return <em>the minimum absolute difference between the values of any two different nodes in the tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg\" style=\"width: 292px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,6,1,3]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg\" style=\"width: 282px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [1,0,48,null,null,12,49]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as 783: <a href=\"https://leetcode.com/problems/minimum-distance-between-bst-nodes/\" target=\"_blank\">https://leetcode.com/problems/minimum-distance-between-bst-nodes/</a></p>\n"}}, "531": {"__typename": "QuestionLightNode", "acRate": 0.6419311222460828, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "531", "isFavor": false, "solutionNum": 132, "title": "Lonely Pixel I", "titleCn": "孤独像素 I", "titleSlug": "lonely-pixel-i", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 7, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/06353afb6baafdf33cc19ddc1c918b0d5fc68934ca68cb9b99355d55ae7f34e2-0ccad55b2d6c9f7922aef717ad53fe3fcfcd208495d565ef66e7dff9f98764da.jpg", "slug": "nvidia", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "532": {"__typename": "QuestionLightNode", "acRate": 0.461459539275291, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "532", "isFavor": false, "solutionNum": 726, "title": "K-diff Pairs in an Array", "titleCn": "数组中的 k-diff 数对", "titleSlug": "k-diff-pairs-in-an-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 45, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937282-qSKaPF-Unknown-4.jpeg", "slug": "twitter", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组&nbsp;<code>nums</code> 和一个整数&nbsp;<code>k</code>，请你在数组中找出<strong> 不同的&nbsp;</strong>k-diff 数对，并返回不同的 <strong>k-diff 数对</strong> 的数目。</p>\n\n<p><strong>k-diff</strong>&nbsp;数对定义为一个整数对 <code>(nums[i], nums[j])</code><strong> </strong>，并满足下述全部条件：</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j &lt; nums.length</code></li>\n\t<li><code>i != j</code></li>\n\t<li><code>|nums[i] - nums[j]| == k</code></li>\n</ul>\n\n<p><strong>注意</strong>，<code>|val|</code> 表示 <code>val</code> 的绝对值。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [3, 1, 4, 1, 5], k = 2\n<strong>输出：</strong>2\n<strong>解释：</strong>数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。\n尽管数组中有两个 1 ，但我们只应返回不同的数对的数量。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1, 2, 3, 4, 5], k = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1, 3, 1, 5, 4], k = 0\n<strong>输出：</strong>1\n<strong>解释：</strong>数组中只有一个 0-diff 数对，(1, 1) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>7</sup></code></li>\n</ul>\n", "en": "<p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the number of <b>unique</b> k-diff pairs in the array</em>.</p>\n\n<p>A <strong>k-diff</strong> pair is an integer pair <code>(nums[i], nums[j])</code>, where the following are true:</p>\n\n<ul>\n\t<li><code>0 &lt;= i, j &lt; nums.length</code></li>\n\t<li><code>i != j</code></li>\n\t<li><code>|nums[i] - nums[j]| == k</code></li>\n</ul>\n\n<p><strong>Notice</strong> that <code>|val|</code> denotes the absolute value of <code>val</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,4,1,5], k = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are two 2-diff pairs in the array, (1, 3) and (3, 5).\nAlthough we have two 1s in the input, we should only return the number of <strong>unique</strong> pairs.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5], k = 1\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,1,5,4], k = 0\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> There is one 0-diff pair in the array, (1, 1).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>7</sup></code></li>\n</ul>\n"}}, "533": {"__typename": "QuestionLightNode", "acRate": 0.5236728837876614, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "533", "isFavor": false, "solutionNum": 52, "title": "Lonely Pixel II", "titleCn": "孤独像素 II", "titleSlug": "lonely-pixel-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 3, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "534": {"__typename": "QuestionLightNode", "acRate": 0.695993434619755, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "534", "isFavor": false, "solutionNum": 225, "title": "Game Play Analysis III", "titleCn": "游戏玩法分析 III", "titleSlug": "game-play-analysis-iii", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 7, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/03c9c3e706139f82f21377990af4c58c89e3c40cb159c12caea18588746390a8-Verified_eBay_Voucher_Code._200x200.png", "slug": "ebay", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1710493578-gEafms-Twilio.png", "slug": "twilio", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "535": {"__typename": "QuestionLightNode", "acRate": 0.8744984395898351, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "535", "isFavor": false, "solutionNum": 289, "title": "Encode and Decode TinyURL", "titleCn": "TinyURL 的加密与解密", "titleSlug": "encode-and-decode-tinyurl", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "xp2e97i", "name": "Hash Function", "slug": "hash-function", "nameTranslated": "哈希函数", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 49, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL&nbsp;<code>https://leetcode.com/problems/design-tinyurl</code>&nbsp;时，它将返回一个简化的URL&nbsp;<code>http://tinyurl.com/4e9iAk</code> 。请你设计一个类来加密与解密 TinyURL 。</p>\n\n<p>加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。</p>\n\n<p>实现 <code>Solution</code> 类：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li><code>Solution()</code> 初始化 TinyURL 系统对象。</li>\n\t<li><code>String encode(String longUrl)</code> 返回 <code>longUrl</code> 对应的 TinyURL 。</li>\n\t<li><code>String decode(String shortUrl)</code> 返回 <code>shortUrl</code> 原本的 URL 。题目数据保证给定的 <code>shortUrl</code> 是由同一个系统对象加密的。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>url = \"https://leetcode.com/problems/design-tinyurl\"\n<strong>输出：</strong>\"https://leetcode.com/problems/design-tinyurl\"\n\n<strong>解释：</strong>\nSolution obj = new Solution();\nstring tiny = obj.encode(url); // 返回加密后得到的 TinyURL 。\nstring ans = obj.decode(tiny); // 返回解密后得到的原本的 URL 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= url.length &lt;= 10<sup>4</sup></code></li>\n\t<li>题目数据保证 <code>url</code> 是一个有效的 URL</li>\n</ul>\n</div>\n</div>\n", "en": "<blockquote>Note: This is a companion problem to the <a href=\"https://leetcode.com/discuss/interview-question/system-design/\" target=\"_blank\">System Design</a> problem: <a href=\"https://leetcode.com/discuss/interview-question/124658/Design-a-URL-Shortener-(-TinyURL-)-System/\" target=\"_blank\">Design TinyURL</a>.</blockquote>\n\n<p>TinyURL is a URL shortening service where you enter a URL such as <code>https://leetcode.com/problems/design-tinyurl</code> and it returns a short URL such as <code>http://tinyurl.com/4e9iAk</code>. Design a class to encode a URL and decode a tiny URL.</p>\n\n<p>There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</p>\n\n<p>Implement the <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution()</code> Initializes the object of the system.</li>\n\t<li><code>String encode(String longUrl)</code> Returns a tiny URL for the given <code>longUrl</code>.</li>\n\t<li><code>String decode(String shortUrl)</code> Returns the original long URL for the given <code>shortUrl</code>. It is guaranteed that the given <code>shortUrl</code> was encoded by the same object.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> url = &quot;https://leetcode.com/problems/design-tinyurl&quot;\n<strong>Output:</strong> &quot;https://leetcode.com/problems/design-tinyurl&quot;\n\n<strong>Explanation:</strong>\nSolution obj = new Solution();\nstring tiny = obj.encode(url); // returns the encoded tiny url.\nstring ans = obj.decode(tiny); // returns the original url after decoding it.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= url.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>url</code> is guranteed to be a valid URL.</li>\n</ul>\n"}}, "536": {"__typename": "QuestionLightNode", "acRate": 0.5570020793779947, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "536", "isFavor": false, "solutionNum": 102, "title": "Construct Binary Tree from String", "titleCn": "从字符串生成二叉树", "titleSlug": "construct-binary-tree-from-string", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 16, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/cf2a3ac504c38f16ee9e9e828b4f40ed444dc54e25653145bbfdf9f2f467115a-1587797765803.jpg", "slug": "oracle", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "537": {"__typename": "QuestionLightNode", "acRate": 0.7426450720790884, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "537", "isFavor": false, "solutionNum": 682, "title": "Complex Number Multiplication", "titleCn": "复数乘法", "titleSlug": "complex-number-multiplication", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 13, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><a href=\"https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0/254365?fr=aladdin\" target=\"_blank\">复数</a> 可以用字符串表示，遵循 <code>\"<strong>实部</strong>+<strong>虚部</strong>i\"</code> 的形式，并满足下述条件：</p>\n\n<ul>\n\t<li><code>实部</code> 是一个整数，取值范围是 <code>[-100, 100]</code></li>\n\t<li><code>虚部</code> 也是一个整数，取值范围是 <code>[-100, 100]</code></li>\n\t<li><code>i<sup>2</sup> == -1</code></li>\n</ul>\n\n<p>给你两个字符串表示的复数 <code>num1</code> 和 <code>num2</code> ，请你遵循复数表示形式，返回表示它们乘积的字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = \"1+1i\", num2 = \"1+1i\"\n<strong>输出：</strong>\"0+2i\"\n<strong>解释：</strong>(1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>num1 = \"1+-1i\", num2 = \"1+-1i\"\n<strong>输出：</strong>\"0+-2i\"\n<strong>解释：</strong>(1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。 \n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>num1</code> 和 <code>num2</code> 都是有效的复数表示。</li>\n</ul>\n", "en": "<p>A <a href=\"https://en.wikipedia.org/wiki/Complex_number\" target=\"_blank\">complex number</a> can be represented as a string on the form <code>&quot;<strong>real</strong>+<strong>imaginary</strong>i&quot;</code> where:</p>\n\n<ul>\n\t<li><code>real</code> is the real part and is an integer in the range <code>[-100, 100]</code>.</li>\n\t<li><code>imaginary</code> is the imaginary part and is an integer in the range <code>[-100, 100]</code>.</li>\n\t<li><code>i<sup>2</sup> == -1</code>.</li>\n</ul>\n\n<p>Given two complex numbers <code>num1</code> and <code>num2</code> as strings, return <em>a string of the complex number that represents their multiplications</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = &quot;1+1i&quot;, num2 = &quot;1+1i&quot;\n<strong>Output:</strong> &quot;0+2i&quot;\n<strong>Explanation:</strong> (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num1 = &quot;1+-1i&quot;, num2 = &quot;1+-1i&quot;\n<strong>Output:</strong> &quot;0+-2i&quot;\n<strong>Explanation:</strong> (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>num1</code> and <code>num2</code> are valid complex numbers.</li>\n</ul>\n"}}, "538": {"__typename": "QuestionLightNode", "acRate": 0.7731314877921436, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "538", "isFavor": false, "solutionNum": 1690, "title": "Convert BST to Greater Tree", "titleCn": "把二叉搜索树转换为累加树", "titleSlug": "convert-bst-to-greater-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 21, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给出二叉<strong> 搜索 </strong>树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code>&nbsp;的新值等于原树中大于或等于&nbsp;<code>node.val</code>&nbsp;的值之和。</p>\n\n<p>提醒一下，二叉搜索树满足下列约束条件：</p>\n\n<ul>\n\t<li>节点的左子树仅包含键<strong> 小于 </strong>节点键的节点。</li>\n\t<li>节点的右子树仅包含键<strong> 大于</strong> 节点键的节点。</li>\n\t<li>左右子树也必须是二叉搜索树。</li>\n</ul>\n\n<p><strong>注意：</strong>本题和 1038:&nbsp;<a href=\"https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/\">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png\" style=\"height: 364px; width: 534px;\"></strong></p>\n\n<pre><strong>输入：</strong>[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n<strong>输出：</strong>[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>root = [0,null,1]\n<strong>输出：</strong>[1,null,1]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>root = [1,0,2]\n<strong>输出：</strong>[3,3,2]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>root = [3,2,4,1]\n<strong>输出：</strong>[7,9,4,10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数介于 <code>0</code>&nbsp;和 <code>10<sup>4</sup></code><sup>&nbsp;</sup>之间。</li>\n\t<li>每个节点的值介于 <code>-10<sup>4</sup></code>&nbsp;和&nbsp;<code>10<sup>4</sup></code>&nbsp;之间。</li>\n\t<li>树中的所有值 <strong>互不相同</strong> 。</li>\n\t<li>给定的树为二叉搜索树。</li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.</p>\n\n<p>As a reminder, a <em>binary search tree</em> is a tree that satisfies these constraints:</p>\n\n<ul>\n\t<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>\n\t<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/05/02/tree.png\" style=\"width: 500px; height: 341px;\" />\n<pre>\n<strong>Input:</strong> root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\n<strong>Output:</strong> [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0,null,1]\n<strong>Output:</strong> [1,null,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>All the values in the tree are <strong>unique</strong>.</li>\n\t<li><code>root</code> is guaranteed to be a valid binary search tree.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as 1038: <a href=\"https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/\" target=\"_blank\">https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/</a></p>\n"}}, "539": {"__typename": "QuestionLightNode", "acRate": 0.6542044394881803, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "539", "isFavor": false, "solutionNum": 696, "title": "Minimum Time Difference", "titleCn": "最小时间差", "titleSlug": "minimum-time-difference", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 21, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1710493537-jqtLQv-Palantir.png", "slug": "palantir-technologies", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个 24 小时制（小时:分钟 <strong>\"HH:MM\"</strong>）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>timePoints = [\"23:59\",\"00:00\"]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>timePoints = [\"00:00\",\"23:59\",\"00:00\"]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= timePoints.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>timePoints[i]</code> 格式为 <strong>\"HH:MM\"</strong></li>\n</ul>\n", "en": "Given a list of 24-hour clock time points in <strong>&quot;HH:MM&quot;</strong> format, return <em>the minimum <b>minutes</b> difference between any two time-points in the list</em>.\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> timePoints = [\"23:59\",\"00:00\"]\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> timePoints = [\"00:00\",\"23:59\",\"00:00\"]\n<strong>Output:</strong> 0\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= timePoints.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>timePoints[i]</code> is in the format <strong>&quot;HH:MM&quot;</strong>.</li>\n</ul>\n"}}, "540": {"__typename": "QuestionLightNode", "acRate": 0.6029716753316856, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "540", "isFavor": false, "solutionNum": 1135, "title": "Single Element in a Sorted Array", "titleCn": "有序数组中的单一元素", "titleSlug": "single-element-in-a-sorted-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 46, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。</p>\n\n<p>请你找出并返回只出现一次的那个数。</p>\n\n<p>你设计的解决方案必须满足 <code>O(log n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,1,2,3,3,4,4,8,8]\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums =  [3,3,7,7,10,11,11]\n<strong>输出:</strong> 10\n</pre>\n\n<p>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.</p>\n\n<p>Return <em>the single element that appears only once</em>.</p>\n\n<p>Your solution must run in <code>O(log n)</code> time and <code>O(1)</code> space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1,2,3,3,4,4,8,8]\n<strong>Output:</strong> 2\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [3,3,7,7,10,11,11]\n<strong>Output:</strong> 10\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "541": {"__typename": "QuestionLightNode", "acRate": 0.5743605623596524, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "541", "isFavor": false, "solutionNum": 1810, "title": "Reverse String II", "titleCn": "反转字符串 II", "titleSlug": "reverse-string-ii", "topicTags": [{"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 35, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p>\n\n<ul>\n\t<li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>\n\t<li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcdefg\", k = 2\n<strong>输出：</strong>\"bacdfeg\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abcd\", k = 2\n<strong>输出：</strong>\"bacd\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> 仅由小写英文组成</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given a string <code>s</code> and an integer <code>k</code>, reverse the first <code>k</code> characters for every <code>2k</code> characters counting from the start of the string.</p>\n\n<p>If there are fewer than <code>k</code> characters left, reverse all of them. If there are less than <code>2k</code> but greater than or equal to <code>k</code> characters, then reverse the first <code>k</code> characters and leave the other as original.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"abcdefg\", k = 2\n<strong>Output:</strong> \"bacdfeg\"\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"abcd\", k = 2\n<strong>Output:</strong> \"bacd\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of only lowercase English letters.</li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "542": {"__typename": "QuestionLightNode", "acRate": 0.46792196096733696, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "542", "isFavor": false, "solutionNum": 1139, "title": "01 Matrix", "titleCn": "01 矩阵", "titleSlug": "01-matrix", "topicTags": [{"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 45, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵 <code>mat</code> ，请输出一个大小相同的矩阵，其中每一个格子是 <code>mat</code> 中对应位置元素到最近的 <code>0</code> 的距离。</p>\n\n<p>两个相邻元素间的距离为 <code>1</code> 。</p>\n\n<p> </p>\n\n<p><b>示例 1：</b></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626667201-NCWmuP-image.png\" style=\"width: 150px; \" /></p>\n\n<pre>\n<strong>输入：</strong>mat =<strong> </strong>[[0,0,0],[0,1,0],[0,0,0]]\n<strong>输出：</strong>[[0,0,0],[0,1,0],[0,0,0]]\n</pre>\n\n<p><b>示例 2：</b></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626667205-xFxIeK-image.png\" style=\"width: 150px; \" /></p>\n\n<pre>\n<b>输入：</b>mat =<b> </b>[[0,0,0],[0,1,0],[1,1,1]]\n<strong>输出：</strong>[[0,0,0],[0,1,0],[1,2,1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 <= m, n <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= m * n <= 10<sup>4</sup></code></li>\n\t<li><code>mat[i][j] is either 0 or 1.</code></li>\n\t<li><code>mat</code> 中至少有一个 <code>0 </code></li>\n</ul>\n", "en": "<p>Given an <code>m x n</code> binary matrix <code>mat</code>, return <em>the distance of the nearest </em><code>0</code><em> for each cell</em>.</p>\n\n<p>The distance between two adjacent cells is <code>1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/01-1-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> mat = [[0,0,0],[0,1,0],[0,0,0]]\n<strong>Output:</strong> [[0,0,0],[0,1,0],[0,0,0]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/01-2-grid.jpg\" style=\"width: 253px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> mat = [[0,0,0],[0,1,0],[1,1,1]]\n<strong>Output:</strong> [[0,0,0],[0,1,0],[1,2,1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li>\n\t<li>There is at least one <code>0</code> in <code>mat</code>.</li>\n</ul>\n"}}, "543": {"__typename": "QuestionLightNode", "acRate": 0.6010037677744468, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "543", "isFavor": false, "solutionNum": 2538, "title": "Diameter of Binary Tree", "titleCn": "二叉树的直径", "titleSlug": "diameter-of-binary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 75, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p>\n\n<p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p>\n\n<p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,5]\n<strong>输出：</strong>3\n<strong>解释：</strong>3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree, return <em>the length of the <strong>diameter</strong> of the tree</em>.</p>\n\n<p>The <strong>diameter</strong> of a binary tree is the <strong>length</strong> of the longest path between any two nodes in a tree. This path may or may not pass through the <code>root</code>.</p>\n\n<p>The <strong>length</strong> of a path between two nodes is represented by the number of edges between them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,2]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n"}}, "544": {"__typename": "QuestionLightNode", "acRate": 0.7234856107868787, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "544", "isFavor": false, "solutionNum": 75, "title": "Output Contest Matches", "titleCn": "输出比赛匹配对", "titleSlug": "output-contest-matches", "topicTags": [{"id": "nbdc3", "name": "Recursion", "slug": "recursion", "nameTranslated": "递归", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 6, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "545": {"__typename": "QuestionLightNode", "acRate": 0.46065012831479896, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "545", "isFavor": false, "solutionNum": 118, "title": "Boundary of Binary Tree", "titleCn": "二叉树的边界", "titleSlug": "boundary-of-binary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 29, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "546": {"__typename": "QuestionLightNode", "acRate": 0.6069192138384277, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "546", "isFavor": false, "solutionNum": 151, "title": "Remove Boxes", "titleCn": "移除盒子", "titleSlug": "remove-boxes", "topicTags": [{"id": "vhos7", "name": "Memoization", "slug": "memoization", "nameTranslated": "记忆化搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 29, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2020/11/2f76be9b-48c6-4111-a005-7d11673dffa0/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200730154359.jpg", "slug": "vivo", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给出一些不同颜色的盒子<meta charset=\"UTF-8\" />&nbsp;<code>boxes</code>&nbsp;，盒子的颜色由不同的正数表示。</p>\n\n<p>你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 <code>k</code> 个盒子（<code>k&nbsp;&gt;= 1</code>），这样一轮之后你将得到 <code>k * k</code> 个积分。</p>\n\n<p>返回 <em>你能获得的最大积分和</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxes = [1,3,2,2,2,3,4,3,1]\n<strong>输出：</strong>23\n<strong>解释：</strong>\n[1, 3, 2, 2, 2, 3, 4, 3, 1] \n----&gt; [1, 3, 3, 4, 3, 1] (3*3=9 分) \n----&gt; [1, 3, 3, 3, 1] (1*1=1 分) \n----&gt; [1, 1] (3*3=9 分) \n----&gt; [] (2*2=4 分)\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxes = [1,1,1]\n<strong>输出：</strong>9\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>boxes = [1]\n<strong>输出：</strong>1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= boxes.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= boxes[i]&nbsp;&lt;= 100</code></li>\n</ul>\n", "en": "<p>You are given several <code>boxes</code> with different colors represented by different positive numbers.</p>\n\n<p>You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of <code>k</code> boxes, <code>k &gt;= 1</code>), remove them and get <code>k * k</code> points.</p>\n\n<p>Return <em>the maximum points you can get</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> boxes = [1,3,2,2,2,3,4,3,1]\n<strong>Output:</strong> 23\n<strong>Explanation:</strong>\n[1, 3, 2, 2, 2, 3, 4, 3, 1] \n----&gt; [1, 3, 3, 4, 3, 1] (3*3=9 points) \n----&gt; [1, 3, 3, 3, 1] (1*1=1 points) \n----&gt; [1, 1] (3*3=9 points) \n----&gt; [] (2*2=4 points)\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> boxes = [1,1,1]\n<strong>Output:</strong> 9\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> boxes = [1]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= boxes.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= boxes[i]&nbsp;&lt;= 100</code></li>\n</ul>\n"}}, "547": {"__typename": "QuestionLightNode", "acRate": 0.6217750425793969, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "547", "isFavor": false, "solutionNum": 1993, "title": "Number of Provinces", "titleCn": "省份数量", "titleSlug": "number-of-provinces", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "n6a2i", "name": "Union Find", "slug": "union-find", "nameTranslated": "并查集", "__typename": "CommonTagNode"}, {"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 63, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/db2c726d9e93256c701c8530c852abbe0b9fa11057ee0a83a775a99b556c872c-two-sigma-logo.png", "slug": "two-sigma", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<div class=\"original__bRMd\">\n<div>\n<p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p>\n\n<p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>\n\n<p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p>\n\n<p>返回矩阵中 <strong>省份</strong> 的数量。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg\" style=\"width: 222px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg\" style=\"width: 222px; height: 142px;\" />\n<pre>\n<strong>输入：</strong>isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n<strong>输出：</strong>3\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 200</code></li>\n\t<li><code>n == isConnected.length</code></li>\n\t<li><code>n == isConnected[i].length</code></li>\n\t<li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li>\n\t<li><code>isConnected[i][i] == 1</code></li>\n\t<li><code>isConnected[i][j] == isConnected[j][i]</code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>There are <code>n</code> cities. Some of them are connected, while some are not. If city <code>a</code> is connected directly with city <code>b</code>, and city <code>b</code> is connected directly with city <code>c</code>, then city <code>a</code> is connected indirectly with city <code>c</code>.</p>\n\n<p>A <strong>province</strong> is a group of directly or indirectly connected cities and no other cities outside of the group.</p>\n\n<p>You are given an <code>n x n</code> matrix <code>isConnected</code> where <code>isConnected[i][j] = 1</code> if the <code>i<sup>th</sup></code> city and the <code>j<sup>th</sup></code> city are directly connected, and <code>isConnected[i][j] = 0</code> otherwise.</p>\n\n<p>Return <em>the total number of <strong>provinces</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg\" style=\"width: 222px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg\" style=\"width: 222px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> isConnected = [[1,0,0],[0,1,0],[0,0,1]]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>n == isConnected.length</code></li>\n\t<li><code>n == isConnected[i].length</code></li>\n\t<li><code>isConnected[i][j]</code> is <code>1</code> or <code>0</code>.</li>\n\t<li><code>isConnected[i][i] == 1</code></li>\n\t<li><code>isConnected[i][j] == isConnected[j][i]</code></li>\n</ul>\n"}}, "548": {"__typename": "QuestionLightNode", "acRate": 0.39282978397426077, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "548", "isFavor": false, "solutionNum": 55, "title": "Split Array with Equal Sum", "titleCn": "将数组分割成和相等的子数组", "titleSlug": "split-array-with-equal-sum", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/03c9c3e706139f82f21377990af4c58c89e3c40cb159c12caea18588746390a8-Verified_eBay_Voucher_Code._200x200.png", "slug": "ebay", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "549": {"__typename": "QuestionLightNode", "acRate": 0.4986742089446703, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "549", "isFavor": false, "solutionNum": 99, "title": "Binary Tree Longest Consecutive Sequence II", "titleCn": "二叉树最长连续序列 II", "titleSlug": "binary-tree-longest-consecutive-sequence-ii", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "550": {"__typename": "QuestionLightNode", "acRate": 0.41460508055270623, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "550", "isFavor": false, "solutionNum": 520, "title": "Game Play Analysis IV", "titleCn": "游戏玩法分析 IV", "titleSlug": "game-play-analysis-iv", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 11, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>Table:&nbsp;<code>Activity</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| player_id    | int     |\n| device_id    | int     |\n| event_date   | date    |\n| games_played | int     |\n+--------------+---------+\n（player_id，event_date）是此表的主键（具有唯一值的列的组合）。\n这张表显示了某些游戏的玩家的活动情况。\n每一行是一个玩家的记录，他在某一天使用某个设备注销之前登录并玩了很多游戏（可能是 0）。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写解决方案，报告在首次登录的第二天再次登录的玩家的 <strong>比率</strong>，<strong>四舍五入到小数点后两位</strong>。换句话说，你需要计算从首次登录日期开始至少连续两天登录的玩家的数量，然后除以玩家总数。</p>\n\n<p>结果格式如下所示：</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nActivity table:\n+-----------+-----------+------------+--------------+\n| player_id | device_id | event_date | games_played |\n+-----------+-----------+------------+--------------+\n| 1         | 2         | 2016-03-01 | 5            |\n| 1         | 2         | 2016-03-02 | 6            |\n| 2         | 3         | 2017-06-25 | 1            |\n| 3         | 1         | 2016-03-02 | 0            |\n| 3         | 4         | 2018-07-03 | 5            |\n+-----------+-----------+------------+--------------+\n<strong>输出：</strong>\n+-----------+\n| fraction  |\n+-----------+\n| 0.33      |\n+-----------+\n<strong>解释：</strong>\n只有 ID 为 1 的玩家在第一天登录后才重新登录，所以答案是 1/3 = 0.33\n</pre>\n", "en": "<p>Table: <code>Activity</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| player_id    | int     |\n| device_id    | int     |\n| event_date   | date    |\n| games_played | int     |\n+--------------+---------+\n(player_id, event_date) is the primary key (combination of columns with unique values) of this table.\nThis table shows the activity of players of some games.\nEach row is a record of a player who logged in and played a number of games (possibly 0) before logging out on someday using some device.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a&nbsp;solution&nbsp;to report the <strong>fraction</strong> of players that logged in again on the day after the day they first logged in, <strong>rounded to 2 decimal places</strong>. In other words, you need to count the number of players that logged in for at least two consecutive days starting from their first login date, then divide that number by the total number of players.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nActivity table:\n+-----------+-----------+------------+--------------+\n| player_id | device_id | event_date | games_played |\n+-----------+-----------+------------+--------------+\n| 1         | 2         | 2016-03-01 | 5            |\n| 1         | 2         | 2016-03-02 | 6            |\n| 2         | 3         | 2017-06-25 | 1            |\n| 3         | 1         | 2016-03-02 | 0            |\n| 3         | 4         | 2018-07-03 | 5            |\n+-----------+-----------+------------+--------------+\n<strong>Output:</strong> \n+-----------+\n| fraction  |\n+-----------+\n| 0.33      |\n+-----------+\n<strong>Explanation:</strong> \nOnly the player with id 1 logged back in after the first day he had logged in so the answer is 1/3 = 0.33\n</pre>\n"}}, "551": {"__typename": "QuestionLightNode", "acRate": 0.5710511752925055, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "551", "isFavor": false, "solutionNum": 1035, "title": "Student Attendance Record I", "titleCn": "学生出勤记录 I", "titleSlug": "student-attendance-record-i", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 11, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code> 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>\n\n<ul>\n\t<li><code>'A'</code>：Absent，缺勤</li>\n\t<li><code>'L'</code>：Late，迟到</li>\n\t<li><code>'P'</code>：Present，到场</li>\n</ul>\n\n<p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>\n\n<ul>\n\t<li>按 <strong>总出勤</strong> 计，学生缺勤（<code>'A'</code>）<strong>严格</strong> 少于两天。</li>\n\t<li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>'L'</code>）记录。</li>\n</ul>\n\n<p>如果学生可以获得出勤奖励，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"PPALLP\"\n<strong>输出：</strong>true\n<strong>解释：</strong>学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"PPALLL\"\n<strong>输出：</strong>false\n<strong>解释：</strong>学生最后三天连续迟到，所以不满足出勤奖励的条件。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code> 为 <code>'A'</code>、<code>'L'</code> 或 <code>'P'</code></li>\n</ul>\n", "en": "<p>You are given a string <code>s</code> representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:</p>\n\n<ul>\n\t<li><code>&#39;A&#39;</code>: Absent.</li>\n\t<li><code>&#39;L&#39;</code>: Late.</li>\n\t<li><code>&#39;P&#39;</code>: Present.</li>\n</ul>\n\n<p>The student is eligible for an attendance award if they meet <strong>both</strong> of the following criteria:</p>\n\n<ul>\n\t<li>The student was absent (<code>&#39;A&#39;</code>) for <strong>strictly</strong> fewer than 2 days <strong>total</strong>.</li>\n\t<li>The student was <strong>never</strong> late (<code>&#39;L&#39;</code>) for 3 or more <strong>consecutive</strong> days.</li>\n</ul>\n\n<p>Return <code>true</code><em> if the student is eligible for an attendance award, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;PPALLP&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The student has fewer than 2 absences and was never late 3 or more consecutive days.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;PPALLL&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The student was late 3 consecutive days in the last 3 days, so is not eligible for the award.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code> is either <code>&#39;A&#39;</code>, <code>&#39;L&#39;</code>, or <code>&#39;P&#39;</code>.</li>\n</ul>\n"}}, "552": {"__typename": "QuestionLightNode", "acRate": 0.5803581766953568, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "552", "isFavor": false, "solutionNum": 358, "title": "Student Attendance Record II", "titleCn": "学生出勤记录 II", "titleSlug": "student-attendance-record-ii", "topicTags": [{"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 10, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/03/73cc6c81-34ea-4863-b4aa-1b3e00fcea36/%E6%8B%9B%E8%A1%8Clogo-200x200.png", "slug": "cmbchina", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：\n<ul>\n\t<li><code>'A'</code>：Absent，缺勤</li>\n\t<li><code>'L'</code>：Late，迟到</li>\n\t<li><code>'P'</code>：Present，到场</li>\n</ul>\n\n<p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>\n\n<ul>\n\t<li>按 <strong>总出勤</strong> 计，学生缺勤（<code>'A'</code>）<strong>严格</strong> 少于两天。</li>\n\t<li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>'L'</code>）记录。</li>\n</ul>\n\n<p>给你一个整数 <code>n</code> ，表示出勤记录的长度（次数）。请你返回记录长度为 <code>n</code> 时，可能获得出勤奖励的记录情况 <strong>数量</strong> 。答案可能很大，所以返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2\n<strong>输出：</strong>8\n<strong>解释：\n</strong>有 8 种长度为 2 的记录将被视为可奖励：\n\"PP\" , \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\" \n只有\"AA\"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 10101\n<strong>输出：</strong>183236316\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:</p>\n\n<ul>\n\t<li><code>&#39;A&#39;</code>: Absent.</li>\n\t<li><code>&#39;L&#39;</code>: Late.</li>\n\t<li><code>&#39;P&#39;</code>: Present.</li>\n</ul>\n\n<p>Any student is eligible for an attendance award if they meet <strong>both</strong> of the following criteria:</p>\n\n<ul>\n\t<li>The student was absent (<code>&#39;A&#39;</code>) for <strong>strictly</strong> fewer than 2 days <strong>total</strong>.</li>\n\t<li>The student was <strong>never</strong> late (<code>&#39;L&#39;</code>) for 3 or more <strong>consecutive</strong> days.</li>\n</ul>\n\n<p>Given an integer <code>n</code>, return <em>the <strong>number</strong> of possible attendance records of length</em> <code>n</code><em> that make a student eligible for an attendance award. The answer may be very large, so return it <strong>modulo</strong> </em><code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> There are 8 records with length 2 that are eligible for an award:\n&quot;PP&quot;, &quot;AP&quot;, &quot;PA&quot;, &quot;LP&quot;, &quot;PL&quot;, &quot;AL&quot;, &quot;LA&quot;, &quot;LL&quot;\nOnly &quot;AA&quot; is not eligible because there are 2 absences (there need to be fewer than 2).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10101\n<strong>Output:</strong> 183236316\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "553": {"__typename": "QuestionLightNode", "acRate": 0.6478542818996758, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "553", "isFavor": false, "solutionNum": 388, "title": "Optimal Division", "titleCn": "最优除法", "titleSlug": "optimal-division", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 11, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一正整数数组<strong> </strong><code>nums</code><strong>，</strong><code>nums</code> 中的相邻整数将进行浮点除法。例如，&nbsp;[2,3,4] -&gt; 2 / 3 / 4 。</p>\n\n<ul>\n\t<li>例如，<code>nums = [2,3,4]</code>，我们将求表达式的值&nbsp;<code>\"2/3/4\"</code>。</li>\n</ul>\n\n<p>但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，以便计算后的表达式的值为最大值。</p>\n\n<p>以字符串格式返回具有最大值的对应表达式。</p>\n\n<p><strong>注意：</strong>你的表达式不应该包含多余的括号。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> [1000,100,10,2]\n<strong>输出:</strong> \"1000/(100/10/2)\"\n<strong>解释: </strong>1000/(100/10/2) = 1000/((100/10)/2) = 200\n但是，以下加粗的括号 \"1000/(<strong>(</strong>100/10<strong>)</strong>/2)\" 是冗余的，\n因为他们并不影响操作的优先级，所以你需要返回 \"1000/(100/10/2)\"。\n\n其他用例:\n1000/(100/10)/2 = 50\n1000/(100/(10/2)) = 50\n1000/100/10/2 = 0.5\n1000/100/(10/2) = 2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [2,3,4]\n<strong>输出:</strong> \"2/(3/4)\"\n<strong>解释:</strong> (2/(3/4)) = 8/3 = 2.667\n可以看出，在尝试了所有的可能性之后，我们无法得到一个结果大于 2.667 的表达式。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>说明:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>2 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>对于给定的输入只有一种最优除法。</li>\n</ul>\n", "en": "<p>You are given an integer array <code>nums</code>. The adjacent integers in <code>nums</code> will perform the float division.</p>\n\n<ul>\n\t<li>For example, for <code>nums = [2,3,4]</code>, we will evaluate the expression <code>&quot;2/3/4&quot;</code>.</li>\n</ul>\n\n<p>However, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum.</p>\n\n<p>Return <em>the corresponding expression that has the maximum value in string format</em>.</p>\n\n<p><strong>Note:</strong> your expression should not contain redundant parenthesis.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1000,100,10,2]\n<strong>Output:</strong> &quot;1000/(100/10/2)&quot;\n<strong>Explanation:</strong> 1000/(100/10/2) = 1000/((100/10)/2) = 200\nHowever, the bold parenthesis in &quot;1000/(<strong>(</strong>100/10<strong>)</strong>/2)&quot; are redundant since they do not influence the operation priority.\nSo you should return &quot;1000/(100/10/2)&quot;.\nOther cases:\n1000/(100/10)/2 = 50\n1000/(100/(10/2)) = 50\n1000/100/10/2 = 0.5\n1000/100/(10/2) = 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,4]\n<strong>Output:</strong> &quot;2/(3/4)&quot;\n<strong>Explanation:</strong> (2/(3/4)) = 8/3 = 2.667\nIt can be shown that after trying all possibilities, we cannot get an expression with evaluation greater than 2.667\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>2 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>There is only one optimal division for the given input.</li>\n</ul>\n"}}, "554": {"__typename": "QuestionLightNode", "acRate": 0.5203582999809415, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "554", "isFavor": false, "solutionNum": 619, "title": "Brick Wall", "titleCn": "砖墙", "titleSlug": "brick-wall", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/d2e85988beccb271af4b1a8f4767e4bdf4c085aaf5aaef093347d778e4e138d7-20.png", "slug": "huawei", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/cf2a3ac504c38f16ee9e9e828b4f40ed444dc54e25653145bbfdf9f2f467115a-1587797765803.jpg", "slug": "oracle", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你的面前有一堵矩形的、由 <code>n</code> 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。</p>\n\n<p>你现在要画一条 <strong>自顶向下 </strong>的、穿过 <strong>最少 </strong>砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。<strong>你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。</strong></p>\n\n<p>给你一个二维数组 <code>wall</code> ，该数组包含这堵墙的相关信息。其中，<code>wall[i]</code> 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 <strong>穿过的砖块数量最少</strong> ，并且返回 <strong>穿过的砖块数量</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg\" style=\"width: 493px; height: 577px;\" />\n<pre>\n<strong>输入：</strong>wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>wall = [[1],[1],[1]]\n<strong>输出：</strong>3\n</pre>\n \n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == wall.length</code></li>\n\t<li><code>1 <= n <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= wall[i].length <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= sum(wall[i].length) <= 2 * 10<sup>4</sup></code></li>\n\t<li>对于每一行 <code>i</code> ，<code>sum(wall[i])</code> 是相同的</li>\n\t<li><code>1 <= wall[i][j] <= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>There is a rectangular brick wall in front of you with <code>n</code> rows of bricks. The <code>i<sup>th</sup></code> row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. The total width of each row is the same.</p>\n\n<p>Draw a vertical line from the top to the bottom and cross the least bricks. If your line goes through the edge of a brick, then the brick is not considered as crossed. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.</p>\n\n<p>Given the 2D array <code>wall</code> that contains the information about the wall, return <em>the minimum number of crossed bricks after drawing such a vertical line</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg\" style=\"width: 493px; height: 577px;\" />\n<pre>\n<strong>Input:</strong> wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> wall = [[1],[1],[1]]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == wall.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= wall[i].length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= sum(wall[i].length) &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>sum(wall[i])</code> is the same for each row <code>i</code>.</li>\n\t<li><code>1 &lt;= wall[i][j] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "555": {"__typename": "QuestionLightNode", "acRate": 0.3757884028484232, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "555", "isFavor": false, "solutionNum": 33, "title": "Split Concatenated Strings", "titleCn": "分割连接字符串", "titleSlug": "split-concatenated-strings", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 3, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608354389-Ejnhyo-alibaba.png", "slug": "alibaba", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "556": {"__typename": "QuestionLightNode", "acRate": 0.3683808628740932, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "556", "isFavor": false, "solutionNum": 590, "title": "Next Greater Element III", "titleCn": "下一个更大元素 III", "titleSlug": "next-greater-element-iii", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 39, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个正整数 <code>n</code> ，请你找出符合条件的最小整数，其由重新排列 <code>n</code><strong> </strong>中存在的每位数字组成，并且其值大于 <code>n</code> 。如果不存在这样的正整数，则返回 <code>-1</code> 。</p>\n\n<p><strong>注意</strong> ，返回的整数应当是一个 <strong>32 位整数</strong> ，如果存在满足题意的答案，但不是 <strong>32 位整数</strong> ，同样返回 <code>-1</code> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 12\n<strong>输出：</strong>21\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 21\n<strong>输出：</strong>-1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= n <= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given a positive integer <code>n</code>, find <em>the smallest integer which has exactly the same digits existing in the integer</em> <code>n</code> <em>and is greater in value than</em> <code>n</code>. If no such positive integer exists, return <code>-1</code>.</p>\n\n<p><strong>Note</strong> that the returned integer should fit in <strong>32-bit integer</strong>, if there is a valid answer but it does not fit in <strong>32-bit integer</strong>, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 12\n<strong>Output:</strong> 21\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 21\n<strong>Output:</strong> -1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "557": {"__typename": "QuestionLightNode", "acRate": 0.7366018862467061, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "557", "isFavor": false, "solutionNum": 2661, "title": "Reverse Words in a String III", "titleCn": "反转字符串中的单词 III", "titleSlug": "reverse-words-in-a-string-iii", "topicTags": [{"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 73, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个字符串<meta charset=\"UTF-8\" />&nbsp;<code>s</code>&nbsp;，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"Let's take LeetCode contest\"\n<strong>输出：</strong>\"s'teL ekat edoCteeL tsetnoc\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入：</strong> s = \"Mr Ding\"\n<strong>输出：</strong>\"rM gniD\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong><strong><strong><strong>提示：</strong></strong></strong></strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><meta charset=\"UTF-8\" /><code>s</code>&nbsp;包含可打印的 <strong>ASCII</strong> 字符。</li>\n\t<li><meta charset=\"UTF-8\" /><code>s</code>&nbsp;不包含任何开头或结尾空格。</li>\n\t<li><meta charset=\"UTF-8\" /><code>s</code>&nbsp;里 <strong>至少</strong> 有一个词。</li>\n\t<li><meta charset=\"UTF-8\" /><code>s</code>&nbsp;中的所有单词都用一个空格隔开。</li>\n</ul>\n", "en": "<p>Given a string <code>s</code>, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;Let&#39;s take LeetCode contest&quot;\n<strong>Output:</strong> &quot;s&#39;teL ekat edoCteeL tsetnoc&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;Mr Ding&quot;\n<strong>Output:</strong> &quot;rM gniD&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s</code> contains printable <strong>ASCII</strong> characters.</li>\n\t<li><code>s</code> does not contain any leading or trailing spaces.</li>\n\t<li>There is <strong>at least one</strong> word in <code>s</code>.</li>\n\t<li>All the words in <code>s</code> are separated by a single space.</li>\n</ul>\n"}}, "558": {"__typename": "QuestionLightNode", "acRate": 0.6273157403705184, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "558", "isFavor": false, "solutionNum": 166, "title": "Logical OR of Two Binary Grids Represented as Quad-Trees", "titleCn": "四叉树交集", "titleSlug": "logical-or-of-two-binary-grids-represented-as-quad-trees", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 7, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>二进制矩阵中的所有元素不是 <strong>0</strong> 就是 <strong>1 </strong>。</p>\n\n<p>给你两个四叉树，<code>quadTree1</code> 和 <code>quadTree2</code>。其中 <code>quadTree1</code> 表示一个 <code>n * n</code> 二进制矩阵，而 <code>quadTree2</code> 表示另一个 <code>n * n</code> 二进制矩阵。</p>\n\n<p>请你返回一个表示 <code>n * n</code> 二进制矩阵的四叉树，它是 <code>quadTree1</code> 和 <code>quadTree2</code> 所表示的两个二进制矩阵进行 <strong>按位逻辑或运算</strong> 的结果。</p>\n\n<p>注意，当 <code>isLeaf</code> 为 <strong>False </strong>时，你可以把 <strong>True</strong> 或者 <strong>False</strong> 赋值给节点，两种值都会被判题机制 <strong>接受</strong> 。</p>\n\n<p>四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：</p>\n\n<ul>\n\t<li><code>val</code>：储存叶子结点所代表的区域的值。1 对应 <strong>True</strong>，0 对应 <strong>False</strong>；</li>\n\t<li><code>isLeaf</code>: 当这个节点是一个叶子结点时为 <strong>True</strong>，如果它有 4 个子节点则为 <strong>False</strong> 。</li>\n</ul>\n\n<pre>\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}</pre>\n\n<p>我们可以按以下步骤为二维区域构建四叉树：</p>\n\n<ol>\n\t<li>如果当前网格的值相同（即，全为 <code>0</code> 或者全为 <code>1</code>），将 <code>isLeaf</code> 设为 True ，将 <code>val</code> 设为网格相应的值，并将四个子节点都设为 Null 然后停止。</li>\n\t<li>如果当前网格的值不同，将 <code>isLeaf</code> 设为 False， 将 <code>val</code> 设为任意值，然后如下图所示，将当前网格划分为四个子网格。</li>\n\t<li>使用适当的子网格递归每个子节点。</li>\n</ol>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/new_top.png\" style=\"height: 181px; width: 777px;\" /></p>\n\n<p>如果你想了解更多关于四叉树的内容，可以参考 <a href=\"https://en.wikipedia.org/wiki/Quadtree\">wiki</a> 。</p>\n\n<p><strong>四叉树格式：</strong></p>\n\n<p>输出为使用层序遍历后四叉树的序列化形式，其中 <code>null</code> 表示路径终止符，其下面不存在节点。</p>\n\n<p>它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 <code>[isLeaf, val]</code> 。</p>\n\n<p>如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 True ，则表示它在列表 <code>[isLeaf, val]</code> 中的值为 <strong>1</strong> ；如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 False ，则表示值为 <strong>0 </strong>。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/qt1.png\" style=\"height: 196px; width: 550px;\" /> <img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/qt2.png\" style=\"height: 278px; width: 550px;\" /></p>\n\n<pre>\n<strong>输入：</strong>quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]]\n, quadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n<strong>输出：</strong>[[0,0],[1,1],[1,1],[1,1],[1,0]]\n<strong>解释：</strong>quadTree1 和 quadTree2 如上所示。由四叉树所表示的二进制矩阵也已经给出。\n如果我们对这两个矩阵进行按位逻辑或运算，则可以得到下面的二进制矩阵，由一个作为结果的四叉树表示。\n注意，我们展示的二进制矩阵仅仅是为了更好地说明题意，你无需构造二进制矩阵来获得结果四叉树。\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/qtr.png\" style=\"height: 222px; width: 777px;\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>quadTree1 = [[1,0]]\n, quadTree2 = [[1,0]]\n<strong>输出：</strong>[[1,0]]\n<strong>解释：</strong>两个数所表示的矩阵大小都为 1*1，值全为 0 \n结果矩阵大小为 1*1，值全为 0 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>quadTree1 = [[0,0],[1,0],[1,0],[1,1],[1,1]]\n, quadTree2 = [[0,0],[1,1],[1,1],[1,0],[1,1]]\n<strong>输出：</strong>[[1,1]]\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>quadTree1 = [[0,0],[1,1],[1,0],[1,1],[1,1]]\n, quadTree2 = [[0,0],[1,1],[0,1],[1,1],[1,1],null,null,null,null,[1,1],[1,0],[1,0],[1,1]]\n<strong>输出：</strong>[[0,0],[1,1],[0,1],[1,1],[1,1],null,null,null,null,[1,1],[1,0],[1,0],[1,1]]\n</pre>\n\n<p><strong>示例 5：</strong></p>\n\n<pre>\n<strong>输入：</strong>quadTree1 = [[0,1],[1,0],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n, quadTree2 = [[0,1],[0,1],[1,0],[1,1],[1,0],[1,0],[1,0],[1,1],[1,1]]\n<strong>输出：</strong>[[0,0],[0,1],[0,1],[1,1],[1,0],[1,0],[1,0],[1,1],[1,1],[1,0],[1,0],[1,1],[1,1]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>quadTree1</code> 和 <code>quadTree2</code> 都是符合题目要求的四叉树，每个都代表一个 <code>n * n</code> 的矩阵。</li>\n\t<li><code>n == 2^x</code> ，其中 <code>0 <= x <= 9</code>.</li>\n</ul>\n", "en": "<p>A Binary Matrix is a matrix in which all the elements are either <strong>0</strong> or <strong>1</strong>.</p>\n\n<p>Given <code>quadTree1</code> and <code>quadTree2</code>. <code>quadTree1</code> represents a <code>n * n</code> binary matrix and <code>quadTree2</code> represents another <code>n * n</code> binary matrix.</p>\n\n<p>Return <em>a Quad-Tree</em> representing the <code>n * n</code> binary matrix which is the result of <strong>logical bitwise OR</strong> of the two binary matrixes represented by <code>quadTree1</code> and <code>quadTree2</code>.</p>\n\n<p>Notice that you can assign the value of a node to <strong>True</strong> or <strong>False</strong> when <code>isLeaf</code> is <strong>False</strong>, and both are <strong>accepted</strong> in the answer.</p>\n\n<p>A Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:</p>\n\n<ul>\n\t<li><code>val</code>: True if the node represents a grid of 1&#39;s or False if the node represents a grid of 0&#39;s.</li>\n\t<li><code>isLeaf</code>: True if the node is leaf node on the tree or False if the node has the four children.</li>\n</ul>\n\n<pre>\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}</pre>\n\n<p>We can construct a Quad-Tree from a two-dimensional area using the following steps:</p>\n\n<ol>\n\t<li>If the current grid has the same value (i.e all <code>1&#39;s</code> or all <code>0&#39;s</code>) set <code>isLeaf</code> True and set <code>val</code> to the value of the grid and set the four children to Null and stop.</li>\n\t<li>If the current grid has different values, set <code>isLeaf</code> to False and set <code>val</code> to any value and divide the current grid into four sub-grids as shown in the photo.</li>\n\t<li>Recurse for each of the children with the proper sub-grid.</li>\n</ol>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/new_top.png\" style=\"width: 777px; height: 181px;\" />\n<p>If you want to know more about the Quad-Tree, you can refer to the <a href=\"https://en.wikipedia.org/wiki/Quadtree\">wiki</a>.</p>\n\n<p><strong>Quad-Tree format:</strong></p>\n\n<p>The input/output represents the serialized format of a Quad-Tree using level order traversal, where <code>null</code> signifies a path terminator where no node exists below.</p>\n\n<p>It is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list <code>[isLeaf, val]</code>.</p>\n\n<p>If the value of <code>isLeaf</code> or <code>val</code> is True we represent it as <strong>1</strong> in the list <code>[isLeaf, val]</code> and if the value of <code>isLeaf</code> or <code>val</code> is False we represent it as <strong>0</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/qt1.png\" style=\"width: 550px; height: 196px;\" /> <img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/qt2.png\" style=\"width: 550px; height: 278px;\" />\n<pre>\n<strong>Input:</strong> quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]]\n, quadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n<strong>Output:</strong> [[0,0],[1,1],[1,1],[1,1],[1,0]]\n<strong>Explanation:</strong> quadTree1 and quadTree2 are shown above. You can see the binary matrix which is represented by each Quad-Tree.\nIf we apply logical bitwise OR on the two binary matrices we get the binary matrix below which is represented by the result Quad-Tree.\nNotice that the binary matrices shown are only for illustration, you don&#39;t have to construct the binary matrix to get the result tree.\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/11/qtr.png\" style=\"width: 777px; height: 222px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> quadTree1 = [[1,0]], quadTree2 = [[1,0]]\n<strong>Output:</strong> [[1,0]]\n<strong>Explanation:</strong> Each tree represents a binary matrix of size 1*1. Each matrix contains only zero.\nThe resulting matrix is of size 1*1 with also zero.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>quadTree1</code> and <code>quadTree2</code> are both <strong>valid</strong> Quad-Trees each representing a <code>n * n</code> grid.</li>\n\t<li><code>n == 2<sup>x</sup></code> where <code>0 &lt;= x &lt;= 9</code>.</li>\n</ul>\n"}}, "559": {"__typename": "QuestionLightNode", "acRate": 0.7514600525981682, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "559", "isFavor": false, "solutionNum": 1138, "title": "Maximum Depth of N-ary Tree", "titleCn": "N 叉树的最大深度", "titleSlug": "maximum-depth-of-n-ary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 23, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个 N 叉树，找到其最大深度。</p>\n\n<p class=\"MachineTrans-lang-zh-CN\">最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>\n\n<p class=\"MachineTrans-lang-zh-CN\">N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p>\n\n<p class=\"MachineTrans-lang-zh-CN\"> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,3,2,4,null,5,6]\n<strong>输出：</strong>3\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>输出：</strong>5\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树的深度不会超过 <code>1000</code> 。</li>\n\t<li>树的节点数目位于 <code>[0, 10<sup>4</sup>]</code> 之间。</li>\n</ul>\n", "en": "<p>Given a n-ary tree, find its maximum depth.</p>\n\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n\n<p><em>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>Output:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The total number of nodes is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li>The depth of the n-ary tree is less than or equal to <code>1000</code>.</li>\n</ul>\n"}}, "560": {"__typename": "QuestionLightNode", "acRate": 0.4407121682917247, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "560", "isFavor": false, "solutionNum": 2273, "title": "Subarray Sum Equals K", "titleCn": "和为 K 的子数组", "titleSlug": "subarray-sum-equals-k", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 98, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> 和一个整数&nbsp;<code>k</code> ，请你统计并返回 <em>该数组中和为&nbsp;<code>k</code><strong>&nbsp;</strong>的子数组的个数&nbsp;</em>。</p>\n\n<p>子数组是数组中元素的连续非空序列。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1], k = 2\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], k = 3\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>-10<sup>7</sup> &lt;= k &lt;= 10<sup>7</sup></code></li>\n</ul>\n", "en": "<p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the total number of subarrays whose sum equals to</em> <code>k</code>.</p>\n\n<p>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1,1], k = 2\n<strong>Output:</strong> 2\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3], k = 3\n<strong>Output:</strong> 2\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>-10<sup>7</sup> &lt;= k &lt;= 10<sup>7</sup></code></li>\n</ul>\n"}}, "561": {"__typename": "QuestionLightNode", "acRate": 0.7841860512548567, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "561", "isFavor": false, "solutionNum": 1216, "title": "Array Partition", "titleCn": "数组拆分", "titleSlug": "array-partition", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "pxmt11", "name": "Counting Sort", "slug": "counting-sort", "nameTranslated": "计数排序", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 25, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定长度为&nbsp;<code>2n</code><strong>&nbsp;</strong>的整数数组 <code>nums</code> ，你的任务是将这些数分成&nbsp;<code>n</code><strong> </strong>对, 例如 <code>(a<sub>1</sub>, b<sub>1</sub>), (a<sub>2</sub>, b<sub>2</sub>), ..., (a<sub>n</sub>, b<sub>n</sub>)</code> ，使得从 <code>1</code> 到&nbsp;<code>n</code> 的 <code>min(a<sub>i</sub>, b<sub>i</sub>)</code> 总和最大。</p>\n\n<p>返回该 <strong>最大总和</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,4,3,2]\n<strong>输出：</strong>4\n<strong>解释：</strong>所有可能的分法（忽略元素顺序）为：\n1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) = 1 + 3 = 4\n所以最大总和为 4</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [6,2,6,5,1,2]\n<strong>输出：</strong>9\n<strong>解释：</strong>最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> of <code>2n</code> integers, group these integers into <code>n</code> pairs <code>(a<sub>1</sub>, b<sub>1</sub>), (a<sub>2</sub>, b<sub>2</sub>), ..., (a<sub>n</sub>, b<sub>n</sub>)</code> such that the sum of <code>min(a<sub>i</sub>, b<sub>i</sub>)</code> for all <code>i</code> is <strong>maximized</strong>. Return<em> the maximized sum</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,4,3,2]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> All possible pairings (ignoring the ordering of elements) are:\n1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) = 1 + 3 = 4\nSo the maximum possible sum is 4.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [6,2,6,5,1,2]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums.length == 2 * n</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "562": {"__typename": "QuestionLightNode", "acRate": 0.498923015556442, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "562", "isFavor": false, "solutionNum": 104, "title": "Longest Line of Consecutive One in Matrix", "titleCn": "矩阵中最长的连续1线段", "titleSlug": "longest-line-of-consecutive-one-in-matrix", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 12, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/d2e85988beccb271af4b1a8f4767e4bdf4c085aaf5aaef093347d778e4e138d7-20.png", "slug": "huawei", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "563": {"__typename": "QuestionLightNode", "acRate": 0.6644250605071228, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "563", "isFavor": false, "solutionNum": 800, "title": "Binary Tree Tilt", "titleCn": "二叉树的坡度", "titleSlug": "binary-tree-tilt", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/ca95f7ed3dcc3dba71c4669cf586cfd074ae086c1a1f138ccd1bef80e92edbd3-0.png", "slug": "indeed", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个二叉树的根节点 <code>root</code> ，计算并返回 <strong>整个树 </strong>的坡度 。</p>\n\n<p>一个树的<strong> 节点的坡度 </strong>定义即为，该节点左子树的节点之和和右子树节点之和的 <strong>差的绝对值 </strong>。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p>\n\n<p><strong>整个树</strong> 的坡度就是其所有节点的坡度之和。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg\" style=\"width: 712px; height: 182px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3]\n<strong>输出：</strong>1\n<strong>解释：</strong>\n节点 2 的坡度：|0-0| = 0（没有子节点）\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）\n坡度总和：0 + 0 + 1 = 1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt2.jpg\" style=\"width: 800px; height: 203px;\" />\n<pre>\n<strong>输入：</strong>root = [4,2,9,3,5,null,7]\n<strong>输出：</strong>15\n<strong>解释：</strong>\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 5 的坡度：|0-0| = 0（没有子节点）\n节点 7 的坡度：|0-0| = 0（没有子节点）\n节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）\n节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）\n节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）\n坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt3.jpg\" style=\"width: 800px; height: 293px;\" />\n<pre>\n<strong>输入：</strong>root = [21,7,14,1,1,2,2,3,3]\n<strong>输出：</strong>9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目的范围在 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree, return <em>the sum of every tree node&#39;s <strong>tilt</strong>.</em></p>\n\n<p>The <strong>tilt</strong> of a tree node is the <strong>absolute difference</strong> between the sum of all left subtree node <strong>values</strong> and all right subtree node <strong>values</strong>. If a node does not have a left child, then the sum of the left subtree node <strong>values</strong> is treated as <code>0</code>. The rule is similar if the node does not have a right child.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg\" style=\"width: 712px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> \nTilt of node 2 : |0-0| = 0 (no children)\nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\nSum of every tilt : 0 + 0 + 1 = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt2.jpg\" style=\"width: 800px; height: 203px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,9,3,5,null,7]\n<strong>Output:</strong> 15\n<strong>Explanation:</strong> \nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 5 : |0-0| = 0 (no children)\nTilt of node 7 : |0-0| = 0 (no children)\nTilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)\nTilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)\nTilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)\nSum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/20/tilt3.jpg\" style=\"width: 800px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> root = [21,7,14,1,1,2,2,3,3]\n<strong>Output:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n"}}, "564": {"__typename": "QuestionLightNode", "acRate": 0.3043056311690771, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "564", "isFavor": false, "solutionNum": 265, "title": "Find the Closest Palindrome", "titleCn": "寻找最近的回文数", "titleSlug": "find-the-closest-palindrome", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 30, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个表示整数的字符串&nbsp;<code>n</code> ，返回与它最近的回文整数（不包括自身）。如果不止一个，返回较小的那个。</p>\n\n<p>“最近的”定义为两个整数<strong>差的绝对值</strong>最小。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = \"123\"\n<strong>输出:</strong> \"121\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = \"1\"\n<strong>输出:</strong> \"0\"\n<strong>解释:</strong> 0 和 2是最近的回文，但我们返回最小的，也就是 0。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n.length &lt;= 18</code></li>\n\t<li><code>n</code>&nbsp;只由数字组成</li>\n\t<li><code>n</code>&nbsp;不含前导 0</li>\n\t<li><code>n</code>&nbsp;代表在&nbsp;<code>[1, 10<sup>18</sup>&nbsp;- 1]</code> 范围内的整数</li>\n</ul>\n", "en": "<p>Given a string <code>n</code> representing an integer, return <em>the closest integer (not including itself), which is a palindrome</em>. If there is a tie, return <em><strong>the smaller one</strong></em>.</p>\n\n<p>The closest is defined as the absolute difference minimized between two integers.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = &quot;123&quot;\n<strong>Output:</strong> &quot;121&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = &quot;1&quot;\n<strong>Output:</strong> &quot;0&quot;\n<strong>Explanation:</strong> 0 and 2 are the closest palindromes but we return the smallest which is 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n.length &lt;= 18</code></li>\n\t<li><code>n</code> consists of only digits.</li>\n\t<li><code>n</code> does not have leading zeros.</li>\n\t<li><code>n</code> is representing an integer in the range <code>[1, 10<sup>18</sup> - 1]</code>.</li>\n</ul>\n"}}, "565": {"__typename": "QuestionLightNode", "acRate": 0.6224487283649703, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "565", "isFavor": false, "solutionNum": 465, "title": "Array Nesting", "titleCn": "数组嵌套", "titleSlug": "array-nesting", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 13, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/78703b3d3d17ff1b249303bec7cd53d61ba4d1ff309f4293600ea7efe8b692ae-salesforce.png", "slug": "salesforce", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>索引从<code>0</code>开始长度为<code>N</code>的数组<code>A</code>，包含<code>0</code>到<code>N - 1</code>的所有整数。找到最大的集合<code>S</code>并返回其大小，其中 <code>S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }</code>且遵守以下的规则。</p>\n\n<p>假设选择索引为<code>i</code>的元素<code>A[i]</code>为<code>S</code>的第一个元素，<code>S</code>的下一个元素应该是<code>A[A[i]]</code>，之后是<code>A[A[A[i]]]...</code> 以此类推，不断添加直到<code>S</code>出现重复的元素。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> A = [5,4,0,3,1,6,2]\n<strong>输出:</strong> 4\n<strong>解释:</strong> \nA[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.\n\n其中一种最长的 S[K]:\nS[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n\t<li><code>A</code>中不含有重复的元素。</li>\n</ul>\n", "en": "<p>You are given an integer array <code>nums</code> of length <code>n</code> where <code>nums</code> is a permutation of the numbers in the range <code>[0, n - 1]</code>.</p>\n\n<p>You should build a set <code>s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... }</code> subjected to the following rule:</p>\n\n<ul>\n\t<li>The first element in <code>s[k]</code> starts with the selection of the element <code>nums[k]</code> of <code>index = k</code>.</li>\n\t<li>The next element in <code>s[k]</code> should be <code>nums[nums[k]]</code>, and then <code>nums[nums[nums[k]]]</code>, and so on.</li>\n\t<li>We stop adding right before a duplicate element occurs in <code>s[k]</code>.</li>\n</ul>\n\n<p>Return <em>the longest length of a set</em> <code>s[k]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,4,0,3,1,6,2]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> \nnums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.\nOne of the longest sets s[k]:\ns[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,2]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n\t<li>All the values of <code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n"}}, "566": {"__typename": "QuestionLightNode", "acRate": 0.6455682566777565, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "566", "isFavor": false, "solutionNum": 1388, "title": "Reshape the Matrix", "titleCn": "重塑矩阵", "titleSlug": "reshape-the-matrix", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 19, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>在 MATLAB 中，有一个非常有用的函数 <code>reshape</code> ，它可以将一个&nbsp;<code>m x n</code> 矩阵重塑为另一个大小不同（<code>r x c</code>）的新矩阵，但保留其原始数据。</p>\n\n<p>给你一个由二维数组 <code>mat</code> 表示的&nbsp;<code>m x n</code> 矩阵，以及两个正整数 <code>r</code> 和 <code>c</code> ，分别表示想要的重构的矩阵的行数和列数。</p>\n\n<p>重构后的矩阵需要将原始矩阵的所有元素以相同的<strong> 行遍历顺序 </strong>填充。</p>\n\n<p>如果具有给定参数的 <code>reshape</code> 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/reshape1-grid.jpg\" style=\"width: 613px; height: 173px;\" />\n<pre>\n<strong>输入：</strong>mat = [[1,2],[3,4]], r = 1, c = 4\n<strong>输出：</strong>[[1,2,3,4]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg\" style=\"width: 453px; height: 173px;\" />\n<pre>\n<strong>输入：</strong>mat = [[1,2],[3,4]], r = 2, c = 4\n<strong>输出：</strong>[[1,2],[3,4]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-1000 &lt;= mat[i][j] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= r, c &lt;= 300</code></li>\n</ul>\n", "en": "<p>In MATLAB, there is a handy function called <code>reshape</code> which can reshape an <code>m x n</code> matrix into a new one with a different size <code>r x c</code> keeping its original data.</p>\n\n<p>You are given an <code>m x n</code> matrix <code>mat</code> and two integers <code>r</code> and <code>c</code> representing the number of rows and the number of columns of the wanted reshaped matrix.</p>\n\n<p>The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.</p>\n\n<p>If the <code>reshape</code> operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/reshape1-grid.jpg\" style=\"width: 613px; height: 173px;\" />\n<pre>\n<strong>Input:</strong> mat = [[1,2],[3,4]], r = 1, c = 4\n<strong>Output:</strong> [[1,2,3,4]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg\" style=\"width: 453px; height: 173px;\" />\n<pre>\n<strong>Input:</strong> mat = [[1,2],[3,4]], r = 2, c = 4\n<strong>Output:</strong> [[1,2],[3,4]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-1000 &lt;= mat[i][j] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= r, c &lt;= 300</code></li>\n</ul>\n"}}, "567": {"__typename": "QuestionLightNode", "acRate": 0.4498068652748456, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "567", "isFavor": false, "solutionNum": 2437, "title": "Permutation in String", "titleCn": "字符串的排列", "titleSlug": "permutation-in-string", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 47, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个字符串&nbsp;<code>s1</code>&nbsp;和&nbsp;<code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code><strong>&nbsp;</strong>的排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1 = \"ab\" s2 = \"eidbaooo\"\n<strong>输出：</strong>true\n<strong>解释：</strong>s2 包含 s1 的排列之一 (\"ba\").\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s1= \"ab\" s2 = \"eidboaoo\"\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li>\n</ul>\n", "en": "<p>Given two strings <code>s1</code> and <code>s2</code>, return <code>true</code><em> if </em><code>s2</code><em> contains a permutation of </em><code>s1</code><em>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>In other words, return <code>true</code> if one of <code>s1</code>&#39;s permutations is the substring of <code>s2</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;ab&quot;, s2 = &quot;eidbaooo&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> s2 contains one permutation of s1 (&quot;ba&quot;).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;ab&quot;, s2 = &quot;eidboaoo&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li>\n</ul>\n"}}, "568": {"__typename": "QuestionLightNode", "acRate": 0.560042735042735, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "568", "isFavor": false, "solutionNum": 48, "title": "Maximum Vacation Days", "titleCn": "最大休假天数", "titleSlug": "maximum-vacation-days", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 7, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "569": {"__typename": "QuestionLightNode", "acRate": 0.571840931934744, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "569", "isFavor": false, "solutionNum": 286, "title": "Median Employee Salary", "titleCn": "员工薪水中位数", "titleSlug": "median-employee-salary", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 16, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "570": {"__typename": "QuestionLightNode", "acRate": 0.5661566984088071, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "570", "isFavor": false, "solutionNum": 377, "title": "Managers with at Least 5 Direct Reports", "titleCn": "至少有5名直接下属的经理", "titleSlug": "managers-with-at-least-5-direct-reports", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表:&nbsp;<code>Employee</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| department  | varchar |\n| managerId   | int     |\n+-------------+---------+\nid 是此表的主键（具有唯一值的列）。\n该表的每一行表示雇员的名字、他们的部门和他们的经理的id。\n如果managerId为空，则该员工没有经理。\n没有员工会成为自己的管理者。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写一个解决方案，找出至少有<strong>五个直接下属</strong>的经理。</p>\n\n<p>以 <strong>任意顺序 </strong>返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nEmployee 表:\n+-----+-------+------------+-----------+\n| id  | name  | department | managerId |\n+-----+-------+------------+-----------+\n| 101 | John  | A          | Null      |\n| 102 | Dan   | A          | 101       |\n| 103 | James | A          | 101       |\n| 104 | Amy   | A          | 101       |\n| 105 | Anne  | A          | 101       |\n| 106 | Ron   | B          | 101       |\n+-----+-------+------------+-----------+\n<strong>输出:</strong> \n+------+\n| name |\n+------+\n| John |\n+------+</pre>\n", "en": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| department  | varchar |\n| managerId   | int     |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the name of an employee, their department, and the id of their manager.\nIf managerId is null, then the employee does not have a manager.\nNo employee will be the manager of themself.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find managers with at least <strong>five direct reports</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+-----+-------+------------+-----------+\n| id  | name  | department | managerId |\n+-----+-------+------------+-----------+\n| 101 | John  | A          | null      |\n| 102 | Dan   | A          | 101       |\n| 103 | James | A          | 101       |\n| 104 | Amy   | A          | 101       |\n| 105 | Anne  | A          | 101       |\n| 106 | Ron   | B          | 101       |\n+-----+-------+------------+-----------+\n<strong>Output:</strong> \n+------+\n| name |\n+------+\n| John |\n+------+\n</pre>\n"}}, "571": {"__typename": "QuestionLightNode", "acRate": 0.46722225664539313, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "571", "isFavor": false, "solutionNum": 164, "title": "Find Median Given Frequency of Numbers", "titleCn": "给定数字的频率查询中位数", "titleSlug": "find-median-given-frequency-of-numbers", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1612772581-OTxyOQ-1.png", "slug": "didi", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "572": {"__typename": "QuestionLightNode", "acRate": 0.4765364684116631, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "572", "isFavor": false, "solutionNum": 1438, "title": "Subtree of Another Tree", "titleCn": "另一棵树的子树", "titleSlug": "subtree-of-another-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}, {"id": "ydzvgh", "name": "String Matching", "slug": "string-matching", "nameTranslated": "字符串匹配", "__typename": "CommonTagNode"}, {"id": "xp2e97i", "name": "Hash Function", "slug": "hash-function", "nameTranslated": "哈希函数", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 48, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<div class=\"original__bRMd\">\n<div>\n<p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg\" style=\"width: 532px; height: 400px;\" />\n<pre>\n<strong>输入：</strong>root = [3,4,5,1,2], subRoot = [4,1,2]\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg\" style=\"width: 502px; height: 458px;\" />\n<pre>\n<strong>输入：</strong>root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\n<strong>输出：</strong>false\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>root</code> 树上的节点数量范围是 <code>[1, 2000]</code></li>\n\t<li><code>subRoot</code> 树上的节点数量范围是 <code>[1, 1000]</code></li>\n\t<li><code>-10<sup>4</sup> <= root.val <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= subRoot.val <= 10<sup>4</sup></code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>Given the roots of two binary trees <code>root</code> and <code>subRoot</code>, return <code>true</code> if there is a subtree of <code>root</code> with the same structure and node values of<code> subRoot</code> and <code>false</code> otherwise.</p>\n\n<p>A subtree of a binary tree <code>tree</code> is a tree that consists of a node in <code>tree</code> and all of this node&#39;s descendants. The tree <code>tree</code> could also be considered as a subtree of itself.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg\" style=\"width: 532px; height: 400px;\" />\n<pre>\n<strong>Input:</strong> root = [3,4,5,1,2], subRoot = [4,1,2]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg\" style=\"width: 502px; height: 458px;\" />\n<pre>\n<strong>Input:</strong> root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the <code>root</code> tree is in the range <code>[1, 2000]</code>.</li>\n\t<li>The number of nodes in the <code>subRoot</code> tree is in the range <code>[1, 1000]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= root.val &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= subRoot.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "573": {"__typename": "QuestionLightNode", "acRate": 0.6539649845520082, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "573", "isFavor": false, "solutionNum": 52, "title": "Squirrel Simulation", "titleCn": "松鼠模拟", "titleSlug": "squirrel-simulation", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 3, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E7%99%BE%E5%BA%A6/company_logo", "slug": "baidu", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/4c7a7739a7541bd279b2cd4afb6efaf09754e553f87f46a893f13d68644defd3-Square,_Inc_-_Square_Logo.jpg", "slug": "square", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "574": {"__typename": "QuestionLightNode", "acRate": 0.6604421219805835, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "574", "isFavor": false, "solutionNum": 181, "title": "Winning Candidate", "titleCn": "当选者", "titleSlug": "winning-candidate", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 3, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "575": {"__typename": "QuestionLightNode", "acRate": 0.7054966414177505, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "575", "isFavor": false, "solutionNum": 1132, "title": "Distribute Candies", "titleCn": "分糖果", "titleSlug": "distribute-candies", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/b173524ee10b67f9db094e0205f38410152ac270122075f78d648e6215212c8d-VKmn1iom_400x400.jpg", "slug": "liveramp", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>Alice 有 <code>n</code> 枚糖，其中第 <code>i</code> 枚糖的类型为 <code>candyType[i]</code> 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。</p>\n\n<p>医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 <code>n / 2</code> 即可（<code>n</code> 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。</p>\n\n<p>给你一个长度为 <code>n</code> 的整数数组 <code>candyType</code> ，返回： Alice <em>在仅吃掉 <code>n / 2</code> 枚糖的情况下，可以吃到糖的 <strong>最多</strong> 种类数</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>candyType = [1,1,2,2,3,3]\n<strong>输出：</strong>3\n<strong>解释：</strong>Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>candyType = [1,1,2,3]\n<strong>输出：</strong>2\n<strong>解释：</strong>Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>candyType = [6,6,6,6]\n<strong>输出：</strong>1\n<strong>解释：</strong>Alice 只能吃 4 / 2 = 2 枚糖，尽管她能吃 2 枚，但只能吃到 1 种糖。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == candyType.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>n</code> 是一个偶数</li>\n\t<li><code>-10<sup>5</sup> &lt;= candyType[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>Alice has <code>n</code> candies, where the <code>i<sup>th</sup></code> candy is of type <code>candyType[i]</code>. Alice noticed that she started to gain weight, so she visited a doctor.</p>\n\n<p>The doctor advised Alice to only eat <code>n / 2</code> of the candies she has (<code>n</code> is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor&#39;s advice.</p>\n\n<p>Given the integer array <code>candyType</code> of length <code>n</code>, return <em>the <strong>maximum</strong> number of different types of candies she can eat if she only eats </em><code>n / 2</code><em> of them</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> candyType = [1,1,2,2,3,3]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> candyType = [1,1,2,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> candyType = [6,6,6,6]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == candyType.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>n</code>&nbsp;is even.</li>\n\t<li><code>-10<sup>5</sup> &lt;= candyType[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "576": {"__typename": "QuestionLightNode", "acRate": 0.47038218852714664, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "576", "isFavor": false, "solutionNum": 402, "title": "Out of Boundary Paths", "titleCn": "出界的路径数", "titleSlug": "out-of-boundary-paths", "topicTags": [{"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个大小为 <code>m x n</code> 的网格和一个球。球的起始坐标为 <code>[startRow, startColumn]</code> 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 <strong>最多</strong> 可以移动 <code>maxMove</code> 次球。</p>\n\n<p>给你五个整数 <code>m</code>、<code>n</code>、<code>maxMove</code>、<code>startRow</code> 以及 <code>startColumn</code> ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 <code>10<sup>9</sup> + 7</code> <strong>取余</strong> 后的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_1.png\" style=\"width: 500px; height: 296px;\" />\n<pre>\n<strong>输入：</strong>m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_2.png\" style=\"width: 500px; height: 293px;\" />\n<pre>\n<strong>输入：</strong>m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1\n<strong>输出：</strong>12\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>0 &lt;= maxMove &lt;= 50</code></li>\n\t<li><code>0 &lt;= startRow &lt; m</code></li>\n\t<li><code>0 &lt;= startColumn &lt; n</code></li>\n</ul>\n", "en": "<p>There is an <code>m x n</code> grid with a ball. The ball is initially at the position <code>[startRow, startColumn]</code>. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply <strong>at most</strong> <code>maxMove</code> moves to the ball.</p>\n\n<p>Given the five integers <code>m</code>, <code>n</code>, <code>maxMove</code>, <code>startRow</code>, <code>startColumn</code>, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_1.png\" style=\"width: 500px; height: 296px;\" />\n<pre>\n<strong>Input:</strong> m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\n<strong>Output:</strong> 6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_2.png\" style=\"width: 500px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1\n<strong>Output:</strong> 12\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>0 &lt;= maxMove &lt;= 50</code></li>\n\t<li><code>0 &lt;= startRow &lt; m</code></li>\n\t<li><code>0 &lt;= startColumn &lt; n</code></li>\n</ul>\n"}}, "577": {"__typename": "QuestionLightNode", "acRate": 0.7029438163537294, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "577", "isFavor": false, "solutionNum": 264, "title": "Employee Bonus", "titleCn": "员工奖金", "titleSlug": "employee-bonus", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表：<code>Employee</code>&nbsp;</p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| empId       | int     |\n| name        | varchar |\n| supervisor  | int     |\n| salary      | int     |\n+-------------+---------+\nempId 是该表中具有唯一值的列。\n该表的每一行都表示员工的姓名和 id，以及他们的工资和经理的 id。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表：<code>Bonus</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| empId       | int  |\n| bonus       | int  |\n+-------------+------+\nempId 是该表具有唯一值的列。\nempId 是 Employee 表中 empId 的外键(reference 列)。\n该表的每一行都包含一个员工的 id 和他们各自的奖金。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写解决方案，报告每个奖金 <strong>少于</strong> <code>1000</code> 的员工的姓名和奖金数额。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>\nEmployee table:\n+-------+--------+------------+--------+\n| empId | name   | supervisor | salary |\n+-------+--------+------------+--------+\n| 3     | Brad   | null       | 4000   |\n| 1     | John   | 3          | 1000   |\n| 2     | Dan    | 3          | 2000   |\n| 4     | Thomas | 3          | 4000   |\n+-------+--------+------------+--------+\nBonus table:\n+-------+-------+\n| empId | bonus |\n+-------+-------+\n| 2     | 500   |\n| 4     | 2000  |\n+-------+-------+\n<b>输出：</b>\n+------+-------+\n| name | bonus |\n+------+-------+\n| Brad | null  |\n| John | null  |\n| Dan  | 500   |\n+------+-------+</pre>\n", "en": "<p>Table: <code>Employee</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| empId       | int     |\n| name        | varchar |\n| supervisor  | int     |\n| salary      | int     |\n+-------------+---------+\nempId is the column with unique values for this table.\nEach row of this table indicates the name and the ID of an employee in addition to their salary and the id of their manager.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Bonus</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| empId       | int  |\n| bonus       | int  |\n+-------------+------+\nempId is the column of unique values for this table.\nempId is a foreign key (reference column) to empId from the Employee table.\nEach row of this table contains the id of an employee and their respective bonus.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the name and bonus amount of each employee with a bonus <strong>less than</strong> <code>1000</code>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+-------+--------+------------+--------+\n| empId | name   | supervisor | salary |\n+-------+--------+------------+--------+\n| 3     | Brad   | null       | 4000   |\n| 1     | John   | 3          | 1000   |\n| 2     | Dan    | 3          | 2000   |\n| 4     | Thomas | 3          | 4000   |\n+-------+--------+------------+--------+\nBonus table:\n+-------+-------+\n| empId | bonus |\n+-------+-------+\n| 2     | 500   |\n| 4     | 2000  |\n+-------+-------+\n<strong>Output:</strong> \n+------+-------+\n| name | bonus |\n+------+-------+\n| Brad | null  |\n| John | null  |\n| Dan  | 500   |\n+------+-------+\n</pre>\n"}}, "578": {"__typename": "QuestionLightNode", "acRate": 0.41858370695224856, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "578", "isFavor": false, "solutionNum": 211, "title": "Get Highest Answer Rate Question", "titleCn": "查询回答率最高的问题", "titleSlug": "get-highest-answer-rate-question", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 4, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/9aa36017e6e7765ecd52335a0308ce6b4761145fc14136de808951076ebff401-intel.png", "slug": "intel", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/b0d081e6ac59a6c7ae410f683461e06c26458bfdfb822e65e83fb33845fd8461-a1730e01f36701801abaaa0afc255a51017556b440804-ziOHRW_fw658.png", "slug": "zhihu", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "579": {"__typename": "QuestionLightNode", "acRate": 0.4499086653727594, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "579", "isFavor": false, "solutionNum": 201, "title": "Find Cumulative Salary of an Employee", "titleCn": "查询员工的累计薪水", "titleSlug": "find-cumulative-salary-of-an-employee", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 7, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/b063fd6e06ce7f408968991858ee401239d7b2232b6451a66ad3d278cb1032ef-RWDlntRx.jpeg", "slug": "coursera", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "580": {"__typename": "QuestionLightNode", "acRate": 0.5380349504546138, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "580", "isFavor": false, "solutionNum": 166, "title": "Count Student Number in Departments", "titleCn": "统计各专业学生人数", "titleSlug": "count-student-number-in-departments", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937282-qSKaPF-Unknown-4.jpeg", "slug": "twitter", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1604559404-lBlorc-https---i.forbesimg.com-media-lists-companies-jpmorgan-chase_416x416.jpg", "slug": "jpmorgan", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "581": {"__typename": "QuestionLightNode", "acRate": 0.4216381805415218, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "581", "isFavor": false, "solutionNum": 1423, "title": "Shortest Unsorted Continuous Subarray", "titleCn": "最短无序连续子数组", "titleSlug": "shortest-unsorted-continuous-subarray", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "xeyj5r5", "name": "Monotonic Stack", "slug": "monotonic-stack", "nameTranslated": "单调栈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 42, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> ，你需要找出一个 <strong>连续子数组</strong> ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>\n\n<p>请你找出符合题意的 <strong>最短</strong> 子数组，并输出它的长度。</p>\n\n<p> </p>\n\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,6,4,8,10,9,15]\n<strong>输出：</strong>5\n<strong>解释：</strong>你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> <= nums[i] <= 10<sup>5</sup></code></li>\n</ul>\n\n<p> </p>\n\n<p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(n)</code> 的解决方案吗？</p>\n</div>\n</div>\n", "en": "<p>Given an integer array <code>nums</code>, you need to find one <b>continuous subarray</b> such that if you only sort this subarray in non-decreasing order, then the whole array will be sorted in non-decreasing order.</p>\n\n<p>Return <em>the shortest such subarray and output its length</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,6,4,8,10,9,15]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Can you solve it in <code>O(n)</code> time complexity?"}}, "582": {"__typename": "QuestionLightNode", "acRate": 0.4719593894605981, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "582", "isFavor": false, "solutionNum": 194, "title": "Kill Process", "titleCn": "杀掉进程", "titleSlug": "kill-process", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 22, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "583": {"__typename": "QuestionLightNode", "acRate": 0.6722361977667032, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "583", "isFavor": false, "solutionNum": 1026, "title": "Delete Operation for Two Strings", "titleCn": "两个字符串的删除操作", "titleSlug": "delete-operation-for-two-strings", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个单词&nbsp;<code>word1</code>&nbsp;和<meta charset=\"UTF-8\" />&nbsp;<code>word2</code>&nbsp;，返回使得<meta charset=\"UTF-8\" />&nbsp;<code>word1</code>&nbsp;和&nbsp;<meta charset=\"UTF-8\" />&nbsp;<code>word2</code><em>&nbsp;</em><strong>相同</strong>所需的<strong>最小步数</strong>。</p>\n\n<p><strong>每步&nbsp;</strong>可以删除任意一个字符串中的一个字符。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> word1 = \"sea\", word2 = \"eat\"\n<strong>输出:</strong> 2\n<strong>解释:</strong> 第一步将 \"sea\" 变为 \"ea\" ，第二步将 \"eat \"变为 \"ea\"\n</pre>\n\n<p><strong>示例 &nbsp;2:</strong></p>\n\n<pre>\n<b>输入：</b>word1 = \"leetcode\", word2 = \"etco\"\n<b>输出：</b>4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>1 &lt;= word1.length, word2.length &lt;= 500</code></li>\n\t<li><code>word1</code>&nbsp;和&nbsp;<code>word2</code>&nbsp;只包含小写英文字母</li>\n</ul>\n", "en": "<p>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of <strong>steps</strong> required to make</em> <code>word1</code> <em>and</em> <code>word2</code> <em>the same</em>.</p>\n\n<p>In one <strong>step</strong>, you can delete exactly one character in either string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;sea&quot;, word2 = &quot;eat&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> word1 = &quot;leetcode&quot;, word2 = &quot;etco&quot;\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= word1.length, word2.length &lt;= 500</code></li>\n\t<li><code>word1</code> and <code>word2</code> consist of only lowercase English letters.</li>\n</ul>\n"}}, "584": {"__typename": "QuestionLightNode", "acRate": 0.6649045928380835, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "584", "isFavor": false, "solutionNum": 561, "title": "Find Customer Referee", "titleCn": "寻找用户推荐人", "titleSlug": "find-customer-referee", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 10, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表:&nbsp;<code>Customer</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| referee_id  | int     |\n+-------------+---------+\n在 SQL 中，id 是该表的主键列。\n该表的每一行表示一个客户的 id、姓名以及推荐他们的客户的 id。</pre>\n\n<p>找出那些 <strong>没有被</strong> <code>id = 2</code> 的客户 <strong>推荐</strong> 的客户的姓名。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b> \nCustomer 表:\n+----+------+------------+\n| id | name | referee_id |\n+----+------+------------+\n| 1  | Will | null       |\n| 2  | Jane | null       |\n| 3  | Alex | 2          |\n| 4  | Bill | null       |\n| 5  | Zack | 1          |\n| 6  | Mark | 2          |\n+----+------+------------+\n<b>输出：</b>\n+------+\n| name |\n+------+\n| Will |\n| Jane |\n| Bill |\n| Zack |\n+------+</pre>\n", "en": "<p>Table: <code>Customer</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| referee_id  | int     |\n+-------------+---------+\nIn SQL, id is the primary key column for this table.\nEach row of this table indicates the id of a customer, their name, and the id of the customer who referred them.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Find the names of the customer that are <strong>not referred by</strong> the customer with <code>id = 2</code>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nCustomer table:\n+----+------+------------+\n| id | name | referee_id |\n+----+------+------------+\n| 1  | Will | null       |\n| 2  | Jane | null       |\n| 3  | Alex | 2          |\n| 4  | Bill | null       |\n| 5  | Zack | 1          |\n| 6  | Mark | 2          |\n+----+------+------------+\n<strong>Output:</strong> \n+------+\n| name |\n+------+\n| Will |\n| Jane |\n| Bill |\n| Zack |\n+------+\n</pre>\n"}}, "585": {"__typename": "QuestionLightNode", "acRate": 0.4695363024638023, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "585", "isFavor": false, "solutionNum": 327, "title": "Investments in 2016", "titleCn": "2016年的投资", "titleSlug": "investments-in-2016", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937282-qSKaPF-Unknown-4.jpeg", "slug": "twitter", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><code>Insurance</code> 表：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<pre>\n+-------------+-------+\n| Column Name | Type  |\n+-------------+-------+\n| pid         | int   |\n| tiv_2015    | float |\n| tiv_2016    | float |\n| lat         | float |\n| lon         | float |\n+-------------+-------+\npid 是这张表的主键(具有唯一值的列)。\n表中的每一行都包含一条保险信息，其中：\npid 是投保人的投保编号。\ntiv_2015 是该投保人在 2015 年的总投保金额，tiv_2016 是该投保人在 2016 年的总投保金额。\nlat 是投保人所在城市的纬度。题目数据确保 lat 不为空。\nlon 是投保人所在城市的经度。题目数据确保 lon 不为空。</pre>\n\n<p>&nbsp;</p>\n\n<p>编写解决方案报告 2016 年 (<code>tiv_2016</code>) 所有满足下述条件的投保人的投保金额之和：</p>\n\n<ul>\n\t<li>他在 2015 年的投保额&nbsp;(<code>tiv_2015</code>) 至少跟一个其他投保人在 2015 年的投保额相同。</li>\n\t<li>他所在的城市必须与其他投保人都不同（也就是说&nbsp;(<code>lat, lon</code>) 不能跟其他任何一个投保人完全相同）。</li>\n</ul>\n\n<p><code>tiv_2016</code> 四舍五入的 <strong>两位小数</strong> 。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nInsurance 表：\n+-----+----------+----------+-----+-----+\n| pid | tiv_2015 | tiv_2016 | lat | lon |\n+-----+----------+----------+-----+-----+\n| 1   | 10       | 5        | 10  | 10  |\n| 2   | 20       | 20       | 20  | 20  |\n| 3   | 10       | 30       | 20  | 20  |\n| 4   | 10       | 40       | 40  | 40  |\n+-----+----------+----------+-----+-----+\n<strong>输出：</strong>\n+----------+\n| tiv_2016 |\n+----------+\n| 45.00    |\n+----------+\n<strong>解释：\n</strong>表中的第一条记录和最后一条记录都满足两个条件。\ntiv_2015 值为 10 与第三条和第四条记录相同，且其位置是唯一的。\n\n第二条记录不符合任何一个条件。其 tiv_2015 与其他投保人不同，并且位置与第三条记录相同，这也导致了第三条记录不符合题目要求。\n因此，结果是第一条记录和最后一条记录的 tiv_2016 之和，即 45 。</pre>\n</div>\n</div>\n", "en": "<p>Table: <code>Insurance</code></p>\n\n<pre>\n+-------------+-------+\n| Column Name | Type  |\n+-------------+-------+\n| pid         | int   |\n| tiv_2015    | float |\n| tiv_2016    | float |\n| lat         | float |\n| lon         | float |\n+-------------+-------+\npid is the primary key (column with unique values) for this table.\nEach row of this table contains information about one policy where:\npid is the policyholder&#39;s policy ID.\ntiv_2015 is the total investment value in 2015 and tiv_2016 is the total investment value in 2016.\nlat is the latitude of the policy holder&#39;s city. It&#39;s guaranteed that lat is not NULL.\nlon is the longitude of the policy holder&#39;s city. It&#39;s guaranteed that lon is not NULL.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the sum of all total investment values in 2016 <code>tiv_2016</code>, for all policyholders who:</p>\n\n<ul>\n\t<li>have the same <code>tiv_2015</code> value as one or more other policyholders, and</li>\n\t<li>are not located in the same city as any other policyholder (i.e., the (<code>lat, lon</code>) attribute pairs must be unique).</li>\n</ul>\n\n<p>Round <code>tiv_2016</code> to <strong>two decimal places</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nInsurance table:\n+-----+----------+----------+-----+-----+\n| pid | tiv_2015 | tiv_2016 | lat | lon |\n+-----+----------+----------+-----+-----+\n| 1   | 10       | 5        | 10  | 10  |\n| 2   | 20       | 20       | 20  | 20  |\n| 3   | 10       | 30       | 20  | 20  |\n| 4   | 10       | 40       | 40  | 40  |\n+-----+----------+----------+-----+-----+\n<strong>Output:</strong> \n+----------+\n| tiv_2016 |\n+----------+\n| 45.00    |\n+----------+\n<strong>Explanation:</strong> \nThe first record in the table, like the last record, meets both of the two criteria.\nThe tiv_2015 value 10 is the same as the third and fourth records, and its location is unique.\n\nThe second record does not meet any of the two criteria. Its tiv_2015 is not like any other policyholders and its location is the same as the third record, which makes the third record fail, too.\nSo, the result is the sum of tiv_2016 of the first and last record, which is 45.\n</pre>\n"}}, "586": {"__typename": "QuestionLightNode", "acRate": 0.6763896158630676, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "586", "isFavor": false, "solutionNum": 450, "title": "Customer Placing the Largest Number of Orders", "titleCn": "订单最多的客户", "titleSlug": "customer-placing-the-largest-number-of-orders", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表:&nbsp;<code>Orders</code></p>\n\n<pre>\n+-----------------+----------+\n| Column Name     | Type     |\n+-----------------+----------+\n| order_number    | int      |\n| customer_number | int      |\n+-----------------+----------+\n在 SQL 中，Order_number是该表的主键。\n此表包含关于订单ID和客户ID的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>查找下了 <strong>最多订单</strong>&nbsp;的客户的 <code>customer_number</code> 。</p>\n\n<p>测试用例生成后， <strong>恰好有一个客户</strong> 比任何其他客户下了更多的订单。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nOrders 表:\n+--------------+-----------------+\n| order_number | customer_number |\n+--------------+-----------------+\n| 1            | 1               |\n| 2            | 2               |\n| 3            | 3               |\n| 4            | 3               |\n+--------------+-----------------+\n<strong>输出:</strong> \n+-----------------+\n| customer_number |\n+-----------------+\n| 3               |\n+-----------------+\n<strong>解释:</strong> \ncustomer_number 为 '3' 的顾客有两个订单，比顾客 '1' 或者 '2' 都要多，因为他们只有一个订单。\n所以结果是该顾客的 customer_number ，也就是 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong> 如果有多位顾客订单数并列最多，你能找到他们所有的 <code>customer_number</code> 吗？</p>\n", "en": "<p>Table: <code>Orders</code></p>\n\n<pre>\n+-----------------+----------+\n| Column Name     | Type     |\n+-----------------+----------+\n| order_number    | int      |\n| customer_number | int      |\n+-----------------+----------+\norder_number is the primary key (column with unique values) for this table.\nThis table contains information about the order ID and the customer ID.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the <code>customer_number</code> for the customer who has placed <strong>the largest number of orders</strong>.</p>\n\n<p>The test cases are generated so that <strong>exactly one customer</strong> will have placed more orders than any other customer.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nOrders table:\n+--------------+-----------------+\n| order_number | customer_number |\n+--------------+-----------------+\n| 1            | 1               |\n| 2            | 2               |\n| 3            | 3               |\n| 4            | 3               |\n+--------------+-----------------+\n<strong>Output:</strong> \n+-----------------+\n| customer_number |\n+-----------------+\n| 3               |\n+-----------------+\n<strong>Explanation:</strong> \nThe customer with number 3 has two orders, which is greater than either customer 1 or 2 because each of them only has one order. \nSo the result is customer_number 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if more than one customer has the largest number of orders, can you find all the <code>customer_number</code> in this case?</p>\n"}}, "587": {"__typename": "QuestionLightNode", "acRate": 0.6021236524223925, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "587", "isFavor": false, "solutionNum": 142, "title": "Erect the Fence", "titleCn": "安装栅栏", "titleSlug": "erect-the-fence", "topicTags": [{"id": "vlt55", "name": "Geometry", "slug": "geometry", "nameTranslated": "几何", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个数组 <code>trees</code>，其中 <code>trees[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> 表示树在花园中的位置。</p>\n\n<p>你被要求用最短长度的绳子把整个花园围起来，因为绳子很贵。只有把&nbsp;<strong>所有的树都围起来</strong>，花园才围得很好。</p>\n\n<p>返回<em>恰好位于围栏周边的树木的坐标</em>。</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/erect2-plane.jpg\" style=\"width: 400px;\" /></p>\n\n<pre>\n<strong>输入:</strong> points = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\n<strong>输出:</strong> [[1,1],[2,0],[3,3],[2,4],[4,2]]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/erect1-plane.jpg\" style=\"height: 393px; width: 400px;\" /></p>\n\n<pre>\n<strong>输入:</strong> points = [[1,2],[2,2],[4,2]]\n<strong>输出:</strong> [[4,2],[2,2],[1,2]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注意:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 3000</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 100</code></li>\n\t<li>\n\t<p data-group=\"1-1\">所有给定的点都是&nbsp;<strong>唯一&nbsp;</strong>的。</p>\n\t</li>\n</ul>\n", "en": "<p>You are given an array <code>trees</code> where <code>trees[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents the location of a tree in the garden.</p>\n\n<p>Fence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if <strong>all the trees are enclosed</strong>.</p>\n\n<p>Return <em>the coordinates of trees that are exactly located on the fence perimeter</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/erect2-plane.jpg\" style=\"width: 400px; height: 393px;\" />\n<pre>\n<strong>Input:</strong> trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]\n<strong>Output:</strong> [[1,1],[2,0],[4,2],[3,3],[2,4]]\n<strong>Explanation:</strong> All the trees will be on the perimeter of the fence except the tree at [2, 2], which will be inside the fence.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/24/erect1-plane.jpg\" style=\"width: 400px; height: 393px;\" />\n<pre>\n<strong>Input:</strong> trees = [[1,2],[2,2],[4,2]]\n<strong>Output:</strong> [[4,2],[2,2],[1,2]]\n<strong>Explanation:</strong> The fence forms a line that passes through all the trees.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= trees.length &lt;= 3000</code></li>\n\t<li><code>trees[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 100</code></li>\n\t<li>All the given positions are <strong>unique</strong>.</li>\n</ul>\n"}}, "588": {"__typename": "QuestionLightNode", "acRate": 0.4380984952120383, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "588", "isFavor": false, "solutionNum": 58, "title": "Design In-Memory File System", "titleCn": "设计内存文件系统", "titleSlug": "design-in-memory-file-system", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 35, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1711005148-NDGnlq-Coinbase.png", "slug": "coinbase", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "589": {"__typename": "QuestionLightNode", "acRate": 0.7589362678308261, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "589", "isFavor": false, "solutionNum": 1253, "title": "N-ary Tree Preorder Traversal", "titleCn": "N 叉树的前序遍历", "titleSlug": "n-ary-tree-preorder-traversal", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个 n&nbsp;叉树的根节点 <meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，返回 <em>其节点值的<strong> 前序遍历</strong></em> 。</p>\n\n<p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p>\n\n<p><br />\n<strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"height: 193px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,3,2,4,null,5,6]\n<strong>输出：</strong>[1,3,5,6,2,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"height: 272px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>输出：</strong>[1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>节点总数在范围<meta charset=\"UTF-8\" />&nbsp;<code>[0, 10<sup>4</sup>]</code>内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>n 叉树的高度小于或等于 <code>1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>递归法很简单，你可以使用迭代法完成此题吗?</p>\n", "en": "<p>Given the <code>root</code> of an n-ary tree, return <em>the preorder traversal of its nodes&#39; values</em>.</p>\n\n<p>Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n<strong>Output:</strong> [1,3,5,6,2,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>Output:</strong> [1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>The height of the n-ary tree is less than or equal to <code>1000</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\n"}}, "590": {"__typename": "QuestionLightNode", "acRate": 0.7954250754727372, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "590", "isFavor": false, "solutionNum": 1010, "title": "N-ary Tree Postorder Traversal", "titleCn": "N 叉树的后序遍历", "titleSlug": "n-ary-tree-postorder-traversal", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 16, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个 n&nbsp;叉树的根节点<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，返回 <em>其节点值的<strong> 后序遍历</strong></em> 。</p>\n\n<p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"height: 193px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,3,2,4,null,5,6]\n<strong>输出：</strong>[5,6,3,2,4,1]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"height: 269px; width: 296px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>输出：</strong>[2,6,14,11,7,3,12,8,4,13,9,10,5,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>节点总数在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>n 叉树的高度小于或等于 <code>1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>递归法很简单，你可以使用迭代法完成此题吗?</p>\n", "en": "<p>Given the <code>root</code> of an n-ary tree, return <em>the postorder traversal of its nodes&#39; values</em>.</p>\n\n<p>Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n<strong>Output:</strong> [5,6,3,2,4,1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>Output:</strong> [2,6,14,11,7,3,12,8,4,13,9,10,5,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>The height of the n-ary tree is less than or equal to <code>1000</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\n"}}, "591": {"__typename": "QuestionLightNode", "acRate": 0.5181905083220872, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "591", "isFavor": false, "solutionNum": 197, "title": "Tag Validator", "titleCn": "标签验证器", "titleSlug": "tag-validator", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：</p>\n\n<ol>\n\t<li>代码必须被<strong>合法的闭合标签</strong>包围。否则，代码是无效的。</li>\n\t<li><strong>闭合标签</strong>（不一定合法）要严格符合格式：<code>&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;</code>。其中，<code>&lt;TAG_NAME&gt;</code>是起始标签，<code>&lt;/TAG_NAME&gt;</code>是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当&nbsp;TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是<strong>合法的</strong>。</li>\n\t<li><strong>合法的</strong>&nbsp;<code>TAG_NAME</code>&nbsp;仅含有<strong>大写字母</strong>，长度在范围 [1,9] 之间。否则，该&nbsp;<code>TAG_NAME</code>&nbsp;是<strong>不合法的</strong>。</li>\n\t<li><strong>合法的</strong>&nbsp;<code>TAG_CONTENT</code>&nbsp;可以包含其他<strong>合法的闭合标签</strong>，<strong>cdata</strong>&nbsp;（请参考规则7）和任意字符（注意参考规则1）<strong>除了</strong>不匹配的<code>&lt;</code>、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则，<code>TAG_CONTENT</code>&nbsp;是<strong>不合法的</strong>。</li>\n\t<li>一个起始标签，如果没有具有相同&nbsp;TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。</li>\n\t<li>一个<code>&lt;</code>，如果你找不到一个后续的<code>&gt;</code>与之匹配，是不合法的。并且当你找到一个<code>&lt;</code>或<code>&lt;/</code>时，所有直到下一个<code>&gt;</code>的前的字符，都应当被解析为&nbsp;TAG_NAME（不一定合法）。</li>\n\t<li>cdata 有如下格式：<code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code>。<code>CDATA_CONTENT</code>&nbsp;的范围被定义成&nbsp;<code>&lt;![CDATA[</code>&nbsp;和<strong>后续的第一个</strong>&nbsp;<code>]]&gt;</code>之间的字符。</li>\n\t<li><code>CDATA_CONTENT</code>&nbsp;可以包含<strong>任意字符</strong>。cdata 的功能是阻止验证器解析<code>CDATA_CONTENT</code>，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为<strong>常规字符</strong>。</li>\n</ol>\n\n<p><strong>合法代码的例子:</strong></p>\n\n<pre>\n<strong>输入:</strong> &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;&quot;\n\n<strong>输出:</strong> True\n\n<strong>解释:</strong> \n\n代码被包含在了闭合的标签内： &lt;DIV&gt; 和 &lt;/DIV&gt; 。\n\nTAG_NAME 是合法的，TAG_CONTENT 包含了一些字符和 cdata 。 \n\n即使 CDATA_CONTENT 含有不匹配的起始标签和不合法的 TAG_NAME，它应该被视为普通的文本，而不是标签。\n\n所以 TAG_CONTENT 是合法的，因此代码是合法的。最终返回True。\n\n\n<strong>输入:</strong> &quot;&lt;DIV&gt;&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;/DIV&gt;&quot;\n\n<strong>输出:</strong> True\n\n<strong>解释:</strong>\n\n我们首先将代码分割为： start_tag|tag_content|end_tag 。\n\nstart_tag -&gt; <strong>&quot;&lt;DIV&gt;&quot;</strong>\n\nend_tag -&gt; <strong>&quot;&lt;/DIV&gt;&quot;</strong>\n\ntag_content 也可被分割为： text1|cdata|text2 。\n\ntext1 -&gt; <strong>&quot;&gt;&gt;  ![cdata[]] &quot;</strong>\n\ncdata -&gt; <strong>&quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot;</strong> ，其中 CDATA_CONTENT 为 <strong>&quot;&lt;div&gt;]&gt;&quot;</strong>\n\ntext2 -&gt; <strong>&quot;]]&gt;&gt;]&quot;</strong>\n\n\nstart_tag <strong>不</strong>是 <strong>&quot;&lt;DIV&gt;&gt;&gt;&quot;</strong> 的原因参照规则 6 。\ncdata <strong>不</strong>是 <strong>&quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot;</strong> 的原因参照规则 7 。\n</pre>\n\n<p><strong>不合法代码的例子:</strong></p>\n\n<pre>\n<strong>输入:</strong> &quot;&lt;A&gt;  &lt;B&gt; &lt;/A&gt;   &lt;/B&gt;&quot;\n<strong>输出:</strong> False\n<strong>解释:</strong> 不合法。如果 &quot;&lt;A&gt;&quot; 是闭合的，那么 &quot;&lt;B&gt;&quot; 一定是不匹配的，反之亦然。\n\n<strong>输入:</strong> &quot;&lt;DIV&gt;  div tag is not closed  &lt;DIV&gt;&quot;\n<strong>输出:</strong> False\n\n<strong>输入:</strong> &quot;&lt;DIV&gt;  unmatched &lt;  &lt;/DIV&gt;&quot;\n<strong>输出:</strong> False\n\n<strong>输入:</strong> &quot;&lt;DIV&gt; closed tags with invalid tag name  &lt;b&gt;123&lt;/b&gt; &lt;/DIV&gt;&quot;\n<strong>输出:</strong> False\n\n<strong>输入:</strong> &quot;&lt;DIV&gt; unmatched tags with invalid tag name  &lt;/1234567890&gt; and &lt;CDATA[[]]&gt;  &lt;/DIV&gt;&quot;\n<strong>输出:</strong> False\n\n<strong>输入:</strong> &quot;&lt;DIV&gt;  unmatched start tag &lt;B&gt;  and unmatched end tag &lt;/C&gt;  &lt;/DIV&gt;&quot;\n<strong>输出:</strong> False\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>为简明起见，你可以假设输入的代码（包括提到的<strong>任意字符</strong>）只包含<code>数字</code>, <font color=\"#c7254e\" face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"background-color:#f9f2f4; font-size:12.6px\">字母</span></font>, <code>&#39;&lt;&#39;</code>,<code>&#39;&gt;&#39;</code>,<code>&#39;/&#39;</code>,<code>&#39;!&#39;</code>,<code>&#39;[&#39;</code>,<code>&#39;]&#39;</code>和<code>&#39; &#39;</code>。</li>\n</ol>\n", "en": "<p>Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid.</p>\n\n<p>A code snippet is valid if all the following rules hold:</p>\n\n<ol>\n\t<li>The code must be wrapped in a <b>valid closed tag</b>. Otherwise, the code is invalid.</li>\n\t<li>A <b>closed tag</b> (not necessarily valid) has exactly the following format : <code>&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;</code>. Among them, <code>&lt;TAG_NAME&gt;</code> is the start tag, and <code>&lt;/TAG_NAME&gt;</code> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is <b>valid</b> if and only if the TAG_NAME and TAG_CONTENT are valid.</li>\n\t<li>A <b>valid</b> <code>TAG_NAME</code> only contain <b>upper-case letters</b>, and has length in range [1,9]. Otherwise, the <code>TAG_NAME</code> is <b>invalid</b>.</li>\n\t<li>A <b>valid</b> <code>TAG_CONTENT</code> may contain other <b>valid closed tags</b>, <b>cdata</b> and any characters (see note1) <b>EXCEPT</b> unmatched <code>&lt;</code>, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the <code>TAG_CONTENT</code> is <b>invalid</b>.</li>\n\t<li>A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.</li>\n\t<li>A <code>&lt;</code> is unmatched if you cannot find a subsequent <code>&gt;</code>. And when you find a <code>&lt;</code> or <code>&lt;/</code>, all the subsequent characters until the next <code>&gt;</code> should be parsed as TAG_NAME (not necessarily valid).</li>\n\t<li>The cdata has the following format : <code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code>. The range of <code>CDATA_CONTENT</code> is defined as the characters between <code>&lt;![CDATA[</code> and the <b>first subsequent</b> <code>]]&gt;</code>.</li>\n\t<li><code>CDATA_CONTENT</code> may contain <b>any characters</b>. The function of cdata is to forbid the validator to parse <code>CDATA_CONTENT</code>, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as <b>regular characters</b>.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> code = &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> \nThe code is wrapped in a closed tag : &lt;DIV&gt; and &lt;/DIV&gt;. \nThe TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. \nAlthough CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag.\nSo TAG_CONTENT is valid, and then the code is valid. Thus return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> code = &quot;&lt;DIV&gt;&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;/DIV&gt;&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong>\nWe first separate the code into : start_tag|tag_content|end_tag.\nstart_tag -&gt; <b>&quot;&lt;DIV&gt;&quot;</b>\nend_tag -&gt; <b>&quot;&lt;/DIV&gt;&quot;</b>\ntag_content could also be separated into : text1|cdata|text2.\ntext1 -&gt; <b>&quot;&gt;&gt;  ![cdata[]] &quot;</b>\ncdata -&gt; <b>&quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot;</b>, where the CDATA_CONTENT is <b>&quot;&lt;div&gt;]&gt;&quot;</b>\ntext2 -&gt; <b>&quot;]]&gt;&gt;]&quot;</b>\nThe reason why start_tag is NOT <b>&quot;&lt;DIV&gt;&gt;&gt;&quot;</b> is because of the rule 6.\nThe reason why cdata is NOT <b>&quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot;</b> is because of the rule 7.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> code = &quot;&lt;A&gt;  &lt;B&gt; &lt;/A&gt;   &lt;/B&gt;&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Unbalanced. If &quot;&lt;A&gt;&quot; is closed, then &quot;&lt;B&gt;&quot; must be unmatched, and vice versa.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= code.length &lt;= 500</code></li>\n\t<li><code>code</code> consists of English letters, digits, <code>&#39;&lt;&#39;</code>, <code>&#39;&gt;&#39;</code>, <code>&#39;/&#39;</code>, <code>&#39;!&#39;</code>, <code>&#39;[&#39;</code>, <code>&#39;]&#39;</code>, <code>&#39;.&#39;</code>, and <code>&#39; &#39;</code>.</li>\n</ul>\n"}}, "592": {"__typename": "QuestionLightNode", "acRate": 0.5970067913138257, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "592", "isFavor": false, "solutionNum": 489, "title": "Fraction Addition and Subtraction", "titleCn": "分数加减运算", "titleSlug": "fraction-addition-and-subtraction", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 12, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1bb96b21aee51658cac9909be80203243b75485220d391f31b842da60df0bc83-512x512bb.jpg", "slug": "ixl", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个表示分数加减运算的字符串&nbsp;<code>expression</code>&nbsp;，你需要返回一个字符串形式的计算结果。&nbsp;</p>\n\n<p>这个结果应该是不可约分的分数，即<a href=\"https://baike.baidu.com/item/%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0\" target=\"_blank\">最简分数</a>。&nbsp;如果最终结果是一个整数，例如&nbsp;<code>2</code>，你需要将它转换成分数形式，其分母为&nbsp;<code>1</code>。所以在上述例子中, <code>2</code>&nbsp;应该被转换为&nbsp;<code>2/1</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;<code>expression</code>&nbsp;= \"-1/2+1/2\"\n<strong>输出:</strong> \"0/1\"\n</pre>\n\n<p><strong>&nbsp;示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;<code>expression</code>&nbsp;= \"-1/2+1/2+1/3\"\n<strong>输出:</strong> \"1/3\"\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong>&nbsp;<code>expression</code>&nbsp;= \"1/3-1/2\"\n<strong>输出:</strong> \"-1/6\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>输入和输出字符串只包含&nbsp;<code>'0'</code> 到&nbsp;<code>'9'</code>&nbsp;的数字，以及&nbsp;<code>'/'</code>, <code>'+'</code> 和&nbsp;<code>'-'</code>。&nbsp;</li>\n\t<li>输入和输出分数格式均为&nbsp;<code>±分子/分母</code>。如果输入的第一个分数或者输出的分数是正数，则&nbsp;<code>'+'</code>&nbsp;会被省略掉。</li>\n\t<li>输入只包含合法的<strong>最简分数</strong>，每个分数的<strong>分子</strong>与<strong>分母</strong>的范围是&nbsp;&nbsp;[1,10]。&nbsp;如果分母是1，意味着这个分数实际上是一个整数。</li>\n\t<li>输入的分数个数范围是 [1,10]。</li>\n\t<li><strong>最终结果</strong>的分子与分母保证是 32 位整数范围内的有效整数。</li>\n</ul>\n", "en": "<p>Given a string <code>expression</code> representing an expression of fraction addition and subtraction, return the calculation result in string format.</p>\n\n<p>The final result should be an <a href=\"https://en.wikipedia.org/wiki/Irreducible_fraction\" target=\"_blank\">irreducible fraction</a>. If your final result is an integer, change it to the format of a fraction that has a denominator <code>1</code>. So in this case, <code>2</code> should be converted to <code>2/1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;-1/2+1/2&quot;\n<strong>Output:</strong> &quot;0/1&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;-1/2+1/2+1/3&quot;\n<strong>Output:</strong> &quot;1/3&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;1/3-1/2&quot;\n<strong>Output:</strong> &quot;-1/6&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The input string only contains <code>&#39;0&#39;</code> to <code>&#39;9&#39;</code>, <code>&#39;/&#39;</code>, <code>&#39;+&#39;</code> and <code>&#39;-&#39;</code>. So does the output.</li>\n\t<li>Each fraction (input and output) has the format <code>&plusmn;numerator/denominator</code>. If the first input fraction or the output is positive, then <code>&#39;+&#39;</code> will be omitted.</li>\n\t<li>The input only contains valid <strong>irreducible fractions</strong>, where the <strong>numerator</strong> and <strong>denominator</strong> of each fraction will always be in the range <code>[1, 10]</code>. If the denominator is <code>1</code>, it means this fraction is actually an integer in a fraction format defined above.</li>\n\t<li>The number of given fractions will be in the range <code>[1, 10]</code>.</li>\n\t<li>The numerator and denominator of the <strong>final result</strong> are guaranteed to be valid and in the range of <strong>32-bit</strong> int.</li>\n</ul>\n"}}, "593": {"__typename": "QuestionLightNode", "acRate": 0.47072007211989936, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "593", "isFavor": false, "solutionNum": 594, "title": "Valid Square", "titleCn": "有效的正方形", "titleSlug": "valid-square", "topicTags": [{"id": "vlt55", "name": "Geometry", "slug": "geometry", "nameTranslated": "几何", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 27, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/4f74c9a5a47e4f0e7f957b46cf24dcd26f53415fb95f090f969cda9618aa9f19-pure-storage.jpg", "slug": "pure-storage", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定2D空间中四个点的坐标&nbsp;<code>p1</code>,&nbsp;<code>p2</code>,&nbsp;<code>p3</code>&nbsp;和&nbsp;<code>p4</code>，如果这四个点构成一个正方形，则返回 <code>true</code> 。</p>\n\n<p>点的坐标&nbsp;<code>p<sub>i</sub></code> 表示为 <code>[xi, yi]</code> 。 <code>输入没有任何顺序</code> 。</p>\n\n<p>一个 <strong>有效的正方形</strong> 有四条等边和四个等角(90度角)。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\n<strong>输出:</strong> True\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入：</strong>p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]\n<b>输出：</b>false\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<b>输入：</b>p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]\n<b>输出：</b>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>p1.length == p2.length == p3.length == p4.length == 2</code></li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given the coordinates of four points in 2D space <code>p1</code>, <code>p2</code>, <code>p3</code> and <code>p4</code>, return <code>true</code> <em>if the four points construct a square</em>.</p>\n\n<p>The coordinate of a point <code>p<sub>i</sub></code> is represented as <code>[x<sub>i</sub>, y<sub>i</sub>]</code>. The input is <strong>not</strong> given in any order.</p>\n\n<p>A <strong>valid square</strong> has four equal sides with positive length and four equal angles (90-degree angles).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>p1.length == p2.length == p3.length == p4.length == 2</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "594": {"__typename": "QuestionLightNode", "acRate": 0.5646580741502344, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "594", "isFavor": false, "solutionNum": 753, "title": "Longest Harmonious Subsequence", "titleCn": "最长和谐子序列", "titleSlug": "longest-harmonious-subsequence", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "pxpqcm", "name": "Counting", "slug": "counting", "nameTranslated": "计数", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 19, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 <strong>正好是 <code>1</code></strong> 。</p>\n\n<p>现在，给你一个整数数组 <code>nums</code> ，请你在所有可能的子序列中找到最长的和谐子序列的长度。</p>\n\n<p>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,2,2,5,2,3,7]\n<strong>输出：</strong>5\n<strong>解释：</strong>最长的和谐子序列是 [3,2,2,2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1,1]\n<strong>输出：</strong>0\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>We define a harmonious array as an array where the difference between its maximum value and its minimum value is <b>exactly</b> <code>1</code>.</p>\r\n\r\n<p>Given an integer array <code>nums</code>, return <em>the length of its longest harmonious subsequence among all its possible subsequences</em>.</p>\r\n\r\n<p>A <strong>subsequence</strong> of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,3,2,2,5,2,3,7]\r\n<strong>Output:</strong> 5\r\n<strong>Explanation:</strong> The longest harmonious subsequence is [3,2,2,2,3].\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,2,3,4]\r\n<strong>Output:</strong> 2\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,1,1,1]\r\n<strong>Output:</strong> 0\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\r\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\r\n</ul>"}}, "595": {"__typename": "QuestionLightNode", "acRate": 0.6644103997675679, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "595", "isFavor": false, "solutionNum": 704, "title": "Big Countries", "titleCn": "大的国家", "titleSlug": "big-countries", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 30, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><code>World</code> 表：</p>\n\n<div class=\"top-view__1vxA\">\n<div class=\"original__bRMd\">\n<div>\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| name        | varchar |\n| continent   | varchar |\n| area        | int     |\n| population  | int     |\n| gdp         | bigint  |\n+-------------+---------+\n<code>name</code> 是该表的主键（具有唯一值的列）。\n这张表的每一行提供：国家名称、所属大陆、面积、人口和 GDP 值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>如果一个国家满足下述两个条件之一，则认为该国是 <strong>大国</strong> ：</p>\n\n<ul>\n\t<li>面积至少为 300 万平方公里（即，<code>3000000 km<sup>2</sup></code>），或者</li>\n\t<li>人口至少为 2500 万（即 <code>25000000</code>）</li>\n</ul>\n\n<p>编写解决方案找出&nbsp;<strong>大国</strong> 的国家名称、人口和面积。</p>\n\n<p>按 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>返回结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nWorld 表：\n+-------------+-----------+---------+------------+--------------+\n| name        | continent | area    | population | gdp          |\n+-------------+-----------+---------+------------+--------------+\n| Afghanistan | Asia      | 652230  | 25500100   | 20343000000  |\n| Albania     | Europe    | 28748   | 2831741    | 12960000000  |\n| Algeria     | Africa    | 2381741 | 37100000   | 188681000000 |\n| Andorra     | Europe    | 468     | 78115      | 3712000000   |\n| Angola      | Africa    | 1246700 | 20609294   | 100990000000 |\n+-------------+-----------+---------+------------+--------------+\n<strong>输出：</strong>\n+-------------+------------+---------+\n| name        | population | area    |\n+-------------+------------+---------+\n| Afghanistan | 25500100   | 652230  |\n| Algeria     | 37100000   | 2381741 |\n+-------------+------------+---------+\n</pre>\n</div>\n</div>\n</div>\n", "en": "<p>Table: <code>World</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| name        | varchar |\n| continent   | varchar |\n| area        | int     |\n| population  | int     |\n| gdp         | bigint  |\n+-------------+---------+\nname is the primary key (column with unique values) for this table.\nEach row of this table gives information about the name of a country, the continent to which it belongs, its area, the population, and its GDP value.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>A country is <strong>big</strong> if:</p>\n\n<ul>\n\t<li>it has an area of at least&nbsp;three million (i.e., <code>3000000 km<sup>2</sup></code>), or</li>\n\t<li>it has a population of at least&nbsp;twenty-five million (i.e., <code>25000000</code>).</li>\n</ul>\n\n<p>Write a solution to find the name, population, and area of the <strong>big countries</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nWorld table:\n+-------------+-----------+---------+------------+--------------+\n| name        | continent | area    | population | gdp          |\n+-------------+-----------+---------+------------+--------------+\n| Afghanistan | Asia      | 652230  | 25500100   | 20343000000  |\n| Albania     | Europe    | 28748   | 2831741    | 12960000000  |\n| Algeria     | Africa    | 2381741 | 37100000   | 188681000000 |\n| Andorra     | Europe    | 468     | 78115      | 3712000000   |\n| Angola      | Africa    | 1246700 | 20609294   | 100990000000 |\n+-------------+-----------+---------+------------+--------------+\n<strong>Output:</strong> \n+-------------+------------+---------+\n| name        | population | area    |\n+-------------+------------+---------+\n| Afghanistan | 25500100   | 652230  |\n| Algeria     | 37100000   | 2381741 |\n+-------------+------------+---------+\n</pre>\n"}}, "596": {"__typename": "QuestionLightNode", "acRate": 0.5342354829081173, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "596", "isFavor": false, "solutionNum": 554, "title": "Classes More Than 5 Students", "titleCn": "超过5名学生的课", "titleSlug": "classes-more-than-5-students", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/c0becdcc322c6ffa7de04f9429fea3cbaa045735fa1771c637d79828358dc8ef-41MVF9VYURL.png", "slug": "yahoo", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表:&nbsp;<code>Courses</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| student     | varchar |\n| class       | varchar |\n+-------------+---------+\n在 SQL 中，(student, class)是该表的主键列。\n该表的每一行表示学生的名字和他们注册的班级。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>查询&nbsp;<strong>至少有5个学生</strong> 的所有班级。</p>\n\n<p>以 <strong>任意顺序 </strong>返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nCourses table:\n+---------+----------+\n| student | class    |\n+---------+----------+\n| A       | Math     |\n| B       | English  |\n| C       | Math     |\n| D       | Biology  |\n| E       | Math     |\n| F       | Computer |\n| G       | Math     |\n| H       | Math     |\n| I       | Math     |\n+---------+----------+\n<strong>输出:</strong> \n+---------+ \n| class &nbsp; | \n+---------+ \n| Math &nbsp; &nbsp;| \n+---------+\n<strong>解释: </strong>\n-数学课有6个学生，所以我们包括它。\n-英语课有1名学生，所以我们不包括它。\n-生物课有1名学生，所以我们不包括它。\n-计算机课有1个学生，所以我们不包括它。</pre>\n", "en": "<p>Table: <code>Courses</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| student     | varchar |\n| class       | varchar |\n+-------------+---------+\n(student, class) is the primary key (combination of columns with unique values) for this table.\nEach row of this table indicates the name of a student and the class in which they are enrolled.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find all the classes that have <strong>at least five students</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nCourses table:\n+---------+----------+\n| student | class    |\n+---------+----------+\n| A       | Math     |\n| B       | English  |\n| C       | Math     |\n| D       | Biology  |\n| E       | Math     |\n| F       | Computer |\n| G       | Math     |\n| H       | Math     |\n| I       | Math     |\n+---------+----------+\n<strong>Output:</strong> \n+---------+\n| class   |\n+---------+\n| Math    |\n+---------+\n<strong>Explanation:</strong> \n- Math has 6 students, so we include it.\n- English has 1 student, so we do not include it.\n- Biology has 1 student, so we do not include it.\n- Computer has 1 student, so we do not include it.\n</pre>\n"}}, "597": {"__typename": "QuestionLightNode", "acRate": 0.42834822823573526, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "597", "isFavor": false, "solutionNum": 138, "title": "Friend Requests I: Overall Acceptance Rate", "titleCn": "好友申请 I：总体通过率", "titleSlug": "friend-requests-i-overall-acceptance-rate", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 6, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "598": {"__typename": "QuestionLightNode", "acRate": 0.5823295142431139, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "598", "isFavor": false, "solutionNum": 665, "title": "Range Addition II", "titleCn": "区间加法 II", "titleSlug": "range-addition-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 12, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1bb96b21aee51658cac9909be80203243b75485220d391f31b842da60df0bc83-512x512bb.jpg", "slug": "ixl", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个 <code>m x&nbsp;n</code> 的矩阵&nbsp;<code>M</code><strong> </strong>和一个操作数组 <code>op</code> 。矩阵初始化时所有的单元格都为 <code>0</code> 。<code>ops[i] = [ai, bi]</code> 意味着当所有的 <code>0 &lt;= x &lt; ai</code> 和 <code>0 &lt;= y &lt; bi</code> 时， <code>M[x][y]</code> 应该加 1。</p>\n\n<p>在&nbsp;<em>执行完所有操作后</em>&nbsp;，计算并返回&nbsp;<em>矩阵中最大整数的个数</em>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/02/ex1.jpg\" style=\"height: 176px; width: 750px;\" /></p>\n\n<pre>\n<strong>输入:</strong> m = 3, n = 3，ops = [[2,2],[3,3]]\n<strong>输出:</strong> 4\n<strong>解释:</strong> M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]\n<strong>输出:</strong> 4\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> m = 3, n = 3, ops = []\n<strong>输出:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= ops.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>ops[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>&nbsp;&lt;= m</code></li>\n\t<li><code>1 &lt;= b<sub>i</sub>&nbsp;&lt;= n</code></li>\n</ul>\n", "en": "<p>You are given an <code>m x n</code> matrix <code>M</code> initialized with all <code>0</code>&#39;s and an array of operations <code>ops</code>, where <code>ops[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> means <code>M[x][y]</code> should be incremented by one for all <code>0 &lt;= x &lt; a<sub>i</sub></code> and <code>0 &lt;= y &lt; b<sub>i</sub></code>.</p>\n\n<p>Count and return <em>the number of maximum integers in the matrix after performing all the operations</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/02/ex1.jpg\" style=\"width: 750px; height: 176px;\" />\n<pre>\n<strong>Input:</strong> m = 3, n = 3, ops = [[2,2],[3,3]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The maximum integer in M is 2, and there are four of it in M. So return 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> m = 3, n = 3, ops = []\n<strong>Output:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= ops.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>ops[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub> &lt;= m</code></li>\n\t<li><code>1 &lt;= b<sub>i</sub> &lt;= n</code></li>\n</ul>\n"}}, "599": {"__typename": "QuestionLightNode", "acRate": 0.5721959268225121, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "599", "isFavor": false, "solutionNum": 768, "title": "Minimum Index Sum of Two Lists", "titleCn": "两个列表的最小索引总和", "titleSlug": "minimum-index-sum-of-two-lists", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 13, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/9c7ab4e2476fc53dc9e8061b1b956172a38d1842b44023aa44e51f223e7d57ac-logo.png", "slug": "yelp", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/cf2a3ac504c38f16ee9e9e828b4f40ed444dc54e25653145bbfdf9f2f467115a-1587797765803.jpg", "slug": "oracle", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。</p>\n\n<p>你需要帮助他们用<strong>最少的索引和</strong>找出他们<strong>共同喜爱的餐厅</strong>。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入: </strong>list1 = [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]，list2 = [\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"]\n<strong>输出:</strong> [\"Shogun\"]\n<strong>解释:</strong> 他们唯一共同喜爱的餐厅是“Shogun”。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong>list1 = [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]，list2 = [\"KFC\", \"Shogun\", \"Burger King\"]\n<strong>输出:</strong> [\"Shogun\"]\n<strong>解释:</strong> 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= list1.length, list2.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= list1[i].length, list2[i].length &lt;= 30</code>&nbsp;</li>\n\t<li><code>list1[i]</code> 和 <code>list2[i]</code> 由空格<meta charset=\"UTF-8\" />&nbsp;<code>' '</code>&nbsp;和英文字母组成。</li>\n\t<li><code>list1</code> 的所有字符串都是 <strong>唯一</strong> 的。</li>\n\t<li><code>list2</code> 中的所有字符串都是 <strong>唯一</strong> 的。</li>\n</ul>\n", "en": "<p>Given two arrays of strings <code>list1</code> and <code>list2</code>, find the <strong>common strings with the least index sum</strong>.</p>\n\n<p>A <strong>common string</strong> is a string that appeared in both <code>list1</code> and <code>list2</code>.</p>\n\n<p>A <strong>common string with the least index sum</strong> is a common string such that if it appeared at <code>list1[i]</code> and <code>list2[j]</code> then <code>i + j</code> should be the minimum value among all the other <strong>common strings</strong>.</p>\n\n<p>Return <em>all the <strong>common strings with the least index sum</strong></em>. Return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> list1 = [&quot;Shogun&quot;,&quot;Tapioca Express&quot;,&quot;Burger King&quot;,&quot;KFC&quot;], list2 = [&quot;Piatti&quot;,&quot;The Grill at Torrey Pines&quot;,&quot;Hungry Hunter Steakhouse&quot;,&quot;Shogun&quot;]\n<strong>Output:</strong> [&quot;Shogun&quot;]\n<strong>Explanation:</strong> The only common string is &quot;Shogun&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> list1 = [&quot;Shogun&quot;,&quot;Tapioca Express&quot;,&quot;Burger King&quot;,&quot;KFC&quot;], list2 = [&quot;KFC&quot;,&quot;Shogun&quot;,&quot;Burger King&quot;]\n<strong>Output:</strong> [&quot;Shogun&quot;]\n<strong>Explanation:</strong> The common string with the least index sum is &quot;Shogun&quot; with index sum = (0 + 1) = 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> list1 = [&quot;happy&quot;,&quot;sad&quot;,&quot;good&quot;], list2 = [&quot;sad&quot;,&quot;happy&quot;,&quot;good&quot;]\n<strong>Output:</strong> [&quot;sad&quot;,&quot;happy&quot;]\n<strong>Explanation:</strong> There are three common strings:\n&quot;happy&quot; with index sum = (0 + 1) = 1.\n&quot;sad&quot; with index sum = (1 + 0) = 1.\n&quot;good&quot; with index sum = (2 + 2) = 4.\nThe strings with the least index sum are &quot;sad&quot; and &quot;happy&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= list1.length, list2.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= list1[i].length, list2[i].length &lt;= 30</code></li>\n\t<li><code>list1[i]</code> and <code>list2[i]</code> consist of spaces <code>&#39; &#39;</code> and English letters.</li>\n\t<li>All the strings of <code>list1</code> are <strong>unique</strong>.</li>\n\t<li>All the strings of <code>list2</code> are <strong>unique</strong>.</li>\n\t<li>There is at least a common string between <code>list1</code> and <code>list2</code>.</li>\n</ul>\n"}}, "600": {"__typename": "QuestionLightNode", "acRate": 0.502087720572217, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "600", "isFavor": false, "solutionNum": 336, "title": "Non-negative Integers without Consecutive Ones", "titleCn": "不含连续1的非负整数", "titleSlug": "non-negative-integers-without-consecutive-ones", "topicTags": [{"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 14, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个正整数 <code>n</code> ，请你统计在&nbsp;<code>[0, n]</code> 范围的非负整数中，有多少个整数的二进制表示中不存在 <strong>连续的 1 </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 5\n<strong>输出:</strong> 5\n<strong>解释:</strong> \n下面列出范围在 [0, 5] 的非负整数与其对应的二进制表示：\n0 : 0\n1 : 1\n2 : 10\n3 : 11\n4 : 100\n5 : 101\n其中，只有整数 3 违反规则（有两个连续的 1 ），其他 5 个满足规则。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 1\n<strong>输出:</strong> 2\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 2\n<strong>输出:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Given a positive integer <code>n</code>, return the number of the integers in the range <code>[0, n]</code> whose binary representations <strong>do not</strong> contain consecutive ones.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\nHere are the non-negative integers &lt;= 5 with their corresponding binary representations:\n0 : 0\n1 : 1\n2 : 10\n3 : 11\n4 : 100\n5 : 101\nAmong them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "601": {"__typename": "QuestionLightNode", "acRate": 0.4831702840593376, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "601", "isFavor": false, "solutionNum": 668, "title": "Human Traffic of Stadium", "titleCn": "体育馆的人流量", "titleSlug": "human-traffic-of-stadium", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 25, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "表：<code>Stadium</code>\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| visit_date    | date    |\n| people        | int     |\n+---------------+---------+\nvisit_date 是该表中具有唯一值的列。\n每日人流量信息被记录在这三列信息中：<strong>序号</strong> (id)、<strong>日期</strong> (visit_date)、&nbsp;<strong>人流量</strong> (people)\n每天只有一行记录，日期随着 id 的增加而增加\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写解决方案找出每行的人数大于或等于 <code>100</code> 且 <code>id</code> 连续的三行或更多行记录。</p>\n\n<p>返回按 <code>visit_date</code> <strong>升序排列</strong> 的结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<code><strong>输入：</strong>\nStadium</code> 表:\n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 1    | 2017-01-01 | 10        |\n| 2    | 2017-01-02 | 109       |\n| 3    | 2017-01-03 | 150       |\n| 4    | 2017-01-04 | 99        |\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\n<strong>输出：</strong>\n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\n<strong>解释：\nid</strong> 为 5、6、7、8 的四行 id 连续，并且每行都有 &gt;= 100 的人数记录。\n请注意，即使第 7 行和第 8 行的 visit_date 不是连续的，输出也应当包含第 8 行，因为我们只需要考虑 id 连续的记录。\n不输出 id 为 2 和 3 的行，因为至少需要三条 id 连续的记录。</pre>\n", "en": "<p>Table: <code>Stadium</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| visit_date    | date    |\n| people        | int     |\n+---------------+---------+\nvisit_date is the column with unique values for this table.\nEach row of this table contains the visit date and visit id to the stadium with the number of people during the visit.\nAs the id increases, the date increases as well.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to display the records with three or more rows with <strong>consecutive</strong> <code>id</code>&#39;s, and the number of people is greater than or equal to 100 for each.</p>\n\n<p>Return the result table ordered by <code>visit_date</code> in <strong>ascending order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nStadium table:\n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 1    | 2017-01-01 | 10        |\n| 2    | 2017-01-02 | 109       |\n| 3    | 2017-01-03 | 150       |\n| 4    | 2017-01-04 | 99        |\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\n<strong>Output:</strong> \n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\n<strong>Explanation:</strong> \nThe four rows with ids 5, 6, 7, and 8 have consecutive ids and each of them has &gt;= 100 people attended. Note that row 8 was included even though the visit_date was not the next day after row 7.\nThe rows with ids 2 and 3 are not included because we need at least three consecutive ids.\n</pre>\n"}}, "602": {"__typename": "QuestionLightNode", "acRate": 0.6028078591837455, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "602", "isFavor": false, "solutionNum": 302, "title": "Friend Requests II: Who Has the Most Friends", "titleCn": "好友申请 II ：谁有最多的好友", "titleSlug": "friend-requests-ii-who-has-the-most-friends", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 11, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><code>RequestAccepted</code> 表：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| requester_id   | int     |\n| accepter_id    | int     |\n| accept_date    | date    |\n+----------------+---------+\n(requester_id, accepter_id) 是这张表的主键(具有唯一值的列的组合)。\n这张表包含发送好友请求的人的 ID ，接收好友请求的人的 ID ，以及好友请求通过的日期。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写解决方案，找出拥有最多的好友的人和他拥有的好友数目。</p>\n\n<p>生成的测试用例保证拥有最多好友数目的只有 1 个人。</p>\n\n<p>查询结果格式如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nRequestAccepted 表：\n+--------------+-------------+-------------+\n| requester_id | accepter_id | accept_date |\n+--------------+-------------+-------------+\n| 1            | 2           | 2016/06/03  |\n| 1            | 3           | 2016/06/08  |\n| 2            | 3           | 2016/06/08  |\n| 3            | 4           | 2016/06/09  |\n+--------------+-------------+-------------+\n<strong>输出：</strong>\n+----+-----+\n| id | num |\n+----+-----+\n| 3  | 3   |\n+----+-----+\n<strong>解释：</strong>\n编号为 3 的人是编号为 1 ，2 和 4 的人的好友，所以他总共有 3 个好友，比其他人都多。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>在真实世界里，可能会有多个人拥有好友数相同且最多，你能找到所有这些人吗？</p>\n</div>\n</div>\n", "en": "<p>Table: <code>RequestAccepted</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| requester_id   | int     |\n| accepter_id    | int     |\n| accept_date    | date    |\n+----------------+---------+\n(requester_id, accepter_id) is the primary key (combination of columns with unique values) for this table.\nThis table contains the ID of the user who sent the request, the ID of the user who received the request, and the date when the request was accepted.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the people who have the most friends and the most friends number.</p>\n\n<p>The test cases are generated so that only one person has the most friends.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nRequestAccepted table:\n+--------------+-------------+-------------+\n| requester_id | accepter_id | accept_date |\n+--------------+-------------+-------------+\n| 1            | 2           | 2016/06/03  |\n| 1            | 3           | 2016/06/08  |\n| 2            | 3           | 2016/06/08  |\n| 3            | 4           | 2016/06/09  |\n+--------------+-------------+-------------+\n<strong>Output:</strong> \n+----+-----+\n| id | num |\n+----+-----+\n| 3  | 3   |\n+----+-----+\n<strong>Explanation:</strong> \nThe person with id 3 is a friend of people 1, 2, and 4, so he has three friends in total, which is the most number than any others.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> In the real world, multiple people could have the same most number of friends. Could you find all these people in this case?</p>\n"}}, "603": {"__typename": "QuestionLightNode", "acRate": 0.627146243429867, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "603", "isFavor": false, "solutionNum": 260, "title": "Consecutive Available Seats", "titleCn": "连续空余座位", "titleSlug": "consecutive-available-seats", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 10, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "604": {"__typename": "QuestionLightNode", "acRate": 0.39466231871621044, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "604", "isFavor": false, "solutionNum": 102, "title": "Design Compressed String Iterator", "titleCn": "迭代压缩字符串", "titleSlug": "design-compressed-string-iterator", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "7eks9i", "name": "Iterator", "slug": "iterator", "nameTranslated": "迭代器", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "605": {"__typename": "QuestionLightNode", "acRate": 0.32285224201360246, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "605", "isFavor": false, "solutionNum": 2234, "title": "Can Place Flowers", "titleCn": "种花问题", "titleSlug": "can-place-flowers", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 38, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>\n\n<p>给你一个整数数组&nbsp;<code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数&nbsp;<code>n</code><strong> </strong>，能否在不打破种植规则的情况下种入&nbsp;<code>n</code><strong>&nbsp;</strong>朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>flowerbed = [1,0,0,0,1], n = 1\n<strong>输出：</strong>true\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>flowerbed = [1,0,0,0,1], n = 2\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= flowerbed.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>flowerbed[i]</code> 为 <code>0</code> 或 <code>1</code></li>\n\t<li><code>flowerbed</code> 中不存在相邻的两朵花</li>\n\t<li><code>0 &lt;= n &lt;= flowerbed.length</code></li>\n</ul>", "en": "<p>You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in <strong>adjacent</strong> plots.</p>\n\n<p>Given an integer array <code>flowerbed</code> containing <code>0</code>&#39;s and <code>1</code>&#39;s, where <code>0</code> means empty and <code>1</code> means not empty, and an integer <code>n</code>, return <code>true</code>&nbsp;<em>if</em> <code>n</code> <em>new flowers can be planted in the</em> <code>flowerbed</code> <em>without violating the no-adjacent-flowers rule and</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> flowerbed = [1,0,0,0,1], n = 1\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> flowerbed = [1,0,0,0,1], n = 2\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= flowerbed.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>flowerbed[i]</code> is <code>0</code> or <code>1</code>.</li>\n\t<li>There are no two adjacent flowers in <code>flowerbed</code>.</li>\n\t<li><code>0 &lt;= n &lt;= flowerbed.length</code></li>\n</ul>\n"}}, "606": {"__typename": "QuestionLightNode", "acRate": 0.6190524162301231, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "606", "isFavor": false, "solutionNum": 771, "title": "Construct String from Binary Tree", "titleCn": "根据二叉树创建字符串", "titleSlug": "construct-string-from-binary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 18, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你二叉树的根节点 <code>root</code> ，请你采用前序遍历的方式，将二叉树转化为一个由括号和整数组成的字符串，返回构造出的字符串。</p>\n\n<p>空节点使用一对空括号对 <code>\"()\"</code> 表示，转化后需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/cons1-tree.jpg\" style=\"width: 292px; height: 301px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,4]\n<strong>输出：</strong>\"1(2(4))(3)\"\n<strong>解释：</strong>初步转化后得到 \"1(2(4)())(3()())\" ，但省略所有不必要的空括号对后，字符串应该是\"1(2(4))(3)\" 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/cons2-tree.jpg\" style=\"width: 207px; height: 293px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,4]\n<strong>输出：</strong>\"1(2()(4))(3)\"\n<strong>解释：</strong>和第一个示例类似，但是无法省略第一个空括号对，否则会破坏输入与输出一一映射的关系。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目范围是 <code>[1, 10<sup>4</sup>]</code></li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>Given the <code>root</code> node of a binary tree, your task is to create a string representation of the tree following a specific set of formatting rules. The representation should be based on a preorder traversal of the binary tree and must adhere to the following guidelines:</p>\n\n<ul>\n\t<li>\n\t<p><strong>Node Representation</strong>: Each node in the tree should be represented by its integer value.</p>\n\t</li>\n\t<li>\n\t<p><strong>Parentheses for Children</strong>: If a node has at least one child (either left or right), its children should be represented inside parentheses. Specifically:</p>\n\n\t<ul>\n\t\t<li>If a node has a left child, the value of the left child should be enclosed in parentheses immediately following the node&#39;s value.</li>\n\t\t<li>If a node has a right child, the value of the right child should also be enclosed in parentheses. The parentheses for the right child should follow those of the left child.</li>\n\t</ul>\n\t</li>\n\t<li>\n\t<p><strong>Omitting Empty Parentheses</strong>: Any empty parentheses pairs (i.e., <code>()</code>) should be omitted from the final string representation of the tree, with one specific exception: when a node has a right child but no left child. In such cases, you must include an empty pair of parentheses to indicate the absence of the left child. This ensures that the one-to-one mapping between the string representation and the original binary tree structure is maintained.</p>\n\n\t<p>In summary, empty parentheses pairs should be omitted when a node has only a left child or no children. However, when a node has a right child but no left child, an empty pair of parentheses must precede the representation of the right child to reflect the tree&#39;s structure accurately.</p>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/cons1-tree.jpg\" style=\"padding: 10px; background: #fff; border-radius: .5rem;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4]\n<strong>Output:</strong> &quot;1(2(4))(3)&quot;\n<strong>Explanation:</strong> Originally, it needs to be &quot;1(2(4)())(3()())&quot;, but you need to omit all the empty parenthesis pairs. And it will be &quot;1(2(4))(3)&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/cons2-tree.jpg\" style=\"padding: 10px; background: #fff; border-radius: .5rem;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,4]\n<strong>Output:</strong> &quot;1(2()(4))(3)&quot;\n<strong>Explanation:</strong> Almost the same as the first example, except the <code>()</code> after <code>2</code> is necessary to indicate the absence of a left child for <code>2</code> and the presence of a right child.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n"}}, "607": {"__typename": "QuestionLightNode", "acRate": 0.6677162367223065, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "607", "isFavor": false, "solutionNum": 483, "title": "Sales Person", "titleCn": "销售员", "titleSlug": "sales-person", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 12, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表:&nbsp;<code>SalesPerson</code></p>\n\n<pre>\n+-----------------+---------+\n| Column Name     | Type    |\n+-----------------+---------+\n| sales_id        | int     |\n| name            | varchar |\n| salary          | int     |\n| commission_rate | int     |\n| hire_date       | date    |\n+-----------------+---------+\nsales_id 是该表的主键列(具有唯一值的列)。\n该表的每一行都显示了销售人员的姓名和 ID ，以及他们的工资、佣金率和雇佣日期。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表:&nbsp;<code>Company</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| com_id      | int     |\n| name        | varchar |\n| city        | varchar |\n+-------------+---------+\ncom_id 是该表的主键列(具有唯一值的列)。\n该表的每一行都表示公司的名称和 ID ，以及公司所在的城市。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>表:&nbsp;<code>Orders</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| order_id    | int  |\n| order_date  | date |\n| com_id      | int  |\n| sales_id    | int  |\n| amount      | int  |\n+-------------+------+\norder_id 是该表的主键列(具有唯一值的列)。\ncom_id 是 Company 表中 com_id 的外键（reference 列）。\nsales_id 是来自销售员表 sales_id 的外键（reference 列）。\n该表的每一行包含一个订单的信息。这包括公司的 ID 、销售人员的 ID 、订单日期和支付的金额。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写解决方案，找出没有任何与名为 <strong>“RED”</strong> 的公司相关的订单的所有销售人员的姓名。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>返回结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nSalesPerson 表:\n+----------+------+--------+-----------------+------------+\n| sales_id | name | salary | commission_rate | hire_date  |\n+----------+------+--------+-----------------+------------+\n| 1        | John | 100000 | 6               | 4/1/2006   |\n| 2        | Amy  | 12000  | 5               | 5/1/2010   |\n| 3        | Mark | 65000  | 12              | 12/25/2008 |\n| 4        | Pam  | 25000  | 25              | 1/1/2005   |\n| 5        | Alex | 5000   | 10              | 2/3/2007   |\n+----------+------+--------+-----------------+------------+\nCompany 表:\n+--------+--------+----------+\n| com_id | name   | city     |\n+--------+--------+----------+\n| 1      | RED    | Boston   |\n| 2      | ORANGE | New York |\n| 3      | YELLOW | Boston   |\n| 4      | GREEN  | Austin   |\n+--------+--------+----------+\nOrders 表:\n+----------+------------+--------+----------+--------+\n| order_id | order_date | com_id | sales_id | amount |\n+----------+------------+--------+----------+--------+\n| 1        | 1/1/2014   | 3      | 4        | 10000  |\n| 2        | 2/1/2014   | 4      | 5        | 5000   |\n| 3        | 3/1/2014   | 1      | 1        | 50000  |\n| 4        | 4/1/2014   | 1      | 4        | 25000  |\n+----------+------------+--------+----------+--------+\n<strong>输出：</strong>\n+------+\n| name |\n+------+\n| Amy  |\n| Mark |\n| Alex |\n+------+\n<strong>解释：</strong>\n根据表&nbsp;<code>orders</code>&nbsp;中的订单 '3' 和 '4' ，容易看出只有 'John' 和 'Pam' 两个销售员曾经向公司 'RED' 销售过。\n所以我们需要输出表&nbsp;<code>salesperson</code>&nbsp;中所有其他人的名字。</pre>\n", "en": "<p>Table: <code>SalesPerson</code></p>\n\n<pre>\n+-----------------+---------+\n| Column Name     | Type    |\n+-----------------+---------+\n| sales_id        | int     |\n| name            | varchar |\n| salary          | int     |\n| commission_rate | int     |\n| hire_date       | date    |\n+-----------------+---------+\nsales_id is the primary key (column with unique values) for this table.\nEach row of this table indicates the name and the ID of a salesperson alongside their salary, commission rate, and hire date.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Company</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| com_id      | int     |\n| name        | varchar |\n| city        | varchar |\n+-------------+---------+\ncom_id is the primary key (column with unique values) for this table.\nEach row of this table indicates the name and the ID of a company and the city in which the company is located.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Orders</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| order_id    | int  |\n| order_date  | date |\n| com_id      | int  |\n| sales_id    | int  |\n| amount      | int  |\n+-------------+------+\norder_id is the primary key (column with unique values) for this table.\ncom_id is a foreign key (reference column) to com_id from the Company table.\nsales_id is a foreign key (reference column) to sales_id from the SalesPerson table.\nEach row of this table contains information about one order. This includes the ID of the company, the ID of the salesperson, the date of the order, and the amount paid.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the names of all the salespersons who did not have any orders related to the company with the name <strong>&quot;RED&quot;</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nSalesPerson table:\n+----------+------+--------+-----------------+------------+\n| sales_id | name | salary | commission_rate | hire_date  |\n+----------+------+--------+-----------------+------------+\n| 1        | John | 100000 | 6               | 4/1/2006   |\n| 2        | Amy  | 12000  | 5               | 5/1/2010   |\n| 3        | Mark | 65000  | 12              | 12/25/2008 |\n| 4        | Pam  | 25000  | 25              | 1/1/2005   |\n| 5        | Alex | 5000   | 10              | 2/3/2007   |\n+----------+------+--------+-----------------+------------+\nCompany table:\n+--------+--------+----------+\n| com_id | name   | city     |\n+--------+--------+----------+\n| 1      | RED    | Boston   |\n| 2      | ORANGE | New York |\n| 3      | YELLOW | Boston   |\n| 4      | GREEN  | Austin   |\n+--------+--------+----------+\nOrders table:\n+----------+------------+--------+----------+--------+\n| order_id | order_date | com_id | sales_id | amount |\n+----------+------------+--------+----------+--------+\n| 1        | 1/1/2014   | 3      | 4        | 10000  |\n| 2        | 2/1/2014   | 4      | 5        | 5000   |\n| 3        | 3/1/2014   | 1      | 1        | 50000  |\n| 4        | 4/1/2014   | 1      | 4        | 25000  |\n+----------+------------+--------+----------+--------+\n<strong>Output:</strong> \n+------+\n| name |\n+------+\n| Amy  |\n| Mark |\n| Alex |\n+------+\n<strong>Explanation:</strong> \nAccording to orders 3 and 4 in the Orders table, it is easy to tell that only salesperson John and Pam have sales to company RED, so we report all the other names in the table salesperson.\n</pre>\n"}}, "608": {"__typename": "QuestionLightNode", "acRate": 0.6225976251683193, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "608", "isFavor": false, "solutionNum": 493, "title": "Tree Node", "titleCn": "树节点", "titleSlug": "tree-node", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 21, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937282-qSKaPF-Unknown-4.jpeg", "slug": "twitter", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表：<code>Tree</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| p_id        | int  |\n+-------------+------+\nid 是该表中具有唯一值的列。\n该表的每行包含树中节点的 id 及其父节点的 id 信息。\n给定的结构总是一个有效的树。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>树中的每个节点可以是以下三种类型之一：</p>\n\n<ul>\n\t<li><strong>\"Leaf\"</strong>：节点是叶子节点。</li>\n\t<li><strong>\"Root\"</strong>：节点是树的根节点。</li>\n\t<li><strong>\"lnner\"</strong>：节点既不是叶子节点也不是根节点。</li>\n</ul>\n\n<p>编写一个解决方案来报告树中每个节点的类型。</p>\n\n<p>以 <strong>任意顺序</strong> 返回结果表。</p>\n\n<p>结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/22/tree1.jpg\" style=\"width: 304px; height: 224px;\" />\n<pre>\n<b>输入：</b>\nTree table:\n+----+------+\n| id | p_id |\n+----+------+\n| 1  | null |\n| 2  | 1    |\n| 3  | 1    |\n| 4  | 2    |\n| 5  | 2    |\n+----+------+\n<b>输出：</b>\n+----+-------+\n| id | type  |\n+----+-------+\n| 1  | Root  |\n| 2  | Inner |\n| 3  | Leaf  |\n| 4  | Leaf  |\n| 5  | Leaf  |\n+----+-------+\n<b>解释：</b>\n节点 1 是根节点，因为它的父节点为空，并且它有子节点 2 和 3。\n节点 2 是一个内部节点，因为它有父节点 1 和子节点 4 和 5。\n节点 3、4 和 5 是叶子节点，因为它们有父节点而没有子节点。\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/22/tree2.jpg\" style=\"width: 64px; height: 65px;\" />\n<pre>\n<b>输入：</b>\nTree table:\n+----+------+\n| id | p_id |\n+----+------+\n| 1  | null |\n+----+------+\n<b>输出：</b>\n+----+-------+\n| id | type  |\n+----+-------+\n| 1  | Root  |\n+----+-------+\n<b>解释：</b>如果树中只有一个节点，则只需要输出其根属性。\n</pre>\n", "en": "<p>Table: <code>Tree</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| p_id        | int  |\n+-------------+------+\nid is the column with unique values for this table.\nEach row of this table contains information about the id of a node and the id of its parent node in a tree.\nThe given structure is always a valid tree.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Each node in the tree can be one of three types:</p>\n\n<ul>\n\t<li><strong>&quot;Leaf&quot;</strong>: if the node is a leaf node.</li>\n\t<li><strong>&quot;Root&quot;</strong>: if the node is the root of the tree.</li>\n\t<li><strong>&quot;Inner&quot;</strong>: If the node is neither a leaf node nor a root node.</li>\n</ul>\n\n<p>Write a solution to report the type of each node in the tree.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/22/tree1.jpg\" style=\"width: 304px; height: 224px;\" />\n<pre>\n<strong>Input:</strong> \nTree table:\n+----+------+\n| id | p_id |\n+----+------+\n| 1  | null |\n| 2  | 1    |\n| 3  | 1    |\n| 4  | 2    |\n| 5  | 2    |\n+----+------+\n<strong>Output:</strong> \n+----+-------+\n| id | type  |\n+----+-------+\n| 1  | Root  |\n| 2  | Inner |\n| 3  | Leaf  |\n| 4  | Leaf  |\n| 5  | Leaf  |\n+----+-------+\n<strong>Explanation:</strong> \nNode 1 is the root node because its parent node is null and it has child nodes 2 and 3.\nNode 2 is an inner node because it has parent node 1 and child node 4 and 5.\nNodes 3, 4, and 5 are leaf nodes because they have parent nodes and they do not have child nodes.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/22/tree2.jpg\" style=\"width: 64px; height: 65px;\" />\n<pre>\n<strong>Input:</strong> \nTree table:\n+----+------+\n| id | p_id |\n+----+------+\n| 1  | null |\n+----+------+\n<strong>Output:</strong> \n+----+-------+\n| id | type  |\n+----+-------+\n| 1  | Root  |\n+----+-------+\n<strong>Explanation:</strong> If there is only one node on the tree, you only need to output its root attributes.\n</pre>\n"}}, "609": {"__typename": "QuestionLightNode", "acRate": 0.536254186657011, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "609", "isFavor": false, "solutionNum": 170, "title": "Find Duplicate File in System", "titleCn": "在系统中查找重复文件", "titleSlug": "find-duplicate-file-in-system", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 21, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708936774-exAysB-u=3581604551,3862588286&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "dropbox", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个目录信息列表&nbsp;<code>paths</code> ，包括目录路径，以及该目录中的所有文件及其内容，请你按路径返回文件系统中的所有重复文件。答案可按 <strong>任意顺序</strong> 返回。</p>\n\n<p>一组重复的文件至少包括 <strong>两个 </strong>具有完全相同内容的文件。</p>\n\n<p><strong>输入 </strong>列表中的单个目录信息字符串的格式如下：</p>\n\n<ul>\n\t<li><code>\"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\"</code></li>\n</ul>\n\n<p>这意味着，在目录&nbsp;<code>root/d1/d2/.../dm</code>&nbsp;下，有 <code>n</code> 个文件 ( <code>f1.txt</code>,&nbsp;<code>f2.txt</code>&nbsp;...&nbsp;<code>fn.txt</code> ) 的内容分别是 ( <code>f1_content</code>,&nbsp;<code>f2_content</code>&nbsp;...&nbsp;<code>fn_content</code> ) 。注意：<code>n &gt;= 1</code> 且 <code>m &gt;= 0</code> 。如果 <code>m = 0</code> ，则表示该目录是根目录。</p>\n\n<p><strong>输出 </strong>是由 <strong>重复文件路径组</strong> 构成的列表。其中每个组由所有具有相同内容文件的文件路径组成。文件路径是具有下列格式的字符串：</p>\n\n<ul>\n\t<li><code>\"directory_path/file_name.txt\"</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]\n<strong>输出：</strong>[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]\n<strong>输出：</strong>[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= paths[i].length &lt;= 3000</code></li>\n\t<li><code>1 &lt;= sum(paths[i].length) &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>paths[i]</code> 由英文字母、数字、字符 <code>'/'</code>、<code>'.'</code>、<code>'('</code>、<code>')'</code> 和 <code>' '</code> 组成</li>\n\t<li>你可以假设在同一目录中没有任何文件或目录共享相同的名称。</li>\n\t<li>你可以假设每个给定的目录信息代表一个唯一的目录。目录路径和文件信息用单个空格分隔。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong></p>\n\n<ul>\n\t<li>假设您有一个真正的文件系统，您将如何搜索文件？广度搜索还是宽度搜索？</li>\n\t<li>如果文件内容非常大（GB级别），您将如何修改您的解决方案？</li>\n\t<li>如果每次只能读取 1 kb 的文件，您将如何修改解决方案？</li>\n\t<li>修改后的解决方案的时间复杂度是多少？其中最耗时的部分和消耗内存的部分是什么？如何优化？</li>\n\t<li>如何确保您发现的重复文件不是误报？</li>\n</ul>\n", "en": "<p>Given a list <code>paths</code> of directory info, including the directory path, and all the files with contents in this directory, return <em>all the duplicate files in the file system in terms of their paths</em>. You may return the answer in <strong>any order</strong>.</p>\n\n<p>A group of duplicate files consists of at least two files that have the same content.</p>\n\n<p>A single directory info string in the input list has the following format:</p>\n\n<ul>\n\t<li><code>&quot;root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)&quot;</code></li>\n</ul>\n\n<p>It means there are <code>n</code> files <code>(f1.txt, f2.txt ... fn.txt)</code> with content <code>(f1_content, f2_content ... fn_content)</code> respectively in the directory &quot;<code>root/d1/d2/.../dm&quot;</code>. Note that <code>n &gt;= 1</code> and <code>m &gt;= 0</code>. If <code>m = 0</code>, it means the directory is just the root directory.</p>\n\n<p>The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:</p>\n\n<ul>\n\t<li><code>&quot;directory_path/file_name.txt&quot;</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]\n<strong>Output:</strong> [[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]\n<strong>Output:</strong> [[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= paths.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= paths[i].length &lt;= 3000</code></li>\n\t<li><code>1 &lt;= sum(paths[i].length) &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>paths[i]</code> consist of English letters, digits, <code>&#39;/&#39;</code>, <code>&#39;.&#39;</code>, <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, and <code>&#39; &#39;</code>.</li>\n\t<li>You may assume no files or directories share the same name in the same directory.</li>\n\t<li>You may assume each given directory info represents a unique directory. A single blank space separates the directory path and file info.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Imagine you are given a real file system, how will you search files? DFS or BFS?</li>\n\t<li>If the file content is very large (GB level), how will you modify your solution?</li>\n\t<li>If you can only read the file by 1kb each time, how will you modify your solution?</li>\n\t<li>What is the time complexity of your modified solution? What is the most time-consuming part and memory-consuming part of it? How to optimize?</li>\n\t<li>How to make sure the duplicated files you find are not false positive?</li>\n</ul>\n"}}, "610": {"__typename": "QuestionLightNode", "acRate": 0.6882136783284742, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "610", "isFavor": false, "solutionNum": 215, "title": "Triangle Judgement", "titleCn": "判断三角形", "titleSlug": "triangle-judgement", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表:&nbsp;<code>Triangle</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| x           | int  |\n| y           | int  |\n| z           | int  |\n+-------------+------+\n在 SQL 中，(x, y, z)是该表的主键列。\n该表的每一行包含三个线段的长度。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>对每三个线段报告它们是否可以形成一个三角形。</p>\n\n<p>以&nbsp;<strong>任意顺序&nbsp;</strong>返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nTriangle 表:\n+----+----+----+\n| x  | y  | z  |\n+----+----+----+\n| 13 | 15 | 30 |\n| 10 | 20 | 15 |\n+----+----+----+\n<strong>输出:</strong> \n+----+----+----+----------+\n| x  | y  | z  | triangle |\n+----+----+----+----------+\n| 13 | 15 | 30 | No       |\n| 10 | 20 | 15 | Yes      |\n+----+----+----+----------+</pre>\n", "en": "<p>Table: <code>Triangle</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| x           | int  |\n| y           | int  |\n| z           | int  |\n+-------------+------+\nIn SQL, (x, y, z) is the primary key column for this table.\nEach row of this table contains the lengths of three line segments.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Report for every three line segments whether they can form a triangle.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nTriangle table:\n+----+----+----+\n| x  | y  | z  |\n+----+----+----+\n| 13 | 15 | 30 |\n| 10 | 20 | 15 |\n+----+----+----+\n<strong>Output:</strong> \n+----+----+----+----------+\n| x  | y  | z  | triangle |\n+----+----+----+----------+\n| 13 | 15 | 30 | No       |\n| 10 | 20 | 15 | Yes      |\n+----+----+----+----------+\n</pre>\n"}}, "611": {"__typename": "QuestionLightNode", "acRate": 0.5356507637581084, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "611", "isFavor": false, "solutionNum": 708, "title": "Valid Triangle Number", "titleCn": "有效三角形的个数", "titleSlug": "valid-triangle-number", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 45, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个包含非负整数的数组&nbsp;<code>nums</code> ，返回其中可以组成三角形三条边的三元组个数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [2,2,3,4]\n<strong>输出:</strong> 3\n<strong>解释:</strong>有效的组合是: \n2,3,4 (使用第一个 2)\n2,3,4 (使用第二个 2)\n2,2,3\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [4,2,3,4]\n<strong>输出:</strong> 4</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code>, return <em>the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,3,4]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Valid combinations are: \n2,3,4 (using the first 2)\n2,3,4 (using the second 2)\n2,2,3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,2,3,4]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n"}}, "612": {"__typename": "QuestionLightNode", "acRate": 0.6428117183194132, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "612", "isFavor": false, "solutionNum": 114, "title": "Shortest Distance in a Plane", "titleCn": "平面上的最近距离", "titleSlug": "shortest-distance-in-a-plane", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 8, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "613": {"__typename": "QuestionLightNode", "acRate": 0.7890510200594607, "difficulty": "EASY", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "613", "isFavor": false, "solutionNum": 138, "title": "Shortest Distance in a Line", "titleCn": "直线上的最近距离", "titleSlug": "shortest-distance-in-a-line", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 1, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "614": {"__typename": "QuestionLightNode", "acRate": 0.37948649311829397, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "614", "isFavor": false, "solutionNum": 120, "title": "Second Degree Follower", "titleCn": "二级关注者", "titleSlug": "second-degree-follower", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 8, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/d9a48abd371c666425f82ac8c14dc7f3e9268e25fd43fb57a14b931e3d68fd9d-unnamed.jpg", "slug": "databricks", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "615": {"__typename": "QuestionLightNode", "acRate": 0.42581304522392965, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "615", "isFavor": false, "solutionNum": 163, "title": "Average Salary: Departments VS Company", "titleCn": "平均工资：部门与公司比较", "titleSlug": "average-salary-departments-vs-company", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 8, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "616": {"__typename": "QuestionLightNode", "acRate": 0.5064688253782619, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "616", "isFavor": false, "solutionNum": 111, "title": "Add Bold Tag in String", "titleCn": "给字符串添加加粗标签", "titleSlug": "add-bold-tag-in-string", "topicTags": [{"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "ydzvgh", "name": "String Matching", "slug": "string-matching", "nameTranslated": "字符串匹配", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 23, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "617": {"__typename": "QuestionLightNode", "acRate": 0.7931322762402738, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "617", "isFavor": false, "solutionNum": 2615, "title": "Merge Two Binary Trees", "titleCn": "合并二叉树", "titleSlug": "merge-two-binary-trees", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 47, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>\n\n<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>\n\n<p>返回合并后的二叉树。</p>\n\n<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/merge.jpg\" style=\"height: 163px; width: 600px;\" />\n<pre>\n<strong>输入：</strong>root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n<strong>输出：</strong>[3,4,5,5,4,null,7]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root1 = [1], root2 = [1,2]\n<strong>输出：</strong>[2,2]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>You are given two binary trees <code>root1</code> and <code>root2</code>.</p>\n\n<p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p>\n\n<p>Return <em>the merged tree</em>.</p>\n\n<p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/05/merge.jpg\" style=\"width: 600px; height: 163px;\" />\n<pre>\n<strong>Input:</strong> root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n<strong>Output:</strong> [3,4,5,5,4,null,7]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root1 = [1], root2 = [1,2]\n<strong>Output:</strong> [2,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in both trees is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "618": {"__typename": "QuestionLightNode", "acRate": 0.6152566676225982, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "618", "isFavor": false, "solutionNum": 97, "title": "Students Report By Geography", "titleCn": "学生地理信息报告", "titleSlug": "students-report-by-geography", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 5, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "619": {"__typename": "QuestionLightNode", "acRate": 0.5427326522801542, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "619", "isFavor": false, "solutionNum": 296, "title": "Biggest Single Number", "titleCn": "只出现一次的最大数字", "titleSlug": "biggest-single-number", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 7, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><code>MyNumbers</code> 表：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| num         | int  |\n+-------------+------+\n该表可能包含重复项（换句话说，在SQL中，该表没有主键）。\n这张表的每一行都含有一个整数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>单一数字</strong> 是在 <code>MyNumbers</code> 表中只出现一次的数字。</p>\n\n<p>找出最大的 <strong>单一数字</strong> 。如果不存在 <strong>单一数字</strong> ，则返回&nbsp;<code>null</code> 。</p>\n\n<p>查询结果如下例所示。</p>\n<ptable> </ptable>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nMyNumbers 表：\n+-----+\n| num |\n+-----+\n| 8   |\n| 8   |\n| 3   |\n| 3   |\n| 1   |\n| 4   |\n| 5   |\n| 6   |\n+-----+\n<strong>输出：</strong>\n+-----+\n| num |\n+-----+\n| 6   |\n+-----+\n<strong>解释：</strong>单一数字有 1、4、5 和 6 。\n6 是最大的单一数字，返回 6 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>\nMyNumbers table:\n+-----+\n| num |\n+-----+\n| 8   |\n| 8   |\n| 7   |\n| 7   |\n| 3   |\n| 3   |\n| 3   |\n+-----+\n<strong>输出：</strong>\n+------+\n| num  |\n+------+\n| null |\n+------+\n<strong>解释：</strong>输入的表中不存在单一数字，所以返回 null 。\n</pre>\n</div>\n</div>\n\n<p>&nbsp;</p>\n", "en": "<p>Table: <code>MyNumbers</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| num         | int  |\n+-------------+------+\nThis table may contain duplicates (In other words, there is no primary key for this table in SQL).\nEach row of this table contains an integer.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>A <strong>single number</strong> is a number that appeared only once in the <code>MyNumbers</code> table.</p>\n\n<p>Find the largest <strong>single number</strong>. If there is no <strong>single number</strong>, report <code>null</code>.</p>\n\n<p>The result format is in the following example.</p>\n<ptable> </ptable>\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nMyNumbers table:\n+-----+\n| num |\n+-----+\n| 8   |\n| 8   |\n| 3   |\n| 3   |\n| 1   |\n| 4   |\n| 5   |\n| 6   |\n+-----+\n<strong>Output:</strong> \n+-----+\n| num |\n+-----+\n| 6   |\n+-----+\n<strong>Explanation:</strong> The single numbers are 1, 4, 5, and 6.\nSince 6 is the largest single number, we return it.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nMyNumbers table:\n+-----+\n| num |\n+-----+\n| 8   |\n| 8   |\n| 7   |\n| 7   |\n| 3   |\n| 3   |\n| 3   |\n+-----+\n<strong>Output:</strong> \n+------+\n| num  |\n+------+\n| null |\n+------+\n<strong>Explanation:</strong> There are no single numbers in the input table so we return null.\n</pre>\n"}}, "620": {"__typename": "QuestionLightNode", "acRate": 0.7744260128837396, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "620", "isFavor": false, "solutionNum": 528, "title": "Not Boring Movies", "titleCn": "有趣的电影", "titleSlug": "not-boring-movies", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 10, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表：<code>cinema</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| id             | int      |\n| movie          | varchar  |\n| description    | varchar  |\n| rating         | float    |\n+----------------+----------+\nid 是该表的主键(具有唯一值的列)。\n每行包含有关电影名称、类型和评级的信息。\n评级为 [0,10] 范围内的小数点后 2 位浮点数。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写解决方案，找出所有影片描述为&nbsp;<strong>非</strong>&nbsp;<code>boring</code>&nbsp;(不无聊)&nbsp;的并且<strong> id 为奇数&nbsp;</strong>的影片。</p>\n\n<p>返回结果按&nbsp;<code>rating</code>&nbsp;<strong>降序排列</strong>。</p>\n\n<p>结果格式如下示例。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n+---------+-----------+--------------+-----------+\n|   id    | movie     |  description |  rating   |\n+---------+-----------+--------------+-----------+\n|   1     | War       |   great 3D   |   8.9     |\n|   2     | Science   |   fiction    |   8.5     |\n|   3     | irish     |   boring     |   6.2     |\n|   4     | Ice song  |   Fantacy    |   8.6     |\n|   5     | House card|   Interesting|   9.1     |\n<strong>+---------+-----------+--------------+-----------+\n输出：</strong>\n+---------+-----------+--------------+-----------+\n|   id    | movie     |  description |  rating   |\n+---------+-----------+--------------+-----------+\n|   5     | House card|   Interesting|   9.1     |\n|   1     | War       |   great 3D   |   8.9     |\n+---------+-----------+--------------+-----------+\n<strong>解释：</strong>\n我们有三部电影，它们的 id 是奇数:1、3 和 5。id = 3 的电影是 boring 的，所以我们不把它包括在答案中。\n</pre>\n", "en": "<p>Table: <code>Cinema</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| id             | int      |\n| movie          | varchar  |\n| description    | varchar  |\n| rating         | float    |\n+----------------+----------+\nid is the primary key (column with unique values) for this table.\nEach row contains information about the name of a movie, its genre, and its rating.\nrating is a 2 decimal places float in the range [0, 10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the movies with an odd-numbered ID and a description that is not <code>&quot;boring&quot;</code>.</p>\n\n<p>Return the result table ordered by <code>rating</code> <strong>in descending order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nCinema table:\n+----+------------+-------------+--------+\n| id | movie      | description | rating |\n+----+------------+-------------+--------+\n| 1  | War        | great 3D    | 8.9    |\n| 2  | Science    | fiction     | 8.5    |\n| 3  | irish      | boring      | 6.2    |\n| 4  | Ice song   | Fantacy     | 8.6    |\n| 5  | House card | Interesting | 9.1    |\n+----+------------+-------------+--------+\n<strong>Output:</strong> \n+----+------------+-------------+--------+\n| id | movie      | description | rating |\n+----+------------+-------------+--------+\n| 5  | House card | Interesting | 9.1    |\n| 1  | War        | great 3D    | 8.9    |\n+----+------------+-------------+--------+\n<strong>Explanation:</strong> \nWe have three movies with odd-numbered IDs: 1, 3, and 5. The movie with ID = 3 is boring so we do not include it in the answer.\n</pre>\n"}}, "621": {"__typename": "QuestionLightNode", "acRate": 0.6008307257334371, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "621", "isFavor": false, "solutionNum": 897, "title": "Task Scheduler", "titleCn": "任务调度器", "titleSlug": "task-scheduler", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "pxpqcm", "name": "Counting", "slug": "counting", "nameTranslated": "计数", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 56, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个用字符数组&nbsp;<code>tasks</code> 表示的 CPU 需要执行的任务列表，用字母 A 到 Z 表示，以及一个冷却时间 <code>n</code>。每个周期或时间间隔允许完成一项任务。任务可以按任何顺序完成，但有一个限制：两个<strong> 相同种类</strong> 的任务之间必须有长度为<strong>&nbsp;</strong><code>n</code><strong> </strong>的冷却时间。</p>\n\n<p>返回完成所有任务所需要的<strong> 最短时间间隔</strong>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\n<strong>输出：</strong>8\n<strong>解释：</strong>A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B\n     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 </pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0\n<strong>输出：</strong>6\n<strong>解释：</strong>在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0\n[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]\n[\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"]\n[\"B\",\"B\",\"B\",\"A\",\"A\",\"A\"]\n...\n诸如此类\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2\n<strong>输出：</strong>16\n<strong>解释：</strong>一种可能的解决方案是：\n     A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>tasks[i]</code> 是大写英文字母</li>\n\t<li><code>0 &lt;= n &lt;= 100</code></li>\n</ul>\n", "en": "<p>You are given an array of CPU <code>tasks</code>, each represented by letters&nbsp;A&nbsp;to Z, and a cooling time, <code>n</code>. Each cycle or interval allows the completion of one task. Tasks can be completed in any order, but there&#39;s a constraint: <strong>identical</strong> tasks must be separated by at least <code>n</code> intervals due to cooling time.</p>\n\n<p>​Return the <em>minimum number of intervals</em> required to complete all tasks.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\" style=\"\n    border-color: var(--border-tertiary);\n    border-left-width: 2px;\n    color: var(--text-secondary);\n    font-size: .875rem;\n    margin-bottom: 1rem;\n    margin-top: 1rem;\n    overflow: visible;\n    padding-left: 1rem;\n\">\n<p><strong>Input:</strong> <span class=\"example-io\" style=\"\n    font-family: Menlo,sans-serif;\n    font-size: 0.85rem;\n\">tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\" style=\"\nfont-family: Menlo,sans-serif;\nfont-size: 0.85rem;\n\">8</span></p>\n\n<p><strong>Explanation:</strong> A possible sequence is: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.</p>\n\n<p>After completing task A, you must wait two cycles before doing A again. The same applies to task B. In the 3<sup>rd</sup> interval, neither A nor B can be done, so you idle. By the 4<sup>th</sup> cycle, you can do A again as 2 intervals have passed.</p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\" style=\"\n    border-color: var(--border-tertiary);\n    border-left-width: 2px;\n    color: var(--text-secondary);\n    font-size: .875rem;\n    margin-bottom: 1rem;\n    margin-top: 1rem;\n    overflow: visible;\n    padding-left: 1rem;\n\">\n<p><strong>Input:</strong> <span class=\"example-io\" style=\"\n    font-family: Menlo,sans-serif;\n    font-size: 0.85rem;\n\">tasks = [&quot;A&quot;,&quot;C&quot;,&quot;A&quot;,&quot;B&quot;,&quot;D&quot;,&quot;B&quot;], n = 1</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\" style=\"\n    font-family: Menlo,sans-serif;\n    font-size: 0.85rem;\n\">6</span></p>\n\n<p><strong>Explanation:</strong> A possible sequence is: A -&gt; B -&gt; C -&gt; D -&gt; A -&gt; B.</p>\n\n<p>With a cooling interval of 1, you can repeat a task after just one other task.</p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\" style=\"\n    border-color: var(--border-tertiary);\n    border-left-width: 2px;\n    color: var(--text-secondary);\n    font-size: .875rem;\n    margin-bottom: 1rem;\n    margin-top: 1rem;\n    overflow: visible;\n    padding-left: 1rem;\n\">\n<p><strong>Input:</strong> <span class=\"example-io\" style=\"\n    font-family: Menlo,sans-serif;\n    font-size: 0.85rem;\n\">tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;, &quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 3</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\" style=\"\n    font-family: Menlo,sans-serif;\n    font-size: 0.85rem;\n\">10</span></p>\n\n<p><strong>Explanation:</strong> A possible sequence is: A -&gt; B -&gt; idle -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; idle -&gt; A -&gt; B.</p>\n\n<p>There are only two types of tasks, A and B, which need to be separated by 3 intervals. This leads to idling twice between repetitions of these tasks.</p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= tasks.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>tasks[i]</code> is an uppercase English letter.</li>\n\t<li><code>0 &lt;= n &lt;= 100</code></li>\n</ul>\n"}}, "622": {"__typename": "QuestionLightNode", "acRate": 0.46594702080818123, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "622", "isFavor": false, "solutionNum": 1070, "title": "Design Circular Queue", "titleCn": "设计循环队列", "titleSlug": "design-circular-queue", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "vxfk6", "name": "Queue", "slug": "queue", "nameTranslated": "队列", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 52, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为&ldquo;环形缓冲器&rdquo;。</p>\n\n<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p>\n\n<p>你的实现应该支持如下操作：</p>\n\n<ul>\n\t<li><code>MyCircularQueue(k)</code>: 构造器，设置队列长度为 k 。</li>\n\t<li><code>Front</code>: 从队首获取元素。如果队列为空，返回 -1 。</li>\n\t<li><code>Rear</code>: 获取队尾元素。如果队列为空，返回 -1 。</li>\n\t<li><code>enQueue(value)</code>: 向循环队列插入一个元素。如果成功插入则返回真。</li>\n\t<li><code>deQueue()</code>: 从循环队列中删除一个元素。如果成功删除则返回真。</li>\n\t<li><code>isEmpty()</code>: 检查循环队列是否为空。</li>\n\t<li><code>isFull()</code>: 检查循环队列是否已满。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3\ncircularQueue.enQueue(1); &nbsp;// 返回 true\ncircularQueue.enQueue(2); &nbsp;// 返回 true\ncircularQueue.enQueue(3); &nbsp;// 返回 true\ncircularQueue.enQueue(4); &nbsp;// 返回 false，队列已满\ncircularQueue.Rear(); &nbsp;// 返回 3\ncircularQueue.isFull(); &nbsp;// 返回 true\ncircularQueue.deQueue(); &nbsp;// 返回 true\ncircularQueue.enQueue(4); &nbsp;// 返回 true\ncircularQueue.Rear(); &nbsp;// 返回 4</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>所有的值都在 0&nbsp;至 1000 的范围内；</li>\n\t<li>操作数将在 1 至 1000 的范围内；</li>\n\t<li>请不要使用内置的队列库。</li>\n</ul>\n", "en": "<p>Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle, and the last position is connected back to the first position to make a circle. It is also called &quot;Ring Buffer&quot;.</p>\n\n<p>One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.</p>\n\n<p>Implement the <code>MyCircularQueue</code> class:</p>\n\n<ul>\n\t<li><code>MyCircularQueue(k)</code> Initializes the object with the size of the queue to be <code>k</code>.</li>\n\t<li><code>int Front()</code> Gets the front item from the queue. If the queue is empty, return <code>-1</code>.</li>\n\t<li><code>int Rear()</code> Gets the last item from the queue. If the queue is empty, return <code>-1</code>.</li>\n\t<li><code>boolean enQueue(int value)</code> Inserts an element into the circular queue. Return <code>true</code> if the operation is successful.</li>\n\t<li><code>boolean deQueue()</code> Deletes an element from the circular queue. Return <code>true</code> if the operation is successful.</li>\n\t<li><code>boolean isEmpty()</code> Checks whether the circular queue is empty or not.</li>\n\t<li><code>boolean isFull()</code> Checks whether the circular queue is full or not.</li>\n</ul>\n\n<p>You must solve the problem without using the built-in queue data structure in your programming language.&nbsp;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyCircularQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;, &quot;isFull&quot;, &quot;deQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n<strong>Output</strong>\n[null, true, true, true, false, 3, true, true, true, 4]\n\n<strong>Explanation</strong>\nMyCircularQueue myCircularQueue = new MyCircularQueue(3);\nmyCircularQueue.enQueue(1); // return True\nmyCircularQueue.enQueue(2); // return True\nmyCircularQueue.enQueue(3); // return True\nmyCircularQueue.enQueue(4); // return False\nmyCircularQueue.Rear();     // return 3\nmyCircularQueue.isFull();   // return True\nmyCircularQueue.deQueue();  // return True\nmyCircularQueue.enQueue(4); // return True\nmyCircularQueue.Rear();     // return 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li><code>0 &lt;= value &lt;= 1000</code></li>\n\t<li>At most <code>3000</code> calls will be made to&nbsp;<code>enQueue</code>, <code>deQueue</code>,&nbsp;<code>Front</code>,&nbsp;<code>Rear</code>,&nbsp;<code>isEmpty</code>, and&nbsp;<code>isFull</code>.</li>\n</ul>\n"}}, "623": {"__typename": "QuestionLightNode", "acRate": 0.6007435314011463, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "623", "isFavor": false, "solutionNum": 669, "title": "Add One Row to Tree", "titleCn": "在二叉树中增加一行", "titleSlug": "add-one-row-to-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 13, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二叉树的根&nbsp;<code>root</code>&nbsp;和两个整数 <code>val</code> 和&nbsp;<code>depth</code>&nbsp;，在给定的深度&nbsp;<code>depth</code>&nbsp;处添加一个值为 <code>val</code> 的节点行。</p>\n\n<p>注意，根节点&nbsp;<code>root</code>&nbsp;位于深度&nbsp;<code>1</code>&nbsp;。</p>\n\n<p>加法规则如下:</p>\n\n<ul>\n\t<li>给定整数&nbsp;<code>depth</code>，对于深度为&nbsp;<code>depth - 1</code> 的每个非空树节点 <code>cur</code> ，创建两个值为 <code>val</code> 的树节点作为 <code>cur</code> 的左子树根和右子树根。</li>\n\t<li><code>cur</code> 原来的左子树应该是新的左子树根的左子树。</li>\n\t<li><code>cur</code> 原来的右子树应该是新的右子树根的右子树。</li>\n\t<li>如果 <code>depth == 1 </code>意味着&nbsp;<code>depth - 1</code>&nbsp;根本没有深度，那么创建一个树节点，值 <code>val </code>作为整个原始树的新根，而原始树就是新根的左子树。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/03/15/addrow-tree.jpg\" style=\"height: 231px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [4,2,6,3,1,5], val = 1, depth = 2\n<strong>输出:</strong> [4,1,1,2,null,null,6,3,1,5]</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/03/11/add2-tree.jpg\" style=\"height: 277px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入:</strong> root = [4,2,null,3,1], val = 1, depth = 3\n<strong>输出:</strong>  [4,2,null,1,1,3,null,null,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>节点数在&nbsp;<code>[1, 10<sup>4</sup>]</code>&nbsp;范围内</li>\n\t<li>树的深度在&nbsp;<code>[1, 10<sup>4</sup>]</code>范围内</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= depth &lt;= the depth of tree + 1</code></li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree and two integers <code>val</code> and <code>depth</code>, add a row of nodes with value <code>val</code> at the given depth <code>depth</code>.</p>\n\n<p>Note that the <code>root</code> node is at depth <code>1</code>.</p>\n\n<p>The adding rule is:</p>\n\n<ul>\n\t<li>Given the integer <code>depth</code>, for each not null tree node <code>cur</code> at the depth <code>depth - 1</code>, create two tree nodes with value <code>val</code> as <code>cur</code>&#39;s left subtree root and right subtree root.</li>\n\t<li><code>cur</code>&#39;s original left subtree should be the left subtree of the new left subtree root.</li>\n\t<li><code>cur</code>&#39;s original right subtree should be the right subtree of the new right subtree root.</li>\n\t<li>If <code>depth == 1</code> that means there is no depth <code>depth - 1</code> at all, then create a tree node with value <code>val</code> as the new root of the whole original tree, and the original tree is the new root&#39;s left subtree.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/15/addrow-tree.jpg\" style=\"width: 500px; height: 231px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,6,3,1,5], val = 1, depth = 2\n<strong>Output:</strong> [4,1,1,2,null,null,6,3,1,5]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/11/add2-tree.jpg\" style=\"width: 500px; height: 277px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,null,3,1], val = 1, depth = 3\n<strong>Output:</strong> [4,2,null,1,1,3,null,null,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li>The depth of the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= val &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= depth &lt;= the depth of tree + 1</code></li>\n</ul>\n"}}, "624": {"__typename": "QuestionLightNode", "acRate": 0.4007722366951991, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "624", "isFavor": false, "solutionNum": 137, "title": "Maximum Distance in Arrays", "titleCn": "数组列表中的最大距离", "titleSlug": "maximum-distance-in-arrays", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 11, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/99a45f957529ef9ac7be507962ccee294f53b3cd87dc8163d18f16c1228e4a70-belo-cn-200x200-9518747d43e25d1834cda4cbe55464c5.png", "slug": "airbnb", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "625": {"__typename": "QuestionLightNode", "acRate": 0.34645974781765276, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "625", "isFavor": false, "solutionNum": 71, "title": "Minimum Factorization", "titleCn": "最小因式分解", "titleSlug": "minimum-factorization", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 2, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/d2e85988beccb271af4b1a8f4767e4bdf4c085aaf5aaef093347d778e4e138d7-20.png", "slug": "huawei", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode.cn/aliyun-lc-upload/uploaded_files/2023/01/e68645fd-9dd0-46ee-b97c-f4ad64a07848/3%26fmt%3Dauto%26app%3D120%26f%3DJPEG.webp", "slug": "tencent", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "626": {"__typename": "QuestionLightNode", "acRate": 0.686593605484957, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "626", "isFavor": false, "solutionNum": 756, "title": "Exchange Seats", "titleCn": "换座位", "titleSlug": "exchange-seats", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>表:&nbsp;<code>Seat</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| student     | varchar |\n+-------------+---------+\n<code>id</code> 是该表的主键（唯一值）列。\n该表的每一行都表示学生的姓名和 ID。\nid 是一个连续的增量。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>编写解决方案来交换每两个连续的学生的座位号。如果学生的数量是奇数，则最后一个学生的id不交换。</p>\n\n<p>按 <code>id</code> <strong>升序</strong> 返回结果表。</p>\n\n<p>查询结果格式如下所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> \nSeat 表:\n+----+---------+\n| id | student |\n+----+---------+\n| 1  | Abbot   |\n| 2  | Doris   |\n| 3  | Emerson |\n| 4  | Green   |\n| 5  | Jeames  |\n+----+---------+\n<strong>输出:</strong> \n+----+---------+\n| id | student |\n+----+---------+\n| 1  | Doris   |\n| 2  | Abbot   |\n| 3  | Green   |\n| 4  | Emerson |\n| 5  | Jeames  |\n+----+---------+\n<strong>解释:\n</strong>请注意，如果学生人数为奇数，则不需要更换最后一名学生的座位。</pre>\n", "en": "<p>Table: <code>Seat</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| student     | varchar |\n+-------------+---------+\nid is the primary key (unique value) column for this table.\nEach row of this table indicates the name and the ID of a student.\nid is a continuous increment.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to swap the seat id of every two consecutive students. If the number of students is odd, the id of the last student is not swapped.</p>\n\n<p>Return the result table ordered by <code>id</code> <strong>in ascending order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nSeat table:\n+----+---------+\n| id | student |\n+----+---------+\n| 1  | Abbot   |\n| 2  | Doris   |\n| 3  | Emerson |\n| 4  | Green   |\n| 5  | Jeames  |\n+----+---------+\n<strong>Output:</strong> \n+----+---------+\n| id | student |\n+----+---------+\n| 1  | Doris   |\n| 2  | Abbot   |\n| 3  | Green   |\n| 4  | Emerson |\n| 5  | Jeames  |\n+----+---------+\n<strong>Explanation:</strong> \nNote that if the number of students is odd, there is no need to change the last one&#39;s seat.\n</pre>\n"}}, "627": {"__typename": "QuestionLightNode", "acRate": 0.8233829874888875, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "627", "isFavor": false, "solutionNum": 696, "title": "Swap Salary", "titleCn": "变更性别", "titleSlug": "swap-salary", "topicTags": [{"id": "pzpd7s", "name": "Database", "slug": "database", "nameTranslated": "数据库", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 19, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<div class=\"original__bRMd\">\n<div>\n<p><code>Salary</code> 表：</p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| id          | int      |\n| name        | varchar  |\n| sex         | ENUM     |\n| salary      | int      |\n+-------------+----------+\nid 是这个表的主键（具有唯一值的列）。\nsex 这一列的值是 ENUM 类型，只能从 ('m', 'f') 中取。\n本表包含公司雇员的信息。\n</pre>\n\n<p>&nbsp;</p>\n\n<p>请你编写一个解决方案来交换所有的 <code>'f'</code> 和 <code>'m'</code> （即，将所有 <code>'f'</code> 变为 <code>'m'</code> ，反之亦然），仅使用 <strong>单个 update 语句</strong> ，且不产生中间临时表。</p>\n\n<p>注意，你必须仅使用一条 update 语句，且 <strong>不能</strong> 使用 select 语句。</p>\n\n<p>结果如下例所示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入：</strong>\nSalary 表：\n+----+------+-----+--------+\n| id | name | sex | salary |\n+----+------+-----+--------+\n| 1  | A    | m   | 2500   |\n| 2  | B    | f   | 1500   |\n| 3  | C    | m   | 5500   |\n| 4  | D    | f   | 500    |\n+----+------+-----+--------+\n<strong>输出：</strong>\n+----+------+-----+--------+\n| id | name | sex | salary |\n+----+------+-----+--------+\n| 1  | A    | f   | 2500   |\n| 2  | B    | m   | 1500   |\n| 3  | C    | f   | 5500   |\n| 4  | D    | m   | 500    |\n+----+------+-----+--------+\n<strong>解释：</strong>\n(1, A) 和 (3, C) 从 'm' 变为 'f' 。\n(2, B) 和 (4, D) 从 'f' 变为 'm' 。</pre>\n</div>\n</div>\n", "en": "<p>Table: <code>Salary</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| id          | int      |\n| name        | varchar  |\n| sex         | ENUM     |\n| salary      | int      |\n+-------------+----------+\nid is the primary key (column with unique values) for this table.\nThe sex column is ENUM (category) value of type (&#39;m&#39;, &#39;f&#39;).\nThe table contains information about an employee.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to swap all <code>&#39;f&#39;</code> and <code>&#39;m&#39;</code> values (i.e., change all <code>&#39;f&#39;</code> values to <code>&#39;m&#39;</code> and vice versa) with a <strong>single update statement</strong> and no intermediate temporary tables.</p>\n\n<p>Note that you must write a single update statement, <strong>do not</strong> write any select statement for this problem.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nSalary table:\n+----+------+-----+--------+\n| id | name | sex | salary |\n+----+------+-----+--------+\n| 1  | A    | m   | 2500   |\n| 2  | B    | f   | 1500   |\n| 3  | C    | m   | 5500   |\n| 4  | D    | f   | 500    |\n+----+------+-----+--------+\n<strong>Output:</strong> \n+----+------+-----+--------+\n| id | name | sex | salary |\n+----+------+-----+--------+\n| 1  | A    | f   | 2500   |\n| 2  | B    | m   | 1500   |\n| 3  | C    | f   | 5500   |\n| 4  | D    | m   | 500    |\n+----+------+-----+--------+\n<strong>Explanation:</strong> \n(1, A) and (3, C) were changed from &#39;m&#39; to &#39;f&#39;.\n(2, B) and (4, D) were changed from &#39;f&#39; to &#39;m&#39;.\n</pre>\n"}}, "628": {"__typename": "QuestionLightNode", "acRate": 0.5180344331166717, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "628", "isFavor": false, "solutionNum": 1174, "title": "Maximum Product of Three Numbers", "titleCn": "三个数的最大乘积", "titleSlug": "maximum-product-of-three-numbers", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 45, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整型数组 <code>nums</code> ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3]\n<strong>输出：</strong>6\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4]\n<strong>输出：</strong>24\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [-1,-2,-3]\n<strong>输出：</strong>-6\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>3 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-1000 <= nums[i] <= 1000</code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code>, <em>find three numbers whose product is maximum and return the maximum product</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> 6\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> 24\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [-1,-2,-3]\n<strong>Output:</strong> -6\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= nums.length &lt;=&nbsp;10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n"}}, "629": {"__typename": "QuestionLightNode", "acRate": 0.5060662573601827, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "629", "isFavor": false, "solutionNum": 220, "title": "K Inverse Pairs Array", "titleCn": "K 个逆序对数组", "titleSlug": "k-inverse-pairs-array", "topicTags": [{"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>对于一个整数数组&nbsp;<code>nums</code>，<strong>逆序对</strong>是一对满足 <code>0 &lt;= i &lt; j &lt; nums.length</code> 且&nbsp;<code>nums[i] &gt; nums[j]</code>的整数对&nbsp;<code>[i, j]</code>&nbsp;。</p>\n\n<p>给你两个整数&nbsp;<code>n</code>&nbsp;和&nbsp;<code>k</code>，找出所有包含从&nbsp;<code>1</code>&nbsp;到&nbsp;<code>n</code>&nbsp;的数字，且恰好拥有&nbsp;<code>k</code>&nbsp;个 <strong>逆序对</strong> 的不同的数组的个数。由于答案可能很大，只需要返回对 <code>10<sup>9</sup>&nbsp;+ 7</code> 取余的结果。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 0\n<strong>输出：</strong>1\n<strong>解释：</strong>\n只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>\n数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= k &lt;= 1000</code></li>\n</ul>\n", "en": "<p>For an integer array <code>nums</code>, an <strong>inverse pair</strong> is a pair of integers <code>[i, j]</code> where <code>0 &lt;= i &lt; j &lt; nums.length</code> and <code>nums[i] &gt; nums[j]</code>.</p>\n\n<p>Given two integers n and k, return the number of different arrays consisting of numbers from <code>1</code> to <code>n</code> such that there are exactly <code>k</code> <strong>inverse pairs</strong>. Since the answer can be huge, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, k = 0\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pairs.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, k = 1\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= k &lt;= 1000</code></li>\n</ul>\n"}}, "630": {"__typename": "QuestionLightNode", "acRate": 0.48550281508972437, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "630", "isFavor": false, "solutionNum": 344, "title": "Course Schedule III", "titleCn": "课程表 III", "titleSlug": "course-schedule-iii", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 25, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>这里有 <code>n</code> 门不同的在线课程，按从 <code>1</code> 到 <code>n</code>&nbsp;编号。给你一个数组 <code>courses</code> ，其中 <code>courses[i] = [duration<sub>i</sub>, lastDay<sub>i</sub>]</code> 表示第 <code>i</code> 门课将会 <strong>持续</strong> 上 <code>duration<sub>i</sub></code> 天课，并且必须在不晚于 <code>lastDay<sub>i</sub></code> 的时候完成。</p>\n\n<p>你的学期从第 <code>1</code> 天开始。且不能同时修读两门及两门以上的课程。</p>\n\n<p>返回你最多可以修读的课程数目。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>courses = [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]\n<strong>输出：</strong>3\n<strong>解释：</strong>\n这里一共有 4 门课程，但是你最多可以修 3 门：\n首先，修第 1 门课，耗费 100 天，在第 100 天完成，在第 101 天开始下门课。\n第二，修第 3 门课，耗费 1000 天，在第 1100 天完成，在第 1101 天开始下门课程。\n第三，修第 2 门课，耗时 200 天，在第 1300 天完成。\n第 4 门课现在不能修，因为将会在第 3300 天完成它，这已经超出了关闭日期。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>courses = [[1,2]]\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>courses = [[3,2],[4,3]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= courses.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= duration<sub>i</sub>, lastDay<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>There are <code>n</code> different online courses numbered from <code>1</code> to <code>n</code>. You are given an array <code>courses</code> where <code>courses[i] = [duration<sub>i</sub>, lastDay<sub>i</sub>]</code> indicate that the <code>i<sup>th</sup></code> course should be taken <b>continuously</b> for <code>duration<sub>i</sub></code> days and must be finished before or on <code>lastDay<sub>i</sub></code>.</p>\n\n<p>You will start on the <code>1<sup>st</sup></code> day and you cannot take two or more courses simultaneously.</p>\n\n<p>Return <em>the maximum number of courses that you can take</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]\n<strong>Output:</strong> 3\nExplanation: \nThere are totally 4 courses, but you can take 3 courses at most:\nFirst, take the 1<sup>st</sup> course, it costs 100 days so you will finish it on the 100<sup>th</sup> day, and ready to take the next course on the 101<sup>st</sup> day.\nSecond, take the 3<sup>rd</sup> course, it costs 1000 days so you will finish it on the 1100<sup>th</sup> day, and ready to take the next course on the 1101<sup>st</sup> day. \nThird, take the 2<sup>nd</sup> course, it costs 200 days so you will finish it on the 1300<sup>th</sup> day. \nThe 4<sup>th</sup> course cannot be taken now, since you will finish it on the 3300<sup>th</sup> day, which exceeds the closed date.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> courses = [[1,2]]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> courses = [[3,2],[4,3]]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= courses.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= duration<sub>i</sub>, lastDay<sub>i</sub> &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "631": {"__typename": "QuestionLightNode", "acRate": 0.34023503077783995, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "631", "isFavor": false, "solutionNum": 49, "title": "Design Excel Sum Formula", "titleCn": "设计 Excel 求和公式", "titleSlug": "design-excel-sum-formula", "topicTags": [{"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}, {"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "ns19t", "name": "Topological Sort", "slug": "topological-sort", "nameTranslated": "拓扑排序", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 14, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "632": {"__typename": "QuestionLightNode", "acRate": 0.6103744750093454, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "632", "isFavor": false, "solutionNum": 334, "title": "Smallest Range Covering Elements from K Lists", "titleCn": "最小区间", "titleSlug": "smallest-range-covering-elements-from-k-lists", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 27, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/cd6a63fa3f2839fe00cb7b0e8b9017e4d8a552e1c9bd2bfeda3a1611bfcb1266-pinterest-1-logo-png-transparent.png", "slug": "pinterest", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你有&nbsp;<code>k</code>&nbsp;个 <strong>非递减排列</strong> 的整数列表。找到一个 <strong>最小 </strong>区间，使得&nbsp;<code>k</code>&nbsp;个列表中的每个列表至少有一个数包含在其中。</p>\n\n<p>我们定义如果&nbsp;<code>b-a &lt; d-c</code>&nbsp;或者在&nbsp;<code>b-a == d-c</code>&nbsp;时&nbsp;<code>a &lt; c</code>，则区间 <code>[a,b]</code> 比 <code>[c,d]</code> 小。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\n<strong>输出：</strong>[20,24]\n<strong>解释：</strong> \n列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。\n列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。\n列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [[1,2,3],[1,2,3],[1,2,3]]\n<strong>输出：</strong>[1,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length == k</code></li>\n\t<li><code>1 &lt;= k &lt;= 3500</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 50</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> 按非递减顺序排列</li>\n</ul>\n\n<p>&nbsp;</p>\n", "en": "<p>You have <code>k</code> lists of sorted integers in <strong>non-decreasing&nbsp;order</strong>. Find the <b>smallest</b> range that includes at least one number from each of the <code>k</code> lists.</p>\n\n<p>We define the range <code>[a, b]</code> is smaller than range <code>[c, d]</code> if <code>b - a &lt; d - c</code> <strong>or</strong> <code>a &lt; c</code> if <code>b - a == d - c</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\n<strong>Output:</strong> [20,24]\n<strong>Explanation: </strong>\nList 1: [4, 10, 15, 24,26], 24 is in range [20,24].\nList 2: [0, 9, 12, 20], 20 is in range [20,24].\nList 3: [5, 18, 22, 30], 22 is in range [20,24].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[1,2,3],[1,2,3],[1,2,3]]\n<strong>Output:</strong> [1,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums.length == k</code></li>\n\t<li><code>1 &lt;= k &lt;= 3500</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 50</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code>&nbsp;is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n"}}, "633": {"__typename": "QuestionLightNode", "acRate": 0.38029801369546234, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "633", "isFavor": false, "solutionNum": 1066, "title": "Sum of Square Numbers", "titleCn": "平方数之和", "titleSlug": "sum-of-square-numbers", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 23, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个非负整数&nbsp;<code>c</code>&nbsp;，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得&nbsp;<code>a<sup>2</sup> + b<sup>2</sup> = c</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>c = 5\n<strong>输出：</strong>true\n<strong>解释：</strong>1 * 1 + 2 * 2 = 5\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>c = 3\n<strong>输出：</strong>false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= c &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given a non-negative integer <code>c</code>, decide whether there&#39;re two integers <code>a</code> and <code>b</code> such that <code>a<sup>2</sup> + b<sup>2</sup> = c</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> c = 5\n<strong>Output:</strong> true\n<strong>Explanation:</strong> 1 * 1 + 2 * 2 = 5\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> c = 3\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= c &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "634": {"__typename": "QuestionLightNode", "acRate": 0.46613407433136506, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "634", "isFavor": false, "solutionNum": 37, "title": "Find the Derangement of An Array", "titleCn": "寻找数组的错位排列", "titleSlug": "find-the-derangement-of-an-array", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 6, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608354389-Ejnhyo-alibaba.png", "slug": "alibaba", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1bb96b21aee51658cac9909be80203243b75485220d391f31b842da60df0bc83-512x512bb.jpg", "slug": "ixl", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "635": {"__typename": "QuestionLightNode", "acRate": 0.5573146465957263, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "635", "isFavor": false, "solutionNum": 112, "title": "Design Log Storage System", "titleCn": "设计日志存储系统", "titleSlug": "design-log-storage-system", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "qwy9jd", "name": "Ordered Set", "slug": "ordered-set", "nameTranslated": "有序集合", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937282-qSKaPF-Unknown-4.jpeg", "slug": "twitter", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "636": {"__typename": "QuestionLightNode", "acRate": 0.6635798621623066, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "636", "isFavor": false, "solutionNum": 365, "title": "Exclusive Time of Functions", "titleCn": "函数的独占时间", "titleSlug": "exclusive-time-of-functions", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 29, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>有一个 <strong>单线程</strong> CPU 正在运行一个含有 <code>n</code> 道函数的程序。每道函数都有一个位于&nbsp; <code>0</code> 和 <code>n-1</code> 之间的唯一标识符。</p>\n\n<p>函数调用 <strong>存储在一个 <a href=\"https://baike.baidu.com/item/%E8%B0%83%E7%94%A8%E6%A0%88/22718047?fr=aladdin\" target=\"_blank\">调用栈</a> 上</strong> ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 <strong>当前正在执行的函数</strong> 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。</p>\n\n<p>给你一个由日志组成的列表 <code>logs</code> ，其中 <code>logs[i]</code> 表示第 <code>i</code> 条日志消息，该消息是一个按 <code>\"{function_id}:{\"start\" | \"end\"}:{timestamp}\"</code> 进行格式化的字符串。例如，<code>\"0:start:3\"</code> 意味着标识符为 <code>0</code> 的函数调用在时间戳 <code>3</code> 的 <strong>起始开始执行</strong> ；而 <code>\"1:end:2\"</code> 意味着标识符为 <code>1</code> 的函数调用在时间戳 <code>2</code> 的 <strong>末尾结束执行</strong>。注意，函数可以 <strong>调用多次，可能存在递归调用 </strong>。</p>\n\n<p>函数的 <strong>独占时间</strong> 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 <code>2</code> 单位时间，另一次调用执行 <code>1</code> 单位时间，那么该函数的 <strong>独占时间</strong> 为 <code>2 + 1 = 3</code> 。</p>\n\n<p>以数组形式返回每个函数的 <strong>独占时间</strong> ，其中第 <code>i</code> 个下标对应的值表示标识符 <code>i</code> 的函数的独占时间。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/04/05/diag1b.png\" style=\"width: 550px; height: 239px;\" />\n<pre>\n<strong>输入：</strong>n = 2, logs = [\"0:start:0\",\"1:start:2\",\"1:end:5\",\"0:end:6\"]\n<strong>输出：</strong>[3,4]\n<strong>解释：</strong>\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 \n函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 \n函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。 \n所以函数 0 总共执行 2 + 1 = 3 个单位时间，函数 1 总共执行 4 个单位时间。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"0:start:6\",\"0:end:6\",\"0:end:7\"]\n<strong>输出：</strong>[8]\n<strong>解释：</strong>\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。\n函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。\n函数 0（初始调用）恢复执行，并立刻再次调用它自身。\n函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。\n函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。\n所以函数 0 总共执行 2 + 4 + 1 + 1 = 8 个单位时间。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, logs = [\"0:start:0\",\"0:start:2\",\"0:end:5\",\"1:start:6\",\"1:end:6\",\"0:end:7\"]\n<strong>输出：</strong>[7,1]\n<strong>解释：</strong>\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。\n函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。\n函数 0（初始调用）恢复执行，并立刻调用函数 1 。\n函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。\n函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。\n所以函数 0 总共执行 2 + 4 + 1 = 7 个单位时间，函数 1 总共执行 1 个单位时间。 </pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= logs.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= function_id &lt; n</code></li>\n\t<li><code>0 &lt;= timestamp &lt;= 10<sup>9</sup></code></li>\n\t<li>两个开始事件不会在同一时间戳发生</li>\n\t<li>两个结束事件不会在同一时间戳发生</li>\n\t<li>每道函数都有一个对应&nbsp;<code>\"start\"</code> 日志的 <code>\"end\"</code> 日志</li>\n</ul>\n", "en": "<p>On a <strong>single-threaded</strong> CPU, we execute a program containing <code>n</code> functions. Each function has a unique ID between <code>0</code> and <code>n-1</code>.</p>\n\n<p>Function calls are <strong>stored in a <a href=\"https://en.wikipedia.org/wiki/Call_stack\">call stack</a></strong>: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is <strong>the current function being executed</strong>. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.</p>\n\n<p>You are given a list <code>logs</code>, where <code>logs[i]</code> represents the <code>i<sup>th</sup></code> log message formatted as a string <code>&quot;{function_id}:{&quot;start&quot; | &quot;end&quot;}:{timestamp}&quot;</code>. For example, <code>&quot;0:start:3&quot;</code> means a function call with function ID <code>0</code> <strong>started at the beginning</strong> of timestamp <code>3</code>, and <code>&quot;1:end:2&quot;</code> means a function call with function ID <code>1</code> <strong>ended at the end</strong> of timestamp <code>2</code>. Note that a function can be called <b>multiple times, possibly recursively</b>.</p>\n\n<p>A function&#39;s <strong>exclusive time</strong> is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for <code>2</code> time units and another call executing for <code>1</code> time unit, the <strong>exclusive time</strong> is <code>2 + 1 = 3</code>.</p>\n\n<p>Return <em>the <strong>exclusive time</strong> of each function in an array, where the value at the </em><code>i<sup>th</sup></code><em> index represents the exclusive time for the function with ID </em><code>i</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/04/05/diag1b.png\" style=\"width: 550px; height: 239px;\" />\n<pre>\n<strong>Input:</strong> n = 2, logs = [&quot;0:start:0&quot;,&quot;1:start:2&quot;,&quot;1:end:5&quot;,&quot;0:end:6&quot;]\n<strong>Output:</strong> [3,4]\n<strong>Explanation:</strong>\nFunction 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.\nFunction 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.\nFunction 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.\nSo function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, logs = [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;0:start:6&quot;,&quot;0:end:6&quot;,&quot;0:end:7&quot;]\n<strong>Output:</strong> [8]\n<strong>Explanation:</strong>\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls itself again.\nFunction 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.\nFunction 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.\nSo function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2, logs = [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;1:start:6&quot;,&quot;1:end:6&quot;,&quot;0:end:7&quot;]\n<strong>Output:</strong> [7,1]\n<strong>Explanation:</strong>\nFunction 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.\nFunction 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\nFunction 0 (initial call) resumes execution then immediately calls function 1.\nFunction 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.\nFunction 0 resumes execution at the beginning of time 6 and executes for 2 units of time.\nSo function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= logs.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= function_id &lt; n</code></li>\n\t<li><code>0 &lt;= timestamp &lt;= 10<sup>9</sup></code></li>\n\t<li>No two start events will happen at the same timestamp.</li>\n\t<li>No two end events will happen at the same timestamp.</li>\n\t<li>Each function has an <code>&quot;end&quot;</code> log for each <code>&quot;start&quot;</code> log.</li>\n</ul>\n"}}, "637": {"__typename": "QuestionLightNode", "acRate": 0.7044052928822163, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "637", "isFavor": false, "solutionNum": 1206, "title": "Average of Levels in Binary Tree", "titleCn": "二叉树的层平均值", "titleSlug": "average-of-levels-in-binary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 24, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个非空二叉树的根节点<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;, 以数组的形式返回每一层节点的平均值。与实际答案相差&nbsp;<code>10<sup>-5</sup></code> 以内的答案可以被接受。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [3,9,20,null,null,15,7]\n<strong>输出：</strong>[3.00000,14.50000,11.00000]\n<strong>解释：</strong>第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。\n因此返回 [3, 14.5, 11] 。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [3,9,20,15,7]\n<strong>输出：</strong>[3.00000,14.50000,11.00000]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li>树中节点数量在&nbsp;<code>[1, 10<sup>4</sup>]</code> 范围内</li>\n\t<li><code>-2<sup>31</sup>&nbsp;&lt;= Node.val &lt;= 2<sup>31</sup>&nbsp;- 1</code></li>\n</ul>\n", "en": "Given the <code>root</code> of a binary tree, return <em>the average value of the nodes on each level in the form of an array</em>. Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg\" style=\"width: 277px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> [3.00000,14.50000,11.00000]\nExplanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.\nHence return [3, 14.5, 11].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg\" style=\"width: 292px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,15,7]\n<strong>Output:</strong> [3.00000,14.50000,11.00000]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-2<sup>31</sup> &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "638": {"__typename": "QuestionLightNode", "acRate": 0.6219246392127077, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "638", "isFavor": false, "solutionNum": 352, "title": "Shopping Offers", "titleCn": "大礼包", "titleSlug": "shopping-offers", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "vhos7", "name": "Memoization", "slug": "memoization", "nameTranslated": "记忆化搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "eeprrj", "name": "Bitmask", "slug": "bitmask", "nameTranslated": "状态压缩", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 18, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>在 LeetCode 商店中， 有 <code>n</code> 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。</p>\n\n<p>给你一个整数数组 <code>price</code> 表示物品价格，其中 <code>price[i]</code> 是第 <code>i</code> 件物品的价格。另有一个整数数组 <code>needs</code> 表示购物清单，其中 <code>needs[i]</code> 是需要购买第 <code>i</code> 件物品的数量。</p>\n\n<p>还有一个数组 <code>special</code> 表示大礼包，<code>special[i]</code> 的长度为 <code>n + 1</code> ，其中 <code>special[i][j]</code> 表示第 <code>i</code> 个大礼包中内含第 <code>j</code> 件物品的数量，且 <code>special[i][n]</code> （也就是数组中的最后一个整数）为第 <code>i</code> 个大礼包的价格。</p>\n\n<p>返回<strong> 确切 </strong>满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\n<strong>输出：</strong>14\n<strong>解释：</strong>有 A 和 B 两种物品，价格分别为 ¥2 和 ¥5 。 \n大礼包 1 ，你可以以 ¥5 的价格购买 3A 和 0B 。 \n大礼包 2 ，你可以以 ¥10 的价格购买 1A 和 2B 。 \n需要购买 3 个 A 和 2 个 B ， 所以付 ¥10 购买 1A 和 2B（大礼包 2），以及 ¥4 购买 2A 。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]\n<strong>输出：</strong>11\n<strong>解释：</strong>A ，B ，C 的价格分别为 ¥2 ，¥3 ，¥4 。\n可以用 ¥4 购买 1A 和 1B ，也可以用 ¥9 购买 2A ，2B 和 1C 。 \n需要买 1A ，2B 和 1C ，所以付 ¥4 买 1A 和 1B（大礼包 1），以及 ¥3 购买 1B ， ¥4 购买 1C 。 \n不可以购买超出待购清单的物品，尽管购买大礼包 2 更加便宜。</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == price.length</code></li>\n\t<li><code>n == needs.length</code></li>\n\t<li><code>1 <= n <= 6</code></li>\n\t<li><code>0 <= price[i] <= 10</code></li>\n\t<li><code>0 <= needs[i] <= 10</code></li>\n\t<li><code>1 <= special.length <= 100</code></li>\n\t<li><code>special[i].length == n + 1</code></li>\n\t<li><code>0 <= special[i][j] <= 50</code></li>\n</ul>\n", "en": "<p>In LeetCode Store, there are <code>n</code> items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.</p>\n\n<p>You are given an integer array <code>price</code> where <code>price[i]</code> is the price of the <code>i<sup>th</sup></code> item, and an integer array <code>needs</code> where <code>needs[i]</code> is the number of pieces of the <code>i<sup>th</sup></code> item you want to buy.</p>\n\n<p>You are also given an array <code>special</code> where <code>special[i]</code> is of size <code>n + 1</code> where <code>special[i][j]</code> is the number of pieces of the <code>j<sup>th</sup></code> item in the <code>i<sup>th</sup></code> offer and <code>special[i][n]</code> (i.e., the last integer in the array) is the price of the <code>i<sup>th</sup></code> offer.</p>\n\n<p>Return <em>the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers</em>. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\n<strong>Output:</strong> 14\n<strong>Explanation:</strong> There are two kinds of items, A and B. Their prices are $2 and $5 respectively. \nIn special offer 1, you can pay $5 for 3A and 0B\nIn special offer 2, you can pay $10 for 1A and 2B. \nYou need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> The price of A is $2, and $3 for B, $4 for C. \nYou may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. \nYou need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. \nYou cannot add more items, though only $9 for 2A ,2B and 1C.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == price.length == needs.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 6</code></li>\n\t<li><code>0 &lt;= price[i], needs[i] &lt;= 10</code></li>\n\t<li><code>1 &lt;= special.length &lt;= 100</code></li>\n\t<li><code>special[i].length == n + 1</code></li>\n\t<li><code>0 &lt;= special[i][j] &lt;= 50</code></li>\n</ul>\n"}}, "639": {"__typename": "QuestionLightNode", "acRate": 0.3687983695109958, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "639", "isFavor": false, "solutionNum": 334, "title": "Decode Ways II", "titleCn": "解码方法 II", "titleSlug": "decode-ways-ii", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>一条包含字母&nbsp;<code>A-Z</code> 的消息通过以下的方式进行了 <strong>编码</strong> ：</p>\n\n<pre>\n'A' -&gt; \"1\"\n'B' -&gt; \"2\"\n...\n'Z' -&gt; \"26\"</pre>\n\n<p>要 <strong>解码</strong> 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，<code>\"11106\"</code> 可以映射为：</p>\n\n<ul>\n\t<li><code>\"AAJF\"</code> 对应分组 <code>(1 1 10 6)</code></li>\n\t<li><code>\"KJF\"</code> 对应分组 <code>(11 10 6)</code></li>\n</ul>\n\n<p>注意，像 <code>(1 11 06)</code> 这样的分组是无效的，因为 <code>\"06\"</code> 不可以映射为 <code>'F'</code> ，因为 <code>\"6\"</code> 与 <code>\"06\"</code> 不同。</p>\n\n<p><strong>除了</strong> 上面描述的数字字母映射方案，编码消息中可能包含 <code>'*'</code> 字符，可以表示从 <code>'1'</code> 到 <code>'9'</code> 的任一数字（不包括 <code>'0'</code>）。例如，编码字符串 <code>\"1*\"</code> 可以表示 <code>\"11\"</code>、<code>\"12\"</code>、<code>\"13\"</code>、<code>\"14\"</code>、<code>\"15\"</code>、<code>\"16\"</code>、<code>\"17\"</code>、<code>\"18\"</code> 或 <code>\"19\"</code> 中的任意一条消息。对 <code>\"1*\"</code> 进行解码，相当于解码该字符串可以表示的任何编码消息。</p>\n\n<p>给你一个字符串 <code>s</code> ，由数字和 <code>'*'</code> 字符组成，返回 <strong>解码</strong> 该字符串的方法 <strong>数目</strong> 。</p>\n\n<p>由于答案数目可能非常大，返回&nbsp;<code>10<sup>9</sup> + 7</code>&nbsp;的&nbsp;<b>模</b>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"*\"\n<strong>输出：</strong>9\n<strong>解释：</strong>这一条编码消息可以表示 \"1\"、\"2\"、\"3\"、\"4\"、\"5\"、\"6\"、\"7\"、\"8\" 或 \"9\" 中的任意一条。\n可以分别解码成字符串 \"A\"、\"B\"、\"C\"、\"D\"、\"E\"、\"F\"、\"G\"、\"H\" 和 \"I\" 。\n因此，\"*\" 总共有 9 种解码方法。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"1*\"\n<strong>输出：</strong>18\n<strong>解释：</strong>这一条编码消息可以表示 \"11\"、\"12\"、\"13\"、\"14\"、\"15\"、\"16\"、\"17\"、\"18\" 或 \"19\" 中的任意一条。\n每种消息都可以由 2 种方法解码（例如，\"11\" 可以解码成 \"AA\" 或 \"K\"）。\n因此，\"1*\" 共有 9 * 2 = 18 种解码方法。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"2*\"\n<strong>输出：</strong>15\n<strong>解释：</strong>这一条编码消息可以表示 \"21\"、\"22\"、\"23\"、\"24\"、\"25\"、\"26\"、\"27\"、\"28\" 或 \"29\" 中的任意一条。\n\"21\"、\"22\"、\"23\"、\"24\"、\"25\" 和 \"26\" 由 2 种解码方法，但 \"27\"、\"28\" 和 \"29\" 仅有 1 种解码方法。\n因此，\"2*\" 共有 (6 * 2) + (3 * 1) = 12 + 3 = 15 种解码方法。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 是 <code>0 - 9</code> 中的一位数字或字符 <code>'*'</code></li>\n</ul>\n", "en": "<p>A message containing letters from <code>A-Z</code> can be <strong>encoded</strong> into numbers using the following mapping:</p>\n\n<pre>\n&#39;A&#39; -&gt; &quot;1&quot;\n&#39;B&#39; -&gt; &quot;2&quot;\n...\n&#39;Z&#39; -&gt; &quot;26&quot;\n</pre>\n\n<p>To <strong>decode</strong> an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, <code>&quot;11106&quot;</code> can be mapped into:</p>\n\n<ul>\n\t<li><code>&quot;AAJF&quot;</code> with the grouping <code>(1 1 10 6)</code></li>\n\t<li><code>&quot;KJF&quot;</code> with the grouping <code>(11 10 6)</code></li>\n</ul>\n\n<p>Note that the grouping <code>(1 11 06)</code> is invalid because <code>&quot;06&quot;</code> cannot be mapped into <code>&#39;F&#39;</code> since <code>&quot;6&quot;</code> is different from <code>&quot;06&quot;</code>.</p>\n\n<p><strong>In addition</strong> to the mapping above, an encoded message may contain the <code>&#39;*&#39;</code> character, which can represent any digit from <code>&#39;1&#39;</code> to <code>&#39;9&#39;</code> (<code>&#39;0&#39;</code> is excluded). For example, the encoded message <code>&quot;1*&quot;</code> may represent any of the encoded messages <code>&quot;11&quot;</code>, <code>&quot;12&quot;</code>, <code>&quot;13&quot;</code>, <code>&quot;14&quot;</code>, <code>&quot;15&quot;</code>, <code>&quot;16&quot;</code>, <code>&quot;17&quot;</code>, <code>&quot;18&quot;</code>, or <code>&quot;19&quot;</code>. Decoding <code>&quot;1*&quot;</code> is equivalent to decoding <strong>any</strong> of the encoded messages it can represent.</p>\n\n<p>Given a string <code>s</code> consisting of digits and <code>&#39;*&#39;</code> characters, return <em>the <strong>number</strong> of ways to <strong>decode</strong> it</em>.</p>\n\n<p>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;*&quot;\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> The encoded message can represent any of the encoded messages &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, or &quot;9&quot;.\nEach of these can be decoded to the strings &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, and &quot;I&quot; respectively.\nHence, there are a total of 9 ways to decode &quot;*&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1*&quot;\n<strong>Output:</strong> 18\n<strong>Explanation:</strong> The encoded message can represent any of the encoded messages &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, or &quot;19&quot;.\nEach of these encoded messages have 2 ways to be decoded (e.g. &quot;11&quot; can be decoded to &quot;AA&quot; or &quot;K&quot;).\nHence, there are a total of 9 * 2 = 18 ways to decode &quot;1*&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;2*&quot;\n<strong>Output:</strong> 15\n<strong>Explanation:</strong> The encoded message can represent any of the encoded messages &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, &quot;26&quot;, &quot;27&quot;, &quot;28&quot;, or &quot;29&quot;.\n&quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, and &quot;26&quot; have 2 ways of being decoded, but &quot;27&quot;, &quot;28&quot;, and &quot;29&quot; only have 1 way.\nHence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode &quot;2*&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is a digit or <code>&#39;*&#39;</code>.</li>\n</ul>\n"}}, "640": {"__typename": "QuestionLightNode", "acRate": 0.44419632632495076, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "640", "isFavor": false, "solutionNum": 729, "title": "Solve the Equation", "titleCn": "求解方程", "titleSlug": "solve-the-equation", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>求解一个给定的方程，将<code>x</code>以字符串 <code>\"x=#value\"</code>&nbsp;的形式返回。该方程仅包含 <code>'+'</code> ， <code>'-'</code> 操作，变量&nbsp;<code>x</code>&nbsp;和其对应系数。</p>\n\n<p>如果方程没有解或存在的解不为整数，请返回&nbsp;<code>\"No solution\"</code>&nbsp;。如果方程有无限解，则返回 <code>“Infinite solutions”</code> 。</p>\n\n<p>题目保证，如果方程中只有一个解，则 <font color=\"#c7254e\"><font face=\"Menlo, Monaco, Consolas, Courier New, monospace\"><span style=\"font-size:12.6px\"><span style=\"background-color:#f9f2f4\">'x'</span></span></font></font> 的值是一个整数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> equation = \"x+5-3+x=6+x-2\"\n<strong>输出:</strong> \"x=2\"\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> equation = \"x=x\"\n<strong>输出:</strong> \"Infinite solutions\"\n</pre>\n\n<p><strong>示例 3:</strong></p>\n\n<pre>\n<strong>输入:</strong> equation = \"2x=x\"\n<strong>输出:</strong> \"x=0\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= equation.length &lt;= 1000</code></li>\n\t<li><code>equation</code>&nbsp;只有一个&nbsp;<code>'='</code>.&nbsp;</li>\n\t<li>方程由绝对值在&nbsp;<code>[0, 100]</code>&nbsp; 范围内且无任何前导零的整数和变量 <code>'x'</code>&nbsp;组成。<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\">​​​</span></span></span></li>\n</ul>\n", "en": "<p>Solve a given equation and return the value of <code>&#39;x&#39;</code> in the form of a string <code>&quot;x=#value&quot;</code>. The equation contains only <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code> operation, the variable <code>&#39;x&#39;</code> and its coefficient. You should return <code>&quot;No solution&quot;</code> if there is no solution for the equation, or <code>&quot;Infinite solutions&quot;</code> if there are infinite solutions for the equation.</p>\n\n<p>If there is exactly one solution for the equation, we ensure that the value of <code>&#39;x&#39;</code> is an integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> equation = &quot;x+5-3+x=6+x-2&quot;\n<strong>Output:</strong> &quot;x=2&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> equation = &quot;x=x&quot;\n<strong>Output:</strong> &quot;Infinite solutions&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> equation = &quot;2x=x&quot;\n<strong>Output:</strong> &quot;x=0&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= equation.length &lt;= 1000</code></li>\n\t<li><code>equation</code> has exactly one <code>&#39;=&#39;</code>.</li>\n\t<li><code>equation</code> consists of integers with an absolute value in the range <code>[0, 100]</code> without any leading zeros, and the variable <code>&#39;x&#39;</code>.</li>\n</ul>\n"}}, "641": {"__typename": "QuestionLightNode", "acRate": 0.5675157180602911, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "641", "isFavor": false, "solutionNum": 672, "title": "Design Circular Deque", "titleCn": "设计循环双端队列", "titleSlug": "design-circular-deque", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "vxfk6", "name": "Queue", "slug": "queue", "nameTranslated": "队列", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 19, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>设计实现双端队列。</p>\n\n<p>实现 <code>MyCircularDeque</code> 类:</p>\n\n<ul>\n\t<li><code>MyCircularDeque(int k)</code>&nbsp;：构造函数,双端队列最大为 <code>k</code> 。</li>\n\t<li><code>boolean insertFront()</code>：将一个元素添加到双端队列头部。 如果操作成功返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n\t<li><code>boolean insertLast()</code>&nbsp;：将一个元素添加到双端队列尾部。如果操作成功返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n\t<li><code>boolean deleteFront()</code>&nbsp;：从双端队列头部删除一个元素。 如果操作成功返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n\t<li><code>boolean deleteLast()</code>&nbsp;：从双端队列尾部删除一个元素。如果操作成功返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n\t<li><code>int getFront()</code>&nbsp;)：从双端队列头部获得一个元素。如果双端队列为空，返回 <code>-1</code>&nbsp;。</li>\n\t<li><code>int getRear()</code>&nbsp;：获得双端队列的最后一个元素。&nbsp;如果双端队列为空，返回 <code>-1</code> 。</li>\n\t<li><code>boolean isEmpty()</code>&nbsp;：若双端队列为空，则返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code> &nbsp;。</li>\n\t<li><code>boolean isFull()</code>&nbsp;：若双端队列满了，则返回&nbsp;<code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n<strong>输出</strong>\n[null, true, true, true, false, 2, true, true, true, 4]\n\n<strong>解释</strong>\nMyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3\ncircularDeque.insertLast(1);\t\t\t        // 返回 true\ncircularDeque.insertLast(2);\t\t\t        // 返回 true\ncircularDeque.insertFront(3);\t\t\t        // 返回 true\ncircularDeque.insertFront(4);\t\t\t        // 已经满了，返回 false\ncircularDeque.getRear();  \t\t\t\t// 返回 2\ncircularDeque.isFull();\t\t\t\t        // 返回 true\ncircularDeque.deleteLast();\t\t\t        // 返回 true\ncircularDeque.insertFront(4);\t\t\t        // 返回 true\ncircularDeque.getFront();\t\t\t\t// 返回 4\n&nbsp;</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li><code>0 &lt;= value &lt;= 1000</code></li>\n\t<li><code>insertFront</code>,&nbsp;<code>insertLast</code>,&nbsp;<code>deleteFront</code>,&nbsp;<code>deleteLast</code>,&nbsp;<code>getFront</code>,&nbsp;<code>getRear</code>,&nbsp;<code>isEmpty</code>,&nbsp;<code>isFull</code>&nbsp; 调用次数不大于&nbsp;<code>2000</code>&nbsp;次</li>\n</ul>\n", "en": "<p>Design your implementation of the circular double-ended queue (deque).</p>\n\n<p>Implement the <code>MyCircularDeque</code> class:</p>\n\n<ul>\n\t<li><code>MyCircularDeque(int k)</code> Initializes the deque with a maximum size of <code>k</code>.</li>\n\t<li><code>boolean insertFront()</code> Adds an item at the front of Deque. Returns <code>true</code> if the operation is successful, or <code>false</code> otherwise.</li>\n\t<li><code>boolean insertLast()</code> Adds an item at the rear of Deque. Returns <code>true</code> if the operation is successful, or <code>false</code> otherwise.</li>\n\t<li><code>boolean deleteFront()</code> Deletes an item from the front of Deque. Returns <code>true</code> if the operation is successful, or <code>false</code> otherwise.</li>\n\t<li><code>boolean deleteLast()</code> Deletes an item from the rear of Deque. Returns <code>true</code> if the operation is successful, or <code>false</code> otherwise.</li>\n\t<li><code>int getFront()</code> Returns the front item from the Deque. Returns <code>-1</code> if the deque is empty.</li>\n\t<li><code>int getRear()</code> Returns the last item from Deque. Returns <code>-1</code> if the deque is empty.</li>\n\t<li><code>boolean isEmpty()</code> Returns <code>true</code> if the deque is empty, or <code>false</code> otherwise.</li>\n\t<li><code>boolean isFull()</code> Returns <code>true</code> if the deque is full, or <code>false</code> otherwise.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyCircularDeque&quot;, &quot;insertLast&quot;, &quot;insertLast&quot;, &quot;insertFront&quot;, &quot;insertFront&quot;, &quot;getRear&quot;, &quot;isFull&quot;, &quot;deleteLast&quot;, &quot;insertFront&quot;, &quot;getFront&quot;]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n<strong>Output</strong>\n[null, true, true, true, false, 2, true, true, true, 4]\n\n<strong>Explanation</strong>\nMyCircularDeque myCircularDeque = new MyCircularDeque(3);\nmyCircularDeque.insertLast(1);  // return True\nmyCircularDeque.insertLast(2);  // return True\nmyCircularDeque.insertFront(3); // return True\nmyCircularDeque.insertFront(4); // return False, the queue is full.\nmyCircularDeque.getRear();      // return 2\nmyCircularDeque.isFull();       // return True\nmyCircularDeque.deleteLast();   // return True\nmyCircularDeque.insertFront(4); // return True\nmyCircularDeque.getFront();     // return 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li><code>0 &lt;= value &lt;= 1000</code></li>\n\t<li>At most <code>2000</code> calls will be made to <code>insertFront</code>, <code>insertLast</code>, <code>deleteFront</code>, <code>deleteLast</code>, <code>getFront</code>, <code>getRear</code>, <code>isEmpty</code>, <code>isFull</code>.</li>\n</ul>\n"}}, "642": {"__typename": "QuestionLightNode", "acRate": 0.560281663336188, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "642", "isFavor": false, "solutionNum": 99, "title": "Design Search Autocomplete System", "titleCn": "设计搜索自动补全系统", "titleSlug": "design-search-autocomplete-system", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "pgti0i", "name": "Data Stream", "slug": "data-stream", "nameTranslated": "数据流", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 43, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "643": {"__typename": "QuestionLightNode", "acRate": 0.43086528455935325, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "643", "isFavor": false, "solutionNum": 1014, "title": "Maximum Average Subarray I", "titleCn": "子数组最大平均数 I", "titleSlug": "maximum-average-subarray-i", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 24, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个由 <code>n</code> 个元素组成的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>\n\n<p>请你找出平均数最大且 <strong>长度为 <code>k</code></strong> 的连续子数组，并输出该最大平均数。</p>\n\n<p>任何误差小于 <code>10<sup>-5</sup></code> 的答案都将被视为正确答案。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,12,-5,-6,50,3], k = 4\n<strong>输出：</strong>12.75\n<strong>解释：</strong>最大平均数 (12-5-6+50)/4 = 51/4 = 12.75\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [5], k = 1\n<strong>输出：</strong>5.00000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>You are given an integer array <code>nums</code> consisting of <code>n</code> elements, and an integer <code>k</code>.</p>\n\n<p>Find a contiguous subarray whose <strong>length is equal to</strong> <code>k</code> that has the maximum average value and return <em>this value</em>. Any answer with a calculation error less than <code>10<sup>-5</sup></code> will be accepted.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,12,-5,-6,50,3], k = 4\n<strong>Output:</strong> 12.75000\n<strong>Explanation:</strong> Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5], k = 1\n<strong>Output:</strong> 5.00000\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "644": {"__typename": "QuestionLightNode", "acRate": 0.4533985175839773, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "644", "isFavor": false, "solutionNum": 41, "title": "Maximum Average Subarray II", "titleCn": "子数组最大平均数 II", "titleSlug": "maximum-average-subarray-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "kr7kj3", "name": "Prefix Sum", "slug": "prefix-sum", "nameTranslated": "前缀和", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 8, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "645": {"__typename": "QuestionLightNode", "acRate": 0.39079408825815215, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "645", "isFavor": false, "solutionNum": 1136, "title": "Set Mismatch", "titleCn": "错误的集合", "titleSlug": "set-mismatch", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 20, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>集合 <code>s</code> 包含从 <code>1</code> 到 <code>n</code> 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 <strong>丢失了一个数字</strong> 并且 <strong>有一个数字重复</strong> 。</p>\n\n<p>给定一个数组 <code>nums</code> 代表了集合 <code>S</code> 发生错误后的结果。</p>\n\n<p>请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,4]\n<strong>输出：</strong>[2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1]\n<strong>输出：</strong>[1,2]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>2 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>1 <= nums[i] <= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>You have a set of integers <code>s</code>, which originally contains all the numbers from <code>1</code> to <code>n</code>. Unfortunately, due to some error, one of the numbers in <code>s</code> got duplicated to another number in the set, which results in <strong>repetition of one</strong> number and <strong>loss of another</strong> number.</p>\n\n<p>You are given an integer array <code>nums</code> representing the data status of this set after the error.</p>\n\n<p>Find the number that occurs twice and the number that is missing and return <em>them in the form of an array</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,2,4]\n<strong>Output:</strong> [2,3]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1]\n<strong>Output:</strong> [1,2]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "646": {"__typename": "QuestionLightNode", "acRate": 0.629947618268129, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "646", "isFavor": false, "solutionNum": 695, "title": "Maximum Length of Pair Chain", "titleCn": "最长数对链", "titleSlug": "maximum-length-of-pair-chain", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 21, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个由&nbsp;<code>n</code>&nbsp;个数对组成的数对数组&nbsp;<code>pairs</code>&nbsp;，其中&nbsp;<code>pairs[i] = [left<sub>i</sub>, right<sub>i</sub>]</code>&nbsp;且&nbsp;<code>left<sub>i</sub>&nbsp;&lt; right<sub>i</sub></code><sub> 。</sub></p>\n\n<p>现在，我们定义一种 <strong>跟随</strong> 关系，当且仅当&nbsp;<code>b &lt; c</code>&nbsp;时，数对&nbsp;<code>p2 = [c, d]</code>&nbsp;才可以跟在&nbsp;<code>p1 = [a, b]</code>&nbsp;后面。我们用这种形式来构造 <strong>数对链</strong> 。</p>\n\n<p>找出并返回能够形成的 <strong>最长数对链的长度</strong> 。</p>\n\n<p>你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>pairs =&nbsp;[[1,2], [2,3], [3,4]]\n<strong>输出：</strong>2\n<strong>解释：</strong>最长的数对链是 [1,2] -&gt; [3,4] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<b>输入：</b>pairs = [[1,2],[7,8],[4,5]]\n<b>输出：</b>3\n<b>解释：</b>最长的数对链是 [1,2] -&gt; [4,5] -&gt; [7,8] 。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == pairs.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= left<sub>i</sub>&nbsp;&lt; right<sub>i</sub>&nbsp;&lt;= 1000</code></li>\n</ul>\n", "en": "<p>You are given an array of <code>n</code> pairs <code>pairs</code> where <code>pairs[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> and <code>left<sub>i</sub> &lt; right<sub>i</sub></code>.</p>\n\n<p>A pair <code>p2 = [c, d]</code> <strong>follows</strong> a pair <code>p1 = [a, b]</code> if <code>b &lt; c</code>. A <strong>chain</strong> of pairs can be formed in this fashion.</p>\n\n<p>Return <em>the length longest chain which can be formed</em>.</p>\n\n<p>You do not need to use up all the given intervals. You can select pairs in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> pairs = [[1,2],[2,3],[3,4]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The longest chain is [1,2] -&gt; [3,4].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> pairs = [[1,2],[7,8],[4,5]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The longest chain is [1,2] -&gt; [4,5] -&gt; [7,8].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == pairs.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= left<sub>i</sub> &lt; right<sub>i</sub> &lt;= 1000</code></li>\n</ul>\n"}}, "647": {"__typename": "QuestionLightNode", "acRate": 0.6726653905163097, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "647", "isFavor": false, "solutionNum": 1873, "title": "Palindromic Substrings", "titleCn": "回文子串", "titleSlug": "palindromic-substrings", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 67, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p>\n\n<p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p>\n\n<p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p>\n\n<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\"\n<strong>输出：</strong>3\n<strong>解释：</strong>三个回文子串: \"a\", \"b\", \"c\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaa\"\n<strong>输出：</strong>6\n<strong>解释：</strong>6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n", "en": "<p>Given a string <code>s</code>, return <em>the number of <strong>palindromic substrings</strong> in it</em>.</p>\n\n<p>A string is a <strong>palindrome</strong> when it reads the same backward as forward.</p>\n\n<p>A <strong>substring</strong> is a contiguous sequence of characters within the string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abc&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aaa&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n"}}, "648": {"__typename": "QuestionLightNode", "acRate": 0.6355936965649008, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "648", "isFavor": false, "solutionNum": 879, "title": "Replace Words", "titleCn": "单词替换", "titleSlug": "replace-words", "topicTags": [{"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 19, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>在英语中，我们有一个叫做&nbsp;<strong>词根</strong>(root) 的概念，可以词根&nbsp;<strong>后面&nbsp;</strong>添加其他一些词组成另一个较长的单词——我们称这个词为 <strong>继承词</strong>&nbsp;(successor)。例如，词根&nbsp;<code>help</code>，跟随着 <strong>继承</strong>词&nbsp;<code>\"ful\"</code>，可以形成新的单词&nbsp;<code>\"helpful\"</code>。</p>\n\n<p>现在，给定一个由许多&nbsp;<strong>词根&nbsp;</strong>组成的词典 <code>dictionary</code> 和一个用空格分隔单词形成的句子 <code>sentence</code>。你需要将句子中的所有&nbsp;<strong>继承词&nbsp;</strong>用&nbsp;<strong>词根&nbsp;</strong>替换掉。如果&nbsp;<strong>继承词&nbsp;</strong>有许多可以形成它的&nbsp;<strong>词根</strong>，则用&nbsp;<strong>最短&nbsp;</strong>的 <strong>词根</strong> 替换它。</p>\n\n<p>你需要输出替换之后的句子。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"\n<strong>输出：</strong>\"the cat was rat by the bat\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"\n<strong>输出：</strong>\"a a b c\"\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= dictionary.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 100</code></li>\n\t<li><code>dictionary[i]</code>&nbsp;仅由小写字母组成。</li>\n\t<li><code>1 &lt;= sentence.length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>sentence</code>&nbsp;仅由小写字母和空格组成。</li>\n\t<li><code>sentence</code> 中单词的总量在范围 <code>[1, 1000]</code> 内。</li>\n\t<li><code>sentence</code> 中每个单词的长度在范围 <code>[1, 1000]</code> 内。</li>\n\t<li><code>sentence</code> 中单词之间由一个空格隔开。</li>\n\t<li><code>sentence</code>&nbsp;没有前导或尾随空格。</li>\n</ul>\n\n<p>&nbsp;</p>\n", "en": "<p>In English, we have a concept called <strong>root</strong>, which can be followed by some other word to form another longer word - let&#39;s call this word <strong>successor</strong>. For example, when the <strong>root</strong> <code>&quot;help&quot;</code> is followed by the <strong>successor</strong> word <code>&quot;ful&quot;</code>, we can form a new word <code>&quot;helpful&quot;</code>.</p>\n\n<p>Given a <code>dictionary</code> consisting of many <strong>roots</strong> and a <code>sentence</code> consisting of words separated by spaces, replace all the <strong>successors</strong> in the sentence with the <strong>root</strong> forming it. If a <strong>successor</strong> can be replaced by more than one <strong>root</strong>, replace it with the <strong>root</strong> that has <strong>the shortest length</strong>.</p>\n\n<p>Return <em>the <code>sentence</code></em> after the replacement.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> dictionary = [&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence = &quot;the cattle was rattled by the battery&quot;\n<strong>Output:</strong> &quot;the cat was rat by the bat&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> dictionary = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], sentence = &quot;aadsfasf absbs bbab cadsfafs&quot;\n<strong>Output:</strong> &quot;a a b c&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= dictionary.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= dictionary[i].length &lt;= 100</code></li>\n\t<li><code>dictionary[i]</code> consists of only lower-case letters.</li>\n\t<li><code>1 &lt;= sentence.length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>sentence</code> consists of only lower-case letters and spaces.</li>\n\t<li>The number of words in <code>sentence</code> is in the range <code>[1, 1000]</code></li>\n\t<li>The length of each word in <code>sentence</code> is in the range <code>[1, 1000]</code></li>\n\t<li>Every two consecutive words in <code>sentence</code> will be separated by exactly one space.</li>\n\t<li><code>sentence</code> does not have leading or trailing spaces.</li>\n</ul>\n"}}, "649": {"__typename": "QuestionLightNode", "acRate": 0.48834879649480867, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "649", "isFavor": false, "solutionNum": 476, "title": "Dota2 Senate", "titleCn": "Dota2 参议院", "titleSlug": "dota2-senate", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "vxfk6", "name": "Queue", "slug": "queue", "nameTranslated": "队列", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 11, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>Dota2 的世界里有两个阵营：<code>Radiant</code>（天辉）和&nbsp;<code>Dire</code>（夜魇）</p>\n\n<p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 <strong>一 </strong>项：</p>\n\n<ul>\n\t<li><strong>禁止一名参议员的权利</strong>：参议员可以让另一位参议员在这一轮和随后的几轮中丧失<strong> 所有的权利 </strong>。</li>\n\t<li><strong>宣布胜利</strong>：如果参议员发现有权利投票的参议员都是 <strong>同一个阵营的</strong> ，他可以宣布胜利并决定在游戏中的有关变化。</li>\n</ul>\n\n<p>给你一个字符串&nbsp;<code>senate</code> 代表每个参议员的阵营。字母 <code>'R'</code> 和 <code>'D'</code>分别代表了&nbsp;<code>Radiant</code>（天辉）和&nbsp;<code>Dire</code>（夜魇）。然后，如果有 <code>n</code> 个参议员，给定字符串的大小将是&nbsp;<code>n</code>。</p>\n\n<p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p>\n\n<p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是&nbsp;<code>\"Radiant\"</code> 或 <code>\"Dire\"</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>senate = \"RD\"\n<strong>输出：</strong>\"Radiant\"\n<strong>解释：\n</strong><code>第 1 轮时，第一个参议员来自 Radiant 阵营，他可以使用第一项权利让第二个参议员失去所有权利。\n这一轮中，第二个参议员将会被跳过，因为他的权利被禁止了。\n第 2 轮时，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人</code>。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>senate = \"RDD\"\n<strong>输出：</strong>\"Dire\"\n<strong>解释：</strong>\n第 1 轮时，第一个<code>来自 Radiant 阵营的</code>参议员可以使用第一项权利禁止第二个参议员的权利。\n<code>这一轮中，</code>第二个<code>来自 Dire 阵营的</code>参议员会将被跳过，因为他的权利被禁止了。\n<code>这一轮中，</code>第三个<code>来自 Dire 阵营的</code>参议员可以使用他的第一项权利禁止第一个参议员的权利。\n因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == senate.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>senate[i]</code> 为 <code>'R'</code> 或 <code>'D'</code></li>\n</ul>\n", "en": "<p>In the world of Dota2, there are two parties: the Radiant and the Dire.</p>\n\n<p>The Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise <strong>one</strong> of the two rights:</p>\n\n<ul>\n\t<li><strong>Ban one senator&#39;s right:</strong> A senator can make another senator lose all his rights in this and all the following rounds.</li>\n\t<li><strong>Announce the victory:</strong> If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.</li>\n</ul>\n\n<p>Given a string <code>senate</code> representing each senator&#39;s party belonging. The character <code>&#39;R&#39;</code> and <code>&#39;D&#39;</code> represent the Radiant party and the Dire party. Then if there are <code>n</code> senators, the size of the given string will be <code>n</code>.</p>\n\n<p>The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.</p>\n\n<p>Suppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be <code>&quot;Radiant&quot;</code> or <code>&quot;Dire&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> senate = &quot;RD&quot;\n<strong>Output:</strong> &quot;Radiant&quot;\n<strong>Explanation:</strong> \nThe first senator comes from Radiant and he can just ban the next senator&#39;s right in round 1. \nAnd the second senator can&#39;t exercise any rights anymore since his right has been banned. \nAnd in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> senate = &quot;RDD&quot;\n<strong>Output:</strong> &quot;Dire&quot;\n<strong>Explanation:</strong> \nThe first senator comes from Radiant and he can just ban the next senator&#39;s right in round 1. \nAnd the second senator can&#39;t exercise any rights anymore since his right has been banned. \nAnd the third senator comes from Dire and he can ban the first senator&#39;s right in round 1. \nAnd in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == senate.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>senate[i]</code> is either <code>&#39;R&#39;</code> or <code>&#39;D&#39;</code>.</li>\n</ul>\n"}}, "650": {"__typename": "QuestionLightNode", "acRate": 0.5783131534360924, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "650", "isFavor": false, "solutionNum": 804, "title": "2 Keys Keyboard", "titleCn": "两个键的键盘", "titleSlug": "2-keys-keyboard", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 28, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>最初记事本上只有一个字符 <code>'A'</code> 。你每次可以对这个记事本进行两种操作：</p>\n\n<ul>\n\t<li><code>Copy All</code>（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。</li>\n\t<li><code>Paste</code>（粘贴）：粘贴<strong> 上一次 </strong>复制的字符。</li>\n</ul>\n\n<p>给你一个数字&nbsp;<code>n</code> ，你需要使用最少的操作次数，在记事本上输出 <strong>恰好</strong>&nbsp;<code>n</code>&nbsp;个 <code>'A'</code> 。返回能够打印出&nbsp;<code>n</code>&nbsp;个 <code>'A'</code> 的最少操作次数。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>3\n<strong>输出：</strong>3\n<strong>解释：</strong>\n最初, 只有一个字符 'A'。\n第 1 步, 使用 <strong>Copy All</strong> 操作。\n第 2 步, 使用 <strong>Paste </strong>操作来获得 'AA'。\n第 3 步, 使用 <strong>Paste</strong> 操作来获得 'AAA'。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n", "en": "<p>There is only one character <code>&#39;A&#39;</code> on the screen of a notepad. You can perform one of two operations on this notepad for each step:</p>\n\n<ul>\n\t<li>Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).</li>\n\t<li>Paste: You can paste the characters which are copied last time.</li>\n</ul>\n\n<p>Given an integer <code>n</code>, return <em>the minimum number of operations to get the character</em> <code>&#39;A&#39;</code> <em>exactly</em> <code>n</code> <em>times on the screen</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Initially, we have one character &#39;A&#39;.\nIn step 1, we use Copy All operation.\nIn step 2, we use Paste operation to get &#39;AA&#39;.\nIn step 3, we use Paste operation to get &#39;AAA&#39;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n"}}, "651": {"__typename": "QuestionLightNode", "acRate": 0.6052512449071978, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "651", "isFavor": false, "solutionNum": 113, "title": "4 Keys Keyboard", "titleCn": "四个键的键盘", "titleSlug": "4-keys-keyboard", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/78703b3d3d17ff1b249303bec7cd53d61ba4d1ff309f4293600ea7efe8b692ae-salesforce.png", "slug": "salesforce", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "652": {"__typename": "QuestionLightNode", "acRate": 0.6135880094612103, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "652", "isFavor": false, "solutionNum": 663, "title": "Find Duplicate Subtrees", "titleCn": "寻找重复的子树", "titleSlug": "find-duplicate-subtrees", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 29, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一棵二叉树的根节点 <code>root</code> ，返回所有 <strong>重复的子树 </strong>。</p>\n\n<p>对于同一类的重复子树，你只需要返回其中任意 <strong>一棵 </strong>的根结点即可。</p>\n\n<p>如果两棵树具有<strong> 相同的结构</strong> 和 <strong>相同的结点值 </strong>，则认为二者是 <strong>重复 </strong>的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/16/e1.jpg\" style=\"height: 236px; width: 300px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,2,3,4,null,2,4,null,null,4]\n<strong>输出：</strong>[[2,4],[4]]</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/16/e2.jpg\" style=\"height: 125px; width: 200px;\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [2,1,1]\n<strong>输出：</strong>[[1]]</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/16/e33.jpg\" style=\"height: 202px; width: 300px;\" /></strong></p>\n\n<pre>\n<strong>输入：</strong>root = [2,2,2,3,null,3,null]\n<strong>输出：</strong>[[2,3],[3]]</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的结点数在 <code>[1, 5000]</code> 范围内。</li>\n\t<li><code>-200 &lt;= Node.val &lt;= 200</code></li>\n</ul>\n", "en": "<p>Given the <code>root</code>&nbsp;of a binary tree, return all <strong>duplicate subtrees</strong>.</p>\n\n<p>For each kind of duplicate subtrees, you only need to return the root node of any <b>one</b> of them.</p>\n\n<p>Two trees are <strong>duplicate</strong> if they have the <strong>same structure</strong> with the <strong>same node values</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/16/e1.jpg\" style=\"width: 450px; height: 354px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,null,2,4,null,null,4]\n<strong>Output:</strong> [[2,4],[4]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/16/e2.jpg\" style=\"width: 321px; height: 201px;\" />\n<pre>\n<strong>Input:</strong> root = [2,1,1]\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/16/e33.jpg\" style=\"width: 450px; height: 303px;\" />\n<pre>\n<strong>Input:</strong> root = [2,2,2,3,null,3,null]\n<strong>Output:</strong> [[2,3],[3]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of the nodes in the tree will be in the range <code>[1, 5000]</code></li>\n\t<li><code>-200 &lt;= Node.val &lt;= 200</code></li>\n</ul>\n"}}, "653": {"__typename": "QuestionLightNode", "acRate": 0.6353781654592688, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "653", "isFavor": false, "solutionNum": 1019, "title": "Two Sum IV - Input is a BST", "titleCn": "两数之和 IV - 输入二叉搜索树", "titleSlug": "two-sum-iv-input-is-a-bst", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 30, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二叉搜索树 <code>root</code> 和一个目标结果 <code>k</code>，如果二叉搜索树中存在两个元素且它们的和等于给定的目标结果，则返回 <code>true</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg\" style=\"height: 229px; width: 400px;\" />\n<pre>\n<strong>输入:</strong> root = [5,3,6,2,4,null,7], k = 9\n<strong>输出:</strong> true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg\" style=\"height: 229px; width: 400px;\" />\n<pre>\n<strong>输入:</strong> root = [5,3,6,2,4,null,7], k = 28\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>二叉树的节点个数的范围是&nbsp;&nbsp;<code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>题目数据保证，输入的 <code>root</code> 是一棵 <strong>有效</strong> 的二叉搜索树</li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary search tree and an integer <code>k</code>, return <code>true</code> <em>if there exist two elements in the BST such that their sum is equal to</em> <code>k</code>, <em>or</em> <code>false</code> <em>otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg\" style=\"width: 400px; height: 229px;\" />\n<pre>\n<strong>Input:</strong> root = [5,3,6,2,4,null,7], k = 9\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg\" style=\"width: 400px; height: 229px;\" />\n<pre>\n<strong>Input:</strong> root = [5,3,6,2,4,null,7], k = 28\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li><code>root</code> is guaranteed to be a <strong>valid</strong> binary search tree.</li>\n\t<li><code>-10<sup>5</sup> &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "654": {"__typename": "QuestionLightNode", "acRate": 0.8210727114745039, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "654", "isFavor": false, "solutionNum": 1792, "title": "Maximum Binary Tree", "titleCn": "最大二叉树", "titleSlug": "maximum-binary-tree", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dp403", "name": "Divide and Conquer", "slug": "divide-and-conquer", "nameTranslated": "分治", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}, {"id": "xeyj5r5", "name": "Monotonic Stack", "slug": "monotonic-stack", "nameTranslated": "单调栈", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 25, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个不重复的整数数组&nbsp;<code>nums</code> 。&nbsp;<strong>最大二叉树</strong>&nbsp;可以用下面的算法从&nbsp;<code>nums</code> 递归地构建:</p>\n\n<ol>\n\t<li>创建一个根节点，其值为&nbsp;<code>nums</code> 中的最大值。</li>\n\t<li>递归地在最大值&nbsp;<strong>左边</strong>&nbsp;的&nbsp;<strong>子数组前缀上</strong>&nbsp;构建左子树。</li>\n\t<li>递归地在最大值 <strong>右边</strong> 的&nbsp;<strong>子数组后缀上</strong>&nbsp;构建右子树。</li>\n</ol>\n\n<p>返回&nbsp;<em><code>nums</code> 构建的 </em><strong><em>最大二叉树</em> </strong>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg\" />\n<pre>\n<strong>输入：</strong>nums = [3,2,1,6,0,5]\n<strong>输出：</strong>[6,3,5,null,2,0,null,null,1]\n<strong>解释：</strong>递归调用如下所示：\n- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。\n    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。\n        - 空数组，无子节点。\n        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。\n            - 空数组，无子节点。\n            - 只有一个元素，所以子节点是一个值为 1 的节点。\n    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。\n        - 只有一个元素，所以子节点是一个值为 0 的节点。\n        - 空数组，无子节点。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg\" />\n<pre>\n<strong>输入：</strong>nums = [3,2,1]\n<strong>输出：</strong>[3,null,2,null,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>\n</ul>\n", "en": "<p>You are given an integer array <code>nums</code> with no duplicates. A <strong>maximum binary tree</strong> can be built recursively from <code>nums</code> using the following algorithm:</p>\n\n<ol>\n\t<li>Create a root node whose value is the maximum value in <code>nums</code>.</li>\n\t<li>Recursively build the left subtree on the <strong>subarray prefix</strong> to the <strong>left</strong> of the maximum value.</li>\n\t<li>Recursively build the right subtree on the <strong>subarray suffix</strong> to the <strong>right</strong> of the maximum value.</li>\n</ol>\n\n<p>Return <em>the <strong>maximum binary tree</strong> built from </em><code>nums</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg\" style=\"width: 302px; height: 421px;\" />\n<pre>\n<strong>Input:</strong> nums = [3,2,1,6,0,5]\n<strong>Output:</strong> [6,3,5,null,2,0,null,null,1]\n<strong>Explanation:</strong> The recursive calls are as follow:\n- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].\n    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].\n        - Empty array, so no child.\n        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].\n            - Empty array, so no child.\n            - Only one element, so child is a node with value 1.\n    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].\n        - Only one element, so child is a node with value 0.\n        - Empty array, so no child.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg\" style=\"width: 182px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> nums = [3,2,1]\n<strong>Output:</strong> [3,null,2,null,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li>All integers in <code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n"}}, "655": {"__typename": "QuestionLightNode", "acRate": 0.697560252681499, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "655", "isFavor": false, "solutionNum": 520, "title": "Print Binary Tree", "titleCn": "输出二叉树", "titleSlug": "print-binary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 22, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一棵二叉树的根节点 <code>root</code> ，请你构造一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的字符串矩阵 <code>res</code> ，用以表示树的 <strong>格式化布局</strong> 。构造此格式化布局矩阵需要遵循以下规则：</p>\n\n<ul>\n\t<li>树的 <strong>高度</strong> 为 <code>height</code> ，矩阵的行数 <code>m</code> 应该等于 <code>height + 1</code> 。</li>\n\t<li>矩阵的列数 <code>n</code> 应该等于 <code>2<sup>height+1</sup> - 1</code> 。</li>\n\t<li><strong>根节点</strong> 需要放置在 <strong>顶行</strong> 的 <strong>正中间</strong> ，对应位置为 <code>res[0][(n-1)/2]</code> 。</li>\n\t<li>对于放置在矩阵中的每个节点，设对应位置为 <code>res[r][c]</code> ，将其左子节点放置在 <code>res[r+1][c-2<sup>height-r-1</sup>]</code> ，右子节点放置在 <code>res[r+1][c+2<sup>height-r-1</sup>]</code> 。</li>\n\t<li>继续这一过程，直到树中的所有节点都妥善放置。</li>\n\t<li>任意空单元格都应该包含空字符串 <code>\"\"</code> 。</li>\n</ul>\n\n<p>返回构造得到的矩阵<em> </em><code>res</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/print1-tree.jpg\" style=\"width: 141px; height: 181px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2]\n<strong>输出：</strong>\n[[\"\",\"1\",\"\"],\n&nbsp;[\"2\",\"\",\"\"]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/print2-tree.jpg\" style=\"width: 207px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [1,2,3,null,4]\n<strong>输出：</strong>\n[[\"\",\"\",\"\",\"1\",\"\",\"\",\"\"],\n&nbsp;[\"\",\"2\",\"\",\"\",\"\",\"3\",\"\"],\n&nbsp;[\"\",\"\",\"4\",\"\",\"\",\"\",\"\"]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数在范围 <code>[1, 2<sup>10</sup>]</code> 内</li>\n\t<li><code>-99 &lt;= Node.val &lt;= 99</code></li>\n\t<li>树的深度在范围 <code>[1, 10]</code> 内</li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree, construct a <strong>0-indexed</strong> <code>m x n</code> string matrix <code>res</code> that represents a <strong>formatted layout</strong> of the tree. The formatted layout matrix should be constructed using the following rules:</p>\n\n<ul>\n\t<li>The <strong>height</strong> of the tree is <code>height</code>&nbsp;and the number of rows <code>m</code> should be equal to <code>height + 1</code>.</li>\n\t<li>The number of columns <code>n</code> should be equal to <code>2<sup>height+1</sup> - 1</code>.</li>\n\t<li>Place the <strong>root node</strong> in the <strong>middle</strong> of the <strong>top row</strong> (more formally, at location <code>res[0][(n-1)/2]</code>).</li>\n\t<li>For each node that has been placed in the matrix at position <code>res[r][c]</code>, place its <strong>left child</strong> at <code>res[r+1][c-2<sup>height-r-1</sup>]</code> and its <strong>right child</strong> at <code>res[r+1][c+2<sup>height-r-1</sup>]</code>.</li>\n\t<li>Continue this process until all the nodes in the tree have been placed.</li>\n\t<li>Any empty cells should contain the empty string <code>&quot;&quot;</code>.</li>\n</ul>\n\n<p>Return <em>the constructed matrix </em><code>res</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/print1-tree.jpg\" style=\"width: 141px; height: 181px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2]\n<strong>Output:</strong> \n[[&quot;&quot;,&quot;1&quot;,&quot;&quot;],\n&nbsp;[&quot;2&quot;,&quot;&quot;,&quot;&quot;]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/print2-tree.jpg\" style=\"width: 207px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,null,4]\n<strong>Output:</strong> \n[[&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;1&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;],\n&nbsp;[&quot;&quot;,&quot;2&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;3&quot;,&quot;&quot;],\n&nbsp;[&quot;&quot;,&quot;&quot;,&quot;4&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 2<sup>10</sup>]</code>.</li>\n\t<li><code>-99 &lt;= Node.val &lt;= 99</code></li>\n\t<li>The depth of the tree will be in the range <code>[1, 10]</code>.</li>\n</ul>\n"}}, "656": {"__typename": "QuestionLightNode", "acRate": 0.3471666315567727, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "656", "isFavor": false, "solutionNum": 37, "title": "Coin Path", "titleCn": "金币路径", "titleSlug": "coin-path", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 4, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "657": {"__typename": "QuestionLightNode", "acRate": 0.7930697869441024, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "657", "isFavor": false, "solutionNum": 939, "title": "Robot Return to Origin", "titleCn": "机器人能否返回原点", "titleSlug": "robot-return-to-origin", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 35, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>在二维平面上，有一个机器人从原点 <code>(0, 0)</code> 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在<strong>&nbsp;<code>(0, 0)</code> 处结束</strong>。</p>\n\n<p>移动顺序由字符串&nbsp;<code>moves</code>&nbsp;表示。字符 <code>move[i]</code> 表示其第 <code>i</code> 次移动。机器人的有效动作有&nbsp;<code>R</code>（右），<code>L</code>（左），<code>U</code>（上）和 <code>D</code>（下）。</p>\n\n<p>如果机器人在完成所有动作后返回原点，则返回 <code>true</code>。否则，返回 <code>false</code>。</p>\n\n<p><strong>注意：</strong>机器人“面朝”的方向无关紧要。 <code>“R”</code> 将始终使机器人向右移动一次，<code>“L”</code> 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> moves = \"UD\"\n<strong>输出:</strong> true\n<strong>解释：</strong>机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> moves = \"LL\"\n<strong>输出:</strong> false\n<strong>解释：</strong>机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= moves.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>moves</code>&nbsp;只包含字符&nbsp;<code>'U'</code>,&nbsp;<code>'D'</code>,&nbsp;<code>'L'</code>&nbsp;和&nbsp;<code>'R'</code></li>\n</ul>\n", "en": "<p>There is a robot starting at the position <code>(0, 0)</code>, the origin, on a 2D plane. Given a sequence of its moves, judge if this robot <strong>ends up at </strong><code>(0, 0)</code> after it completes its moves.</p>\n\n<p>You are given a string <code>moves</code> that represents the move sequence of the robot where <code>moves[i]</code> represents its <code>i<sup>th</sup></code> move. Valid moves are <code>&#39;R&#39;</code> (right), <code>&#39;L&#39;</code> (left), <code>&#39;U&#39;</code> (up), and <code>&#39;D&#39;</code> (down).</p>\n\n<p>Return <code>true</code><em> if the robot returns to the origin after it finishes all of its moves, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p><strong>Note</strong>: The way that the robot is &quot;facing&quot; is irrelevant. <code>&#39;R&#39;</code> will always make the robot move to the right once, <code>&#39;L&#39;</code> will always make it move left, etc. Also, assume that the magnitude of the robot&#39;s movement is the same for each move.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> moves = &quot;UD&quot;\n<strong>Output:</strong> true\n<strong>Explanation</strong>: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> moves = &quot;LL&quot;\n<strong>Output:</strong> false\n<strong>Explanation</strong>: The robot moves left twice. It ends up two &quot;moves&quot; to the left of the origin. We return false because it is not at the origin at the end of its moves.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= moves.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>moves</code> only contains the characters <code>&#39;U&#39;</code>, <code>&#39;D&#39;</code>, <code>&#39;L&#39;</code> and <code>&#39;R&#39;</code>.</li>\n</ul>\n"}}, "658": {"__typename": "QuestionLightNode", "acRate": 0.47827825994766543, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "658", "isFavor": false, "solutionNum": 875, "title": "Find K Closest Elements", "titleCn": "找到 K 个最接近的元素", "titleSlug": "find-k-closest-elements", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 41, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个 <strong>排序好</strong> 的数组&nbsp;<code>arr</code> ，两个整数 <code>k</code> 和 <code>x</code> ，从数组中找到最靠近 <code>x</code>（两数之差最小）的 <code>k</code> 个数。返回的结果必须要是按升序排好的。</p>\n\n<p>整数 <code>a</code> 比整数 <code>b</code> 更接近 <code>x</code> 需要满足：</p>\n\n<ul>\n\t<li><code>|a - x| &lt; |b - x|</code> 或者</li>\n\t<li><code>|a - x| == |b - x|</code> 且 <code>a &lt; b</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4,5], k = 4, x = 3\n<strong>输出：</strong>[1,2,3,4]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>arr = [1,2,3,4,5], k = 4, x = -1\n<strong>输出：</strong>[1,2,3,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= arr.length</code></li>\n\t<li><code>1 &lt;= arr.length&nbsp;&lt;= 10<sup>4</sup></code><meta charset=\"UTF-8\" /></li>\n\t<li><code>arr</code>&nbsp;按 <strong>升序</strong> 排列</li>\n\t<li><code>-10<sup>4</sup>&nbsp;&lt;= arr[i], x &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given a <strong>sorted</strong> integer array <code>arr</code>, two integers <code>k</code> and <code>x</code>, return the <code>k</code> closest integers to <code>x</code> in the array. The result should also be sorted in ascending order.</p>\n\n<p>An integer <code>a</code> is closer to <code>x</code> than an integer <code>b</code> if:</p>\n\n<ul>\n\t<li><code>|a - x| &lt; |b - x|</code>, or</li>\n\t<li><code>|a - x| == |b - x|</code> and <code>a &lt; b</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> arr = [1,2,3,4,5], k = 4, x = 3\n<strong>Output:</strong> [1,2,3,4]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> arr = [1,2,3,4,5], k = 4, x = -1\n<strong>Output:</strong> [1,2,3,4]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= arr.length</code></li>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>arr</code> is sorted in <strong>ascending</strong> order.</li>\n\t<li><code>-10<sup>4</sup> &lt;= arr[i], x &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "659": {"__typename": "QuestionLightNode", "acRate": 0.5513010784604729, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "659", "isFavor": false, "solutionNum": 410, "title": "Split Array into Consecutive Subsequences", "titleCn": "分割数组为连续子序列", "titleSlug": "split-array-into-consecutive-subsequences", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums</code> 。</p>\n\n<p>请你判断是否能在将 <code>nums</code> 分割成 <strong>一个或多个子序列</strong> 的同时满足下述 <strong>两个</strong> 条件：</p>\n\n<div class=\"original__bRMd\">\n<div>\n<ul>\n\t<li>每个子序列都是一个 <strong>连续递增序列</strong>（即，每个整数 <strong>恰好</strong> 比前一个整数大 <strong>1</strong> ）。</li>\n\t<li>所有子序列的长度 <strong>至少</strong> 为 <code>3</code><strong> </strong>。</li>\n</ul>\n\n<p>如果可以分割 <code>nums</code> 并满足上述条件，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,3,4,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>nums 可以分割成以下子序列：\n[<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>,3,4,5] --&gt; 1, 2, 3\n[1,2,3,<em><strong>3</strong></em>,<em><strong>4</strong></em>,<em><strong>5</strong></em>] --&gt; 3, 4, 5\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,3,4,4,5,5]\n<strong>输出：</strong>true\n<strong>解释：</strong>nums 可以分割成以下子序列：\n[<em><strong>1</strong></em>,<em><strong>2</strong></em>,<em><strong>3</strong></em>,3,<em><strong>4</strong></em>,4,<em><strong>5</strong></em>,5] --&gt; 1, 2, 3, 4, 5\n[1,2,3,<em><strong>3</strong></em>,4,<em><strong>4</strong></em>,5,<em><strong>5</strong></em>] --&gt; 3, 4, 5\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3,4,4,5]\n<strong>输出：</strong>false\n<strong>解释：</strong>无法将 nums 分割成长度至少为 3 的连续递增子序列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>提示：</b></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums</code> 按非递减顺序排列</li>\n</ul>\n", "en": "<p>You are given an integer array <code>nums</code> that is <strong>sorted in non-decreasing order</strong>.</p>\n\n<p>Determine if it is possible to split <code>nums</code> into <strong>one or more subsequences</strong> such that <strong>both</strong> of the following conditions are true:</p>\n\n<ul>\n\t<li>Each subsequence is a <strong>consecutive increasing sequence</strong> (i.e. each integer is <strong>exactly one</strong> more than the previous integer).</li>\n\t<li>All subsequences have a length of <code>3</code><strong> or more</strong>.</li>\n</ul>\n\n<p>Return <code>true</code><em> if you can split </em><code>nums</code><em> according to the above conditions, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>A <strong>subsequence</strong> of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., <code>[1,3,5]</code> is a subsequence of <code>[<u>1</u>,2,<u>3</u>,4,<u>5</u>]</code> while <code>[1,3,2]</code> is not).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,3,4,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> nums can be split into the following subsequences:\n[<strong><u>1</u></strong>,<strong><u>2</u></strong>,<strong><u>3</u></strong>,3,4,5] --&gt; 1, 2, 3\n[1,2,3,<strong><u>3</u></strong>,<strong><u>4</u></strong>,<strong><u>5</u></strong>] --&gt; 3, 4, 5\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,3,4,4,5,5]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> nums can be split into the following subsequences:\n[<strong><u>1</u></strong>,<strong><u>2</u></strong>,<strong><u>3</u></strong>,3,<strong><u>4</u></strong>,4,<strong><u>5</u></strong>,5] --&gt; 1, 2, 3, 4, 5\n[1,2,3,<strong><u>3</u></strong>,4,<strong><u>4</u></strong>,5,<strong><u>5</u></strong>] --&gt; 3, 4, 5\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,4,5]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> It is impossible to split nums into consecutive increasing subsequences of length 3 or more.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>nums</code> is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n"}}, "660": {"__typename": "QuestionLightNode", "acRate": 0.638199411022297, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "660", "isFavor": false, "solutionNum": 40, "title": "Remove 9", "titleCn": "移除 9", "titleSlug": "remove-9", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 4, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "661": {"__typename": "QuestionLightNode", "acRate": 0.6409602580448309, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "661", "isFavor": false, "solutionNum": 603, "title": "Image Smoother", "titleCn": "图片平滑器", "titleSlug": "image-smoother", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p><strong>图像平滑器</strong> 是大小为&nbsp;<code>3 x 3</code> 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。</p>\n\n<p>每个单元格的<strong>&nbsp; 平均灰度</strong> 定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。</p>\n\n<p>如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。</p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/05/03/smoother-grid.jpg\" style=\"height: 493px; width: 493px;\" /></p>\n\n<p>给你一个表示图像灰度的 <code>m x n</code> 整数矩阵 <code>img</code> ，返回对图像的每个单元格平滑处理后的图像&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2021/05/03/smooth-grid.jpg\" /></p>\n\n<pre>\n<strong>输入:</strong>img = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>输出:</strong>[[0, 0, 0],[0, 0, 0], [0, 0, 0]]\n<strong>解释:</strong>\n对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0\n对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0\n对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0\n</pre>\n\n<p><strong>示例 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/smooth2-grid.jpg\" />\n<pre>\n<strong>输入:</strong> img = [[100,200,100],[200,50,200],[100,200,100]]\n<strong>输出:</strong> [[137,141,137],[141,138,141],[137,141,137]]\n<strong>解释:</strong>\n对于点 (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\n对于点 (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\n对于点 (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>m == img.length</code></li>\n\t<li><code>n == img[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= img[i][j] &lt;= 255</code></li>\n</ul>\n", "en": "<p>An <strong>image smoother</strong> is a filter of the size <code>3 x 3</code> that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/smoother-grid.jpg\" style=\"width: 493px; height: 493px;\" />\n<p>Given an <code>m x n</code> integer matrix <code>img</code> representing the grayscale of an image, return <em>the image after applying the smoother on each cell of it</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/smooth-grid.jpg\" style=\"width: 613px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> img = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>Output:</strong> [[0,0,0],[0,0,0],[0,0,0]]\n<strong>Explanation:</strong>\nFor the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0\nFor the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0\nFor the point (1,1): floor(8/9) = floor(0.88888889) = 0\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/smooth2-grid.jpg\" style=\"width: 613px; height: 253px;\" />\n<pre>\n<strong>Input:</strong> img = [[100,200,100],[200,50,200],[100,200,100]]\n<strong>Output:</strong> [[137,141,137],[141,138,141],[137,141,137]]\n<strong>Explanation:</strong>\nFor the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\nFor the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\nFor the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == img.length</code></li>\n\t<li><code>n == img[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>0 &lt;= img[i][j] &lt;= 255</code></li>\n</ul>\n"}}, "662": {"__typename": "QuestionLightNode", "acRate": 0.43870456636642335, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "662", "isFavor": false, "solutionNum": 895, "title": "Maximum Width of Binary Tree", "titleCn": "二叉树最大宽度", "titleSlug": "maximum-width-of-binary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 37, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一棵二叉树的根节点 <code>root</code> ，返回树的 <strong>最大宽度</strong> 。</p>\n\n<p>树的 <strong>最大宽度</strong> 是所有层中最大的 <strong>宽度</strong> 。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>每一层的 <strong>宽度</strong> 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 <code>null</code> 节点，这些 <code>null</code> 节点也计入长度。</p>\n\n<p>题目数据保证答案将会在&nbsp; <strong>32 位</strong> 带符号整数范围内。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg\" style=\"width: 359px; height: 302px;\" />\n<pre>\n<strong>输入：</strong>root = [1,3,2,5,3,null,9]\n<strong>输出：</strong>4\n<strong>解释：</strong>最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-tree-v3.jpg\" style=\"width: 442px; height: 422px;\" />\n<pre>\n<strong>输入：</strong>root = [1,3,2,5,null,null,9,6,null,7]\n<strong>输出：</strong>7\n<strong>解释：</strong>最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg\" style=\"width: 289px; height: 299px;\" />\n<pre>\n<strong>输入：</strong>root = [1,3,2,5]\n<strong>输出：</strong>2\n<strong>解释：</strong>最大宽度出现在树的第 2 层，宽度为 2 (3,2) 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点的数目范围是 <code>[1, 3000]</code></li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>Given the <code>root</code> of a binary tree, return <em>the <strong>maximum width</strong> of the given tree</em>.</p>\n\n<p>The <strong>maximum width</strong> of a tree is the maximum <strong>width</strong> among all levels.</p>\n\n<p>The <strong>width</strong> of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation.</p>\n\n<p>It is <strong>guaranteed</strong> that the answer will in the range of a <strong>32-bit</strong> signed integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg\" style=\"width: 359px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [1,3,2,5,3,null,9]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The maximum width exists in the third level with length 4 (5,3,null,9).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-tree-v3.jpg\" style=\"width: 442px; height: 422px;\" />\n<pre>\n<strong>Input:</strong> root = [1,3,2,5,null,null,9,6,null,7]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg\" style=\"width: 289px; height: 299px;\" />\n<pre>\n<strong>Input:</strong> root = [1,3,2,5]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The maximum width exists in the second level with length 2 (3,2).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 3000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n"}}, "663": {"__typename": "QuestionLightNode", "acRate": 0.4579838116261957, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "663", "isFavor": false, "solutionNum": 60, "title": "Equal Tree Partition", "titleCn": "均匀树划分", "titleSlug": "equal-tree-partition", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/455700859e03a769dcb90fabbcce91f17af10954d6cab1b473c341ae8511915c-snapchat_logo1-300x300.png", "slug": "snapchat", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "664": {"__typename": "QuestionLightNode", "acRate": 0.653438324907163, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "664", "isFavor": false, "solutionNum": 246, "title": "Strange Printer", "titleCn": "奇怪的打印机", "titleSlug": "strange-printer", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 18, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>有台奇怪的打印机有以下两个特殊要求：</p>\n\n<ul>\n\t<li>打印机每次只能打印由 <strong>同一个字符</strong> 组成的序列。</li>\n\t<li>每次可以在从起始到结束的任意位置打印新字符，并且会覆盖掉原来已有的字符。</li>\n</ul>\n\n<p>给你一个字符串 <code>s</code> ，你的任务是计算这个打印机打印它需要的最少打印次数。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aaabbb\"\n<strong>输出：</strong>2\n<strong>解释：</strong>首先打印 \"aaa\" 然后打印 \"bbb\"。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aba\"\n<strong>输出：</strong>2\n<strong>解释：</strong>首先打印 \"aaa\" 然后在第二个位置打印 \"b\" 覆盖掉原来的字符 'a'。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n", "en": "<p>There is a strange printer with the following two special properties:</p>\n\n<ul>\n\t<li>The printer can only print a sequence of <strong>the same character</strong> each time.</li>\n\t<li>At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.</li>\n</ul>\n\n<p>Given a string <code>s</code>, return <em>the minimum number of turns the printer needed to print it</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aaabbb&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Print &quot;aaa&quot; first and then print &quot;bbb&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aba&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Print &quot;aaa&quot; first and then print &quot;b&quot; from the second place of the string, which will cover the existing character &#39;a&#39;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n"}}, "665": {"__typename": "QuestionLightNode", "acRate": 0.2790416096043824, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "665", "isFavor": false, "solutionNum": 1269, "title": "Non-decreasing Array", "titleCn": "非递减数列", "titleSlug": "non-decreasing-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 31, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个长度为&nbsp;<code>n</code>&nbsp;的整数数组<meta charset=\"UTF-8\" />&nbsp;<code>nums</code>&nbsp;，请你判断在 <strong>最多 </strong>改变&nbsp;<code>1</code> 个元素的情况下，该数组能否变成一个非递减数列。</p>\n\n<p>我们是这样定义一个非递减数列的：&nbsp;对于数组中任意的&nbsp;<code>i</code> <code>(0 &lt;= i &lt;= n-2)</code>，总满足 <code>nums[i] &lt;= nums[i + 1]</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [4,2,3]\n<strong>输出:</strong> true\n<strong>解释:</strong> 你可以通过把第一个 4 变成 1 来使得它成为一个非递减数列。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [4,2,1]\n<strong>输出:</strong> false\n<strong>解释:</strong> 你不能在只改变一个元素的情况下将其变为非递减数列。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n<meta charset=\"UTF-8\" />\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "en": "<p>Given an array <code>nums</code> with <code>n</code> integers, your task is to check if it could become non-decreasing by modifying <strong>at most one element</strong>.</p>\n\n<p>We define an array is non-decreasing if <code>nums[i] &lt;= nums[i + 1]</code> holds for every <code>i</code> (<strong>0-based</strong>) such that (<code>0 &lt;= i &lt;= n - 2</code>).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,2,3]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> You could modify the first 4 to 1 to get a non-decreasing array.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,2,1]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> You cannot get a non-decreasing array by modifying at most one element.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n"}}, "666": {"__typename": "QuestionLightNode", "acRate": 0.6240601503759399, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "666", "isFavor": false, "solutionNum": 115, "title": "Path Sum IV", "titleCn": "路径总和 IV", "titleSlug": "path-sum-iv", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/cd6a63fa3f2839fe00cb7b0e8b9017e4d8a552e1c9bd2bfeda3a1611bfcb1266-pinterest-1-logo-png-transparent.png", "slug": "pinterest", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "667": {"__typename": "QuestionLightNode", "acRate": 0.668329537649568, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "667", "isFavor": false, "solutionNum": 523, "title": "Beautiful Arrangement II", "titleCn": "优美的排列 II", "titleSlug": "beautiful-arrangement-ii", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 8, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你两个整数 <code>n</code> 和 <code>k</code> ，请你构造一个答案列表 <code>answer</code> ，该列表应当包含从 <code>1</code> 到 <code>n</code> 的 <code>n</code> 个不同正整数，并同时满足下述条件：</p>\n\n<ul>\n\t<li>假设该列表是 <code>answer = [a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ... , a<sub>n</sub>]</code> ，那么列表 <code>[|a<sub>1</sub> - a<sub>2</sub>|, |a<sub>2</sub> - a<sub>3</sub>|, |a<sub>3</sub> - a<sub>4</sub>|, ... , |a<sub>n-1</sub> - a<sub>n</sub>|]</code> 中应该有且仅有 <code>k</code> 个不同整数。</li>\n</ul>\n\n<p>返回列表 <code>answer</code> 。如果存在多种答案，只需返回其中 <strong>任意一种</strong> 。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 1\n<strong>输出：</strong>[1, 2, 3]\n<strong>解释：</strong>[1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, k = 2\n<strong>输出：</strong>[1, 3, 2]\n<strong>解释：</strong>[1, 3, 2] 包含 3 个范围在 1-3 的不同整数，并且 [2, 1] 中有且仅有 2 个不同整数：1 和 2\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= k < n <= 10<sup>4</sup></code></li>\n</ul>\n\n<p> </p>\n", "en": "<p>Given two integers <code>n</code> and <code>k</code>, construct a list <code>answer</code> that contains <code>n</code> different positive integers ranging from <code>1</code> to <code>n</code> and obeys the following requirement:</p>\n\n<ul>\n\t<li>Suppose this list is <code>answer =&nbsp;[a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ... , a<sub>n</sub>]</code>, then the list <code>[|a<sub>1</sub> - a<sub>2</sub>|, |a<sub>2</sub> - a<sub>3</sub>|, |a<sub>3</sub> - a<sub>4</sub>|, ... , |a<sub>n-1</sub> - a<sub>n</sub>|]</code> has exactly <code>k</code> distinct integers.</li>\n</ul>\n\n<p>Return <em>the list</em> <code>answer</code>. If there multiple valid answers, return <strong>any of them</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, k = 1\n<strong>Output:</strong> [1,2,3]\nExplanation: The [1,2,3] has three different positive integers ranging from 1 to 3, and the [1,1] has exactly 1 distinct integer: 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, k = 2\n<strong>Output:</strong> [1,3,2]\nExplanation: The [1,3,2] has three different positive integers ranging from 1 to 3, and the [2,1] has exactly 2 distinct integers: 1 and 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt; n &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "668": {"__typename": "QuestionLightNode", "acRate": 0.5865194675725073, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "668", "isFavor": false, "solutionNum": 284, "title": "Kth Smallest Number in Multiplication Table", "titleCn": "乘法表中第k小的数", "titleSlug": "kth-smallest-number-in-multiplication-table", "topicTags": [{"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 16, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1676258062-Lqtrvc-pdd.png", "slug": "pinduoduo", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>几乎每一个人都用&nbsp;<a href=\"https://baike.baidu.com/item/%E4%B9%98%E6%B3%95%E8%A1%A8\">乘法表</a>。但是你能在乘法表中快速找到第 <code>k</code> 小的数字吗？</p>\n\n<p>乘法表是大小为 <code>m x n</code> 的一个整数矩阵，其中&nbsp;<code>mat[i][j] == i * j</code>（下标从 <strong>1</strong> 开始）。</p>\n\n<p>给你三个整数 <code>m</code>、<code>n</code> 和 <code>k</code>，请你在大小为&nbsp;<code>m x n</code> 的乘法表中，找出并返回第 <code>k</code>&nbsp;小的数字。</p>\n\n<div class=\"original__bRMd\">\n<div>\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/02/multtable1-grid.jpg\" style=\"width: 500px; height: 254px;\" />\n<pre>\n<strong>输入：</strong>m = 3, n = 3, k = 5\n<strong>输出：</strong>3\n<strong>解释：</strong>第 5 小的数字是 3 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/02/multtable2-grid.jpg\" style=\"width: 493px; height: 293px;\" />\n<pre>\n<strong>输入：</strong>m = 2, n = 3, k = 6\n<strong>输出：</strong>6\n<strong>解释：</strong>第 6 小的数字是 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= m * n</code></li>\n</ul>\n</div>\n</div>\n", "en": "<p>Nearly everyone has used the <a href=\"https://en.wikipedia.org/wiki/Multiplication_table\" target=\"_blank\">Multiplication Table</a>. The multiplication table of size <code>m x n</code> is an integer matrix <code>mat</code> where <code>mat[i][j] == i * j</code> (<strong>1-indexed</strong>).</p>\n\n<p>Given three integers <code>m</code>, <code>n</code>, and <code>k</code>, return <em>the </em><code>k<sup>th</sup></code><em> smallest element in the </em><code>m x n</code><em> multiplication table</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/02/multtable1-grid.jpg\" style=\"width: 500px; height: 254px;\" />\n<pre>\n<strong>Input:</strong> m = 3, n = 3, k = 5\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The 5<sup>th</sup> smallest number is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/02/multtable2-grid.jpg\" style=\"width: 493px; height: 293px;\" />\n<pre>\n<strong>Input:</strong> m = 2, n = 3, k = 6\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The 6<sup>th</sup> smallest number is 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= m * n</code></li>\n</ul>\n"}}, "669": {"__typename": "QuestionLightNode", "acRate": 0.6707626938602081, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "669", "isFavor": false, "solutionNum": 1061, "title": "Trim a Binary Search Tree", "titleCn": "修剪二叉搜索树", "titleSlug": "trim-a-binary-search-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 24, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong>&nbsp;改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在&nbsp;<strong>唯一的答案</strong>&nbsp;。</p>\n\n<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg\" style=\"height: 126px; width: 450px;\" />\n<pre>\n<strong>输入：</strong>root = [1,0,2], low = 1, high = 2\n<strong>输出：</strong>[1,null,2]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg\" style=\"height: 277px; width: 450px;\" />\n<pre>\n<strong>输入：</strong>root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n<strong>输出：</strong>[3,2,null,1]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数在范围 <code>[1, 10<sup>4</sup>]</code> 内</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>树中每个节点的值都是 <strong>唯一</strong> 的</li>\n\t<li>题目数据保证输入是一棵有效的二叉搜索树</li>\n\t<li><code>0 &lt;= low &lt;= high &lt;= 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary search tree and the lowest and highest boundaries as <code>low</code> and <code>high</code>, trim the tree so that all its elements lies in <code>[low, high]</code>. Trimming the tree should <strong>not</strong> change the relative structure of the elements that will remain in the tree (i.e., any node&#39;s descendant should remain a descendant). It can be proven that there is a <strong>unique answer</strong>.</p>\n\n<p>Return <em>the root of the trimmed binary search tree</em>. Note that the root may change depending on the given bounds.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg\" style=\"width: 450px; height: 126px;\" />\n<pre>\n<strong>Input:</strong> root = [1,0,2], low = 1, high = 2\n<strong>Output:</strong> [1,null,2]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg\" style=\"width: 450px; height: 277px;\" />\n<pre>\n<strong>Input:</strong> root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n<strong>Output:</strong> [3,2,null,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>The value of each node in the tree is <strong>unique</strong>.</li>\n\t<li><code>root</code> is guaranteed to be a valid binary search tree.</li>\n\t<li><code>0 &lt;= low &lt;= high &lt;= 10<sup>4</sup></code></li>\n</ul>\n"}}, "670": {"__typename": "QuestionLightNode", "acRate": 0.4910397501540292, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "670", "isFavor": false, "solutionNum": 1180, "title": "Maximum Swap", "titleCn": "最大交换", "titleSlug": "maximum-swap", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 25, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个非负整数，你<strong>至多</strong>可以交换一次数字中的任意两位。返回你能得到的最大值。</p>\n\n<p><strong>示例 1 :</strong></p>\n\n<pre>\n<strong>输入:</strong> 2736\n<strong>输出:</strong> 7236\n<strong>解释:</strong> 交换数字2和数字7。\n</pre>\n\n<p><strong>示例 2 :</strong></p>\n\n<pre>\n<strong>输入:</strong> 9973\n<strong>输出:</strong> 9973\n<strong>解释:</strong> 不需要交换。\n</pre>\n\n<p><strong>注意:</strong></p>\n\n<ol>\n\t<li>给定数字的范围是&nbsp;[0, 10<sup>8</sup>]</li>\n</ol>\n", "en": "<p>You are given an integer <code>num</code>. You can swap two digits at most once to get the maximum valued number.</p>\n\n<p>Return <em>the maximum valued number you can get</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 2736\n<strong>Output:</strong> 7236\n<strong>Explanation:</strong> Swap the number 2 and the number 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = 9973\n<strong>Output:</strong> 9973\n<strong>Explanation:</strong> No swap.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 10<sup>8</sup></code></li>\n</ul>\n"}}, "671": {"__typename": "QuestionLightNode", "acRate": 0.4797029988650863, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "671", "isFavor": false, "solutionNum": 903, "title": "Second Minimum Node In a Binary Tree", "titleCn": "二叉树中第二小的节点", "titleSlug": "second-minimum-node-in-a-binary-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 21, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为&nbsp;<code>2</code>&nbsp;或&nbsp;<code>0</code>。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p>\n\n<p>更正式地说，即&nbsp;<code>root.val = min(root.left.val, root.right.val)</code> 总成立。</p>\n\n<p>给出这样的一个二叉树，你需要输出所有节点中的&nbsp;<strong>第二小的值 </strong>。</p>\n\n<p>如果第二小的值不存在的话，输出 -1 <strong>。</strong></p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg\" style=\"height: 210px; width: 300px;\" />\n<pre>\n<strong>输入：</strong>root = [2,2,5,null,null,5,7]\n<strong>输出：</strong>5\n<strong>解释：</strong>最小的值是 2 ，第二小的值是 5 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg\" style=\"height: 113px; width: 200px;\" />\n<pre>\n<strong>输入：</strong>root = [2,2,2]\n<strong>输出：</strong>-1\n<strong>解释：</strong>最小的值是 2, 但是不存在第二小的值。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数目在范围 <code>[1, 25]</code> 内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>对于树中每个节点 <code>root.val == min(root.left.val, root.right.val)</code></li>\n</ul>\n", "en": "<p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly <code>two</code> or <code>zero</code> sub-node. If the node has two sub-nodes, then this node&#39;s value is the smaller value among its two sub-nodes. More formally, the property&nbsp;<code>root.val = min(root.left.val, root.right.val)</code>&nbsp;always holds.</p>\n\n<p>Given such a binary tree, you need to output the <b>second minimum</b> value in the set made of all the nodes&#39; value in the whole tree.</p>\n\n<p>If no such second minimum value exists, output -1 instead.</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg\" style=\"width: 431px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [2,2,5,null,null,5,7]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The smallest value is 2, the second smallest value is 5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg\" style=\"width: 321px; height: 182px;\" />\n<pre>\n<strong>Input:</strong> root = [2,2,2]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> The smallest value is 2, but there isn&#39;t any second smallest value.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 25]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>root.val == min(root.left.val, root.right.val)</code>&nbsp;for each internal node of the tree.</li>\n</ul>\n"}}, "672": {"__typename": "QuestionLightNode", "acRate": 0.6074958087002559, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "672", "isFavor": false, "solutionNum": 265, "title": "Bulb Switcher II", "titleCn": "灯泡开关 Ⅱ", "titleSlug": "bulb-switcher-ii", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 11, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>房间中有 <code>n</code>&nbsp;只已经打开的灯泡，编号从 <code>1</code> 到 <code>n</code> 。墙上挂着 <strong>4 个开关</strong> 。</p>\n\n<p>这 4 个开关各自都具有不同的功能，其中：</p>\n\n<ul>\n\t<li><strong>开关 1 ：</strong>反转当前所有灯的状态（即开变为关，关变为开）</li>\n\t<li><strong>开关 2 ：</strong>反转编号为偶数的灯的状态（即 <code>0, 2, 4, ...</code>）</li>\n\t<li><strong>开关 3 ：</strong>反转编号为奇数的灯的状态（即 <code>1, 3, ...</code>）</li>\n\t<li><strong>开关 4 ：</strong>反转编号为 <code>j = 3k + 1</code> 的灯的状态，其中 <code>k = 0, 1, 2, ...</code>（即 <code>1, 4, 7, 10, ...</code>）</li>\n</ul>\n\n<p>你必须 <strong>恰好</strong> 按压开关 <code>presses</code> 次。每次按压，你都需要从 4 个开关中选出一个来执行按压操作。</p>\n\n<p>给你两个整数 <code>n</code> 和 <code>presses</code> ，执行完所有按压之后，返回 <strong>不同可能状态</strong> 的数量。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 1, presses = 1\n<strong>输出：</strong>2\n<strong>解释：</strong>状态可以是：\n- 按压开关 1 ，[关]\n- 按压开关 2 ，[开]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 2, presses = 1\n<strong>输出：</strong>3\n<strong>解释：</strong>状态可以是：\n- 按压开关 1 ，[关, 关]\n- 按压开关 2 ，[开, 关]\n- 按压开关 3 ，[关, 开]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 3, presses = 1\n<strong>输出：</strong>4\n<strong>解释：</strong>状态可以是：\n- 按压开关 1 ，[关, 关, 关]\n- 按压开关 2 ，[关, 开, 关]\n- 按压开关 3 ，[开, 关, 开]\n- 按压开关 4 ，[关, 开, 开]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= presses &lt;= 1000</code></li>\n</ul>\n", "en": "<p>There is a room with <code>n</code> bulbs labeled from <code>1</code> to <code>n</code> that all are turned on initially, and <strong>four buttons</strong> on the wall. Each of the four buttons has a different functionality where:</p>\n\n<ul>\n\t<li><strong>Button 1:</strong> Flips the status of all the bulbs.</li>\n\t<li><strong>Button 2:</strong> Flips the status of all the bulbs with even labels (i.e., <code>2, 4, ...</code>).</li>\n\t<li><strong>Button 3:</strong> Flips the status of all the bulbs with odd labels (i.e., <code>1, 3, ...</code>).</li>\n\t<li><strong>Button 4:</strong> Flips the status of all the bulbs with a label <code>j = 3k + 1</code> where <code>k = 0, 1, 2, ...</code> (i.e., <code>1, 4, 7, 10, ...</code>).</li>\n</ul>\n\n<p>You must make <strong>exactly</strong> <code>presses</code> button presses in total. For each press, you may pick <strong>any</strong> of the four buttons to press.</p>\n\n<p>Given the two integers <code>n</code> and <code>presses</code>, return <em>the number of <strong>different possible statuses</strong> after performing all </em><code>presses</code><em> button presses</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, presses = 1\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Status can be:\n- [off] by pressing button 1\n- [on] by pressing button 2\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2, presses = 1\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Status can be:\n- [off, off] by pressing button 1\n- [on, off] by pressing button 2\n- [off, on] by pressing button 3\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, presses = 1\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Status can be:\n- [off, off, off] by pressing button 1\n- [off, on, off] by pressing button 2\n- [on, off, on] by pressing button 3\n- [off, on, on] by pressing button 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= presses &lt;= 1000</code></li>\n</ul>\n"}}, "673": {"__typename": "QuestionLightNode", "acRate": 0.44822152183701036, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "673", "isFavor": false, "solutionNum": 719, "title": "Number of Longest Increasing Subsequence", "titleCn": "最长递增子序列的个数", "titleSlug": "number-of-longest-increasing-subsequence", "topicTags": [{"id": "n16hs", "name": "Binary Indexed Tree", "slug": "binary-indexed-tree", "nameTranslated": "树状数组", "__typename": "CommonTagNode"}, {"id": "nytfd", "name": "Segment Tree", "slug": "segment-tree", "nameTranslated": "线段树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 38, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个未排序的整数数组<meta charset=\"UTF-8\" />&nbsp;<code>nums</code>&nbsp;，&nbsp;<em>返回最长递增子序列的个数</em>&nbsp;。</p>\n\n<p><strong>注意</strong>&nbsp;这个数列必须是 <strong>严格</strong> 递增的。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> [1,3,5,4,7]\n<strong>输出:</strong> 2\n<strong>解释:</strong> 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> [2,2,2,2,2]\n<strong>输出:</strong> 5\n<strong>解释:</strong> 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong>&nbsp;</p>\n\n<p><meta charset=\"UTF-8\" /></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup>&nbsp;&lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n", "en": "<p>Given an integer array&nbsp;<code>nums</code>, return <em>the number of longest increasing subsequences.</em></p>\n\n<p><strong>Notice</strong> that the sequence has to be <strong>strictly</strong> increasing.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,4,7]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,2,2,2]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n"}}, "674": {"__typename": "QuestionLightNode", "acRate": 0.5707120510219283, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "674", "isFavor": false, "solutionNum": 1451, "title": "Longest Continuous Increasing Subsequence", "titleCn": "最长连续递增序列", "titleSlug": "longest-continuous-increasing-subsequence", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 37, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个未经排序的整数数组，找到最长且<strong> 连续递增的子序列</strong>，并返回该序列的长度。</p>\n\n<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l < r</code>）确定，如果对于每个 <code>l <= i < r</code>，都有 <code>nums[i] < nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,5,4,7]\n<strong>输出：</strong>3\n<strong>解释：</strong>最长连续递增序列是 [1,3,5], 长度为3。\n尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 \n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [2,2,2,2,2]\n<strong>输出：</strong>1\n<strong>解释：</strong>最长连续递增序列是 [2], 长度为1。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest <strong>continuous increasing subsequence</strong> (i.e. subarray)</em>. The subsequence must be <strong>strictly</strong> increasing.</p>\n\n<p>A <strong>continuous increasing subsequence</strong> is defined by two indices <code>l</code> and <code>r</code> (<code>l &lt; r</code>) such that it is <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> and for each <code>l &lt;= i &lt; r</code>, <code>nums[i] &lt; nums[i + 1]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,5,4,7]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The longest continuous increasing subsequence is [1,3,5] with length 3.\nEven though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element\n4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,2,2,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly\nincreasing.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n"}}, "675": {"__typename": "QuestionLightNode", "acRate": 0.5162301068482034, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "675", "isFavor": false, "solutionNum": 221, "title": "Cut Off Trees for Golf Event", "titleCn": "为高尔夫比赛砍树", "titleSlug": "cut-off-trees-for-golf-event", "topicTags": [{"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 13, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 <code>m x n</code> 的矩阵表示， 在这个矩阵中：</p>\n\n<ul>\n\t<li><code>0</code> 表示障碍，无法触碰</li>\n\t<li><code>1</code> 表示地面，可以行走</li>\n\t<li><code>比 1 大的数</code> 表示有树的单元格，可以行走，数值表示树的高度</li>\n</ul>\n\n<p>每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。</p>\n\n<p>你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 <code>1</code>（即变为地面）。</p>\n\n<p>你将从 <code>(0, 0)</code> 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 <code>-1</code> 。</p>\n\n<p>可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>forest = [[1,2,3],[0,0,4],[7,6,5]]\n<strong>输出：</strong>6\n<strong>解释：</strong>沿着上面的路径，你可以用 6 步，按从最矮到最高的顺序砍掉这些树。</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>输入：</strong>forest = [[1,2,3],[0,0,0],[7,6,5]]\n<strong>输出：</strong>-1\n<strong>解释：</strong>由于中间一行被障碍阻塞，无法访问最下面一行中的树。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>forest = [[2,3,4],[0,0,5],[8,7,6]]\n<strong>输出：</strong>6\n<strong>解释：</strong>可以按与示例 1 相同的路径来砍掉所有的树。\n(0,0) 位置的树，可以直接砍去，不用算步数。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == forest.length</code></li>\n\t<li><code>n == forest[i].length</code></li>\n\t<li><code>1 <= m, n <= 50</code></li>\n\t<li><code>0 <= forest[i][j] <= 10<sup>9</sup></code></li>\n</ul>\n", "en": "<p>You are asked to cut off all the trees in a forest for a golf event. The forest is represented as an <code>m x n</code> matrix. In this matrix:</p>\n\n<ul>\n\t<li><code>0</code> means the cell cannot be walked through.</li>\n\t<li><code>1</code> represents an empty cell that can be walked through.</li>\n\t<li>A number greater than <code>1</code> represents a tree in a cell that can be walked through, and this number is the tree&#39;s height.</li>\n</ul>\n\n<p>In one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.</p>\n\n<p>You must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes <code>1</code> (an empty cell).</p>\n\n<p>Starting from the point <code>(0, 0)</code>, return <em>the minimum steps you need to walk to cut off all the trees</em>. If you cannot cut off all the trees, return <code>-1</code>.</p>\n\n<p><strong>Note:</strong> The input is generated such that no two trees have the same height, and there is at least one tree needs to be cut off.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> forest = [[1,2,3],[0,0,4],[7,6,5]]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> forest = [[1,2,3],[0,0,0],[7,6,5]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> The trees in the bottom row cannot be accessed as the middle row is blocked.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> forest = [[2,3,4],[0,0,5],[8,7,6]]\n<strong>Output:</strong> 6\n<b>Explanation:</b> You can follow the same path as Example 1 to cut off all the trees.\nNote that you can cut off the first tree at (0, 0) before making any steps.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == forest.length</code></li>\n\t<li><code>n == forest[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>0 &lt;= forest[i][j] &lt;= 10<sup>9</sup></code></li>\n\t<li>Heights of all trees are <strong>distinct</strong>.</li>\n</ul>\n"}}, "676": {"__typename": "QuestionLightNode", "acRate": 0.652615365270967, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "676", "isFavor": false, "solutionNum": 485, "title": "Implement Magic Dictionary", "titleCn": "实现一个魔法字典", "titleSlug": "implement-magic-dictionary", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 12, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 <strong>互不相同</strong> 。 如果给出一个单词，请判定能否只将这个单词中<strong>一个</strong>字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。</p>\n\n<p>实现 <code>MagicDictionary</code> 类：</p>\n\n<ul>\n\t<li><code>MagicDictionary()</code> 初始化对象</li>\n\t<li><code>void buildDict(String[] dictionary)</code> 使用字符串数组 <code>dictionary</code> 设定该数据结构，<code>dictionary</code> 中的字符串互不相同</li>\n\t<li><code>bool search(String searchWord)</code> 给定一个字符串 <code>searchWord</code> ，判定能否只将字符串中<strong> 一个 </strong>字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n\n<p> </p>\n\n<div class=\"top-view__1vxA\">\n<div class=\"original__bRMd\">\n<div>\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"]\n[[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\n<strong>输出</strong>\n[null, null, false, true, false, false]\n\n<strong>解释</strong>\nMagicDictionary magicDictionary = new MagicDictionary();\nmagicDictionary.buildDict([\"hello\", \"leetcode\"]);\nmagicDictionary.search(\"hello\"); // 返回 False\nmagicDictionary.search(\"hhllo\"); // 将第二个 'h' 替换为 'e' 可以匹配 \"hello\" ，所以返回 True\nmagicDictionary.search(\"hell\"); // 返回 False\nmagicDictionary.search(\"leetcoded\"); // 返回 False\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= dictionary.length <= 100</code></li>\n\t<li><code>1 <= dictionary[i].length <= 100</code></li>\n\t<li><code>dictionary[i]</code> 仅由小写英文字母组成</li>\n\t<li><code>dictionary</code> 中的所有字符串 <strong>互不相同</strong></li>\n\t<li><code>1 <= searchWord.length <= 100</code></li>\n\t<li><code>searchWord</code> 仅由小写英文字母组成</li>\n\t<li><code>buildDict</code> 仅在 <code>search</code> 之前调用一次</li>\n\t<li>最多调用 <code>100</code> 次 <code>search</code></li>\n</ul>\n</div>\n</div>\n</div>\n", "en": "<p>Design a data structure that is initialized with a list of <strong>different</strong> words. Provided a string, you should determine if you can change exactly one character in this string to match any word in the data structure.</p>\n\n<p>Implement the&nbsp;<code>MagicDictionary</code>&nbsp;class:</p>\n\n<ul>\n\t<li><code>MagicDictionary()</code>&nbsp;Initializes the object.</li>\n\t<li><code>void buildDict(String[]&nbsp;dictionary)</code>&nbsp;Sets the data structure&nbsp;with an array of distinct strings <code>dictionary</code>.</li>\n\t<li><code>bool search(String searchWord)</code> Returns <code>true</code> if you can change <strong>exactly one character</strong> in <code>searchWord</code> to match any string in the data structure, otherwise returns <code>false</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MagicDictionary&quot;, &quot;buildDict&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;]\n[[], [[&quot;hello&quot;, &quot;leetcode&quot;]], [&quot;hello&quot;], [&quot;hhllo&quot;], [&quot;hell&quot;], [&quot;leetcoded&quot;]]\n<strong>Output</strong>\n[null, null, false, true, false, false]\n\n<strong>Explanation</strong>\nMagicDictionary magicDictionary = new MagicDictionary();\nmagicDictionary.buildDict([&quot;hello&quot;, &quot;leetcode&quot;]);\nmagicDictionary.search(&quot;hello&quot;); // return False\nmagicDictionary.search(&quot;hhllo&quot;); // We can change the second &#39;h&#39; to &#39;e&#39; to match &quot;hello&quot; so we return True\nmagicDictionary.search(&quot;hell&quot;); // return False\nmagicDictionary.search(&quot;leetcoded&quot;); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;=&nbsp;dictionary.length &lt;= 100</code></li>\n\t<li><code>1 &lt;=&nbsp;dictionary[i].length &lt;= 100</code></li>\n\t<li><code>dictionary[i]</code> consists of only lower-case English letters.</li>\n\t<li>All the strings in&nbsp;<code>dictionary</code>&nbsp;are <strong>distinct</strong>.</li>\n\t<li><code>1 &lt;=&nbsp;searchWord.length &lt;= 100</code></li>\n\t<li><code>searchWord</code>&nbsp;consists of only lower-case English letters.</li>\n\t<li><code>buildDict</code>&nbsp;will be called only once before <code>search</code>.</li>\n\t<li>At most <code>100</code> calls will be made to <code>search</code>.</li>\n</ul>\n"}}, "677": {"__typename": "QuestionLightNode", "acRate": 0.6550056773963078, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "677", "isFavor": false, "solutionNum": 719, "title": "Map Sum Pairs", "titleCn": "键值映射", "titleSlug": "map-sum-pairs", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>设计一个 map ，满足以下几点:</p>\n\n<ul>\n\t<li>字符串表示键，整数表示值</li>\n\t<li>返回具有前缀等于给定字符串的键的值的总和</li>\n</ul>\n\n<p>实现一个 <code>MapSum</code> 类：</p>\n\n<ul>\n\t<li><code>MapSum()</code> 初始化 <code>MapSum</code> 对象</li>\n\t<li><code>void insert(String key, int val)</code> 插入 <code>key-val</code> 键值对，字符串表示键 <code>key</code> ，整数表示值 <code>val</code> 。如果键 <code>key</code> 已经存在，那么原来的键值对&nbsp;<code>key-value</code>&nbsp;将被替代成新的键值对。</li>\n\t<li><code>int sum(string prefix)</code> 返回所有以该前缀 <code>prefix</code> 开头的键 <code>key</code> 的值的总和。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"]\n[[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]\n<strong>输出：</strong>\n[null, null, 3, null, 5]\n\n<strong>解释：</strong>\nMapSum mapSum = new MapSum();\nmapSum.insert(\"apple\", 3);  \nmapSum.sum(\"ap\");           // 返回 3 (<u>ap</u>ple = 3)\nmapSum.insert(\"app\", 2);    \nmapSum.sum(\"ap\");           // 返回 5 (<u>ap</u>ple + <u>ap</u>p = 3 + 2 = 5)\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= key.length, prefix.length &lt;= 50</code></li>\n\t<li><code>key</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>\n\t<li><code>1 &lt;= val &lt;= 1000</code></li>\n\t<li>最多调用 <code>50</code> 次 <code>insert</code> 和 <code>sum</code></li>\n</ul>\n", "en": "<p>Design a map that allows you to do the following:</p>\n\n<ul>\n\t<li>Maps a string key to a given value.</li>\n\t<li>Returns the sum of the values that have a key with a prefix equal to a given string.</li>\n</ul>\n\n<p>Implement the <code>MapSum</code> class:</p>\n\n<ul>\n\t<li><code>MapSum()</code> Initializes the <code>MapSum</code> object.</li>\n\t<li><code>void insert(String key, int val)</code> Inserts the <code>key-val</code> pair into the map. If the <code>key</code> already existed, the original <code>key-value</code> pair will be overridden to the new one.</li>\n\t<li><code>int sum(string prefix)</code> Returns the sum of all the pairs&#39; value whose <code>key</code> starts with the <code>prefix</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MapSum&quot;, &quot;insert&quot;, &quot;sum&quot;, &quot;insert&quot;, &quot;sum&quot;]\n[[], [&quot;apple&quot;, 3], [&quot;ap&quot;], [&quot;app&quot;, 2], [&quot;ap&quot;]]\n<strong>Output</strong>\n[null, null, 3, null, 5]\n\n<strong>Explanation</strong>\nMapSum mapSum = new MapSum();\nmapSum.insert(&quot;apple&quot;, 3);  \nmapSum.sum(&quot;ap&quot;);           // return 3 (<u>ap</u>ple = 3)\nmapSum.insert(&quot;app&quot;, 2);    \nmapSum.sum(&quot;ap&quot;);           // return 5 (<u>ap</u>ple + <u>ap</u>p = 3 + 2 = 5)\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= key.length, prefix.length &lt;= 50</code></li>\n\t<li><code>key</code> and <code>prefix</code> consist of only lowercase English letters.</li>\n\t<li><code>1 &lt;= val &lt;= 1000</code></li>\n\t<li>At most <code>50</code> calls will be made to <code>insert</code> and <code>sum</code>.</li>\n</ul>\n"}}, "678": {"__typename": "QuestionLightNode", "acRate": 0.39391903062884326, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "678", "isFavor": false, "solutionNum": 701, "title": "Valid Parenthesis String", "titleCn": "有效的括号字符串", "titleSlug": "valid-parenthesis-string", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 47, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode.cn/aliyun-lc-upload/uploaded_files/2023/01/e68645fd-9dd0-46ee-b97c-f4ad64a07848/3%26fmt%3Dauto%26app%3D120%26f%3DJPEG.webp", "slug": "tencent", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个只包含三种字符的字符串，支持的字符类型分别是 <code>'('</code>、<code>')'</code> 和 <code>'*'</code>。请你检验这个字符串是否为有效字符串，如果是有效字符串返回 <code>true</code> 。</p>\n\n<p>有效字符串符合如下规则：</p>\n\n<ul>\n\t<li>任何左括号 <code>'('</code>&nbsp;必须有相应的右括号 <code>')'</code>。</li>\n\t<li>任何右括号 <code>')'</code>&nbsp;必须有相应的左括号 <code>'('</code>&nbsp;。</li>\n\t<li>左括号 <code>'('</code> 必须在对应的右括号之前 <code>')'</code>。</li>\n\t<li><code>'*'</code>&nbsp;可以被视为单个右括号 <code>')'</code>&nbsp;，或单个左括号 <code>'('</code>&nbsp;，或一个空字符串。</li>\n\t<li>一个空字符串也被视为有效字符串。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"()\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong class=\"example\">示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(*)\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong class=\"example\">示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"(*))\"\n<strong>输出：</strong>true\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s[i]</code> 为 <code>'('</code>、<code>')'</code> 或 <code>'*'</code></li>\n</ul>\n", "en": "<p>Given a string <code>s</code> containing only three types of characters: <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code> and <code>&#39;*&#39;</code>, return <code>true</code> <em>if</em> <code>s</code> <em>is <strong>valid</strong></em>.</p>\n\n<p>The following rules define a <strong>valid</strong> string:</p>\n\n<ul>\n\t<li>Any left parenthesis <code>&#39;(&#39;</code> must have a corresponding right parenthesis <code>&#39;)&#39;</code>.</li>\n\t<li>Any right parenthesis <code>&#39;)&#39;</code> must have a corresponding left parenthesis <code>&#39;(&#39;</code>.</li>\n\t<li>Left parenthesis <code>&#39;(&#39;</code> must go before the corresponding right parenthesis <code>&#39;)&#39;</code>.</li>\n\t<li><code>&#39;*&#39;</code> could be treated as a single right parenthesis <code>&#39;)&#39;</code> or a single left parenthesis <code>&#39;(&#39;</code> or an empty string <code>&quot;&quot;</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"()\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"(*)\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> s = \"(*))\"\n<strong>Output:</strong> true\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s[i]</code> is <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code> or <code>&#39;*&#39;</code>.</li>\n</ul>\n"}}, "679": {"__typename": "QuestionLightNode", "acRate": 0.5376323987538941, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "679", "isFavor": false, "solutionNum": 376, "title": "24 Game", "titleCn": "24 点游戏", "titleSlug": "24-game", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 46, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个长度为4的整数数组&nbsp;<code>cards</code>&nbsp;。你有 <code>4</code> 张卡片，每张卡片上都包含一个范围在 <code>[1,9]</code> 的数字。您应该使用运算符&nbsp;<code>['+', '-', '*', '/']</code>&nbsp;和括号&nbsp;<code>'('</code>&nbsp;和&nbsp;<code>')'</code>&nbsp;将这些卡片上的数字排列成数学表达式，以获得值24。</p>\n\n<p>你须遵守以下规则:</p>\n\n<ul>\n\t<li>除法运算符 <code>'/'</code> 表示实数除法，而不是整数除法。\n\n\t<ul>\n\t\t<li>例如，&nbsp;<code>4 /(1 - 2 / 3)= 4 /(1 / 3)= 12</code>&nbsp;。</li>\n\t</ul>\n\t</li>\n\t<li>每个运算都在两个数字之间。特别是，不能使用 <code>“-”</code> 作为一元运算符。\n\t<ul>\n\t\t<li>例如，如果 <code>cards =[1,1,1,1]</code> ，则表达式 <code>“-1 -1 -1 -1”</code> 是 <strong>不允许</strong> 的。</li>\n\t</ul>\n\t</li>\n\t<li>你不能把数字串在一起\n\t<ul>\n\t\t<li>例如，如果 <code>cards =[1,2,1,2]</code> ，则表达式 <code>“12 + 12”</code> 无效。</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>如果可以得到这样的表达式，其计算结果为 <code>24</code> ，则返回 <code>true </code>，否则返回 <code>false</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> cards = [4, 1, 8, 7]\n<strong>输出:</strong> true\n<strong>解释:</strong> (8-4) * (7-1) = 24\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> cards = [1, 2, 1, 2]\n<strong>输出:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>cards.length == 4</code></li>\n\t<li><code>1 &lt;= cards[i] &lt;= 9</code></li>\n</ul>\n", "en": "<p>You are given an integer array <code>cards</code> of length <code>4</code>. You have four cards, each containing a number in the range <code>[1, 9]</code>. You should arrange the numbers on these cards in a mathematical expression using the operators <code>[&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;]</code> and the parentheses <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code> to get the value 24.</p>\n\n<p>You are restricted with the following rules:</p>\n\n<ul>\n\t<li>The division operator <code>&#39;/&#39;</code> represents real division, not integer division.\n\n\t<ul>\n\t\t<li>For example, <code>4 / (1 - 2 / 3) = 4 / (1 / 3) = 12</code>.</li>\n\t</ul>\n\t</li>\n\t<li>Every operation done is between two numbers. In particular, we cannot use <code>&#39;-&#39;</code> as a unary operator.\n\t<ul>\n\t\t<li>For example, if <code>cards = [1, 1, 1, 1]</code>, the expression <code>&quot;-1 - 1 - 1 - 1&quot;</code> is <strong>not allowed</strong>.</li>\n\t</ul>\n\t</li>\n\t<li>You cannot concatenate numbers together\n\t<ul>\n\t\t<li>For example, if <code>cards = [1, 2, 1, 2]</code>, the expression <code>&quot;12 + 12&quot;</code> is not valid.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Return <code>true</code> if you can get such expression that evaluates to <code>24</code>, and <code>false</code> otherwise.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> cards = [4,1,8,7]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> (8-4) * (7-1) = 24\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> cards = [1,2,1,2]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>cards.length == 4</code></li>\n\t<li><code>1 &lt;= cards[i] &lt;= 9</code></li>\n</ul>\n"}}, "680": {"__typename": "QuestionLightNode", "acRate": 0.40191310998348334, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "680", "isFavor": false, "solutionNum": 1262, "title": "Valid Palindrome II", "titleCn": "验证回文串 II", "titleSlug": "valid-palindrome-ii", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 45, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串&nbsp;<code>s</code>，<strong>最多</strong> 可以从中删除一个字符。</p>\n\n<p>请你判断 <code>s</code> 是否能成为回文字符串：如果能，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"aba\"\n<strong>输出：</strong>true\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abca\"\n<strong>输出：</strong>true\n<strong>解释：</strong>你可以删除字符 'c' 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"abc\"\n<strong>输出：</strong>false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n", "en": "<p>Given a string <code>s</code>, return <code>true</code> <em>if the </em><code>s</code><em> can be palindrome after deleting <strong>at most one</strong> character from it</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aba&quot;\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abca&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> You could delete the character &#39;c&#39;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abc&quot;\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n"}}, "681": {"__typename": "QuestionLightNode", "acRate": 0.4986164325244785, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "681", "isFavor": false, "solutionNum": 97, "title": "Next Closest Time", "titleCn": "最近时刻", "titleSlug": "next-closest-time", "topicTags": [{"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "2men8m", "name": "Enumeration", "slug": "enumeration", "nameTranslated": "枚举", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 18, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "682": {"__typename": "QuestionLightNode", "acRate": 0.7091589839088298, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "682", "isFavor": false, "solutionNum": 1095, "title": "Baseball Game", "titleCn": "棒球比赛", "titleSlug": "baseball-game", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "xeyjfe6", "name": "Simulation", "slug": "simulation", "nameTranslated": "模拟", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 13, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</p>\n\n<p>比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 <code>ops</code>，其中 <code>ops[i]</code> 是你需要记录的第 <code>i</code> 项操作，<code>ops</code> 遵循下述规则：</p>\n\n<ol>\n\t<li>整数 <code>x</code> - 表示本回合新获得分数 <code>x</code></li>\n\t<li><code>\"+\"</code> - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。</li>\n\t<li><code>\"D\"</code> - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>\n\t<li><code>\"C\"</code> - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。</li>\n</ol>\n\n<p>请你返回记录中所有得分的总和。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\n<strong>输出：</strong>30\n<strong>解释：</strong>\n\"5\" - 记录加 5 ，记录现在是 [5]\n\"2\" - 记录加 2 ，记录现在是 [5, 2]\n\"C\" - 使前一次得分的记录无效并将其移除，记录现在是 [5].\n\"D\" - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].\n\"+\" - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].\n所有得分的总和 5 + 10 + 15 = 30\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\n<strong>输出：</strong>27\n<strong>解释：</strong>\n\"5\" - 记录加 5 ，记录现在是 [5]\n\"-2\" - 记录加 -2 ，记录现在是 [5, -2]\n\"4\" - 记录加 4 ，记录现在是 [5, -2, 4]\n\"C\" - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]\n\"D\" - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]\n\"9\" - 记录加 9 ，记录现在是 [5, -2, -4, 9]\n\"+\" - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]\n\"+\" - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]\n所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>ops = [\"1\"]\n<strong>输出：</strong>1\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= ops.length <= 1000</code></li>\n\t<li><code>ops[i]</code> 为 <code>\"C\"</code>、<code>\"D\"</code>、<code>\"+\"</code>，或者一个表示整数的字符串。整数范围是 <code>[-3 * 10<sup>4</sup>, 3 * 10<sup>4</sup>]</code></li>\n\t<li>对于 <code>\"+\"</code> 操作，题目数据保证记录此操作时前面总是存在两个有效的分数</li>\n\t<li>对于 <code>\"C\"</code> 和 <code>\"D\"</code> 操作，题目数据保证记录此操作时前面总是存在一个有效的分数</li>\n</ul>\n", "en": "<p>You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.</p>\n\n<p>You are given a list of strings <code>operations</code>, where <code>operations[i]</code> is the <code>i<sup>th</sup></code> operation you must apply to the record and is one of the following:</p>\n\n<ul>\n\t<li>An integer <code>x</code>.\n\n\t<ul>\n\t\t<li>Record a new score of <code>x</code>.</li>\n\t</ul>\n\t</li>\n\t<li><code>&#39;+&#39;</code>.\n\t<ul>\n\t\t<li>Record a new score that is the sum of the previous two scores.</li>\n\t</ul>\n\t</li>\n\t<li><code>&#39;D&#39;</code>.\n\t<ul>\n\t\t<li>Record a new score that is the double of the previous score.</li>\n\t</ul>\n\t</li>\n\t<li><code>&#39;C&#39;</code>.\n\t<ul>\n\t\t<li>Invalidate the previous score, removing it from the record.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Return <em>the sum of all the scores on the record after applying all the operations</em>.</p>\n\n<p>The test cases are generated such that the answer and all intermediate calculations fit in a <strong>32-bit</strong> integer and that all operations are valid.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> ops = [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]\n<strong>Output:</strong> 30\n<strong>Explanation:</strong>\n&quot;5&quot; - Add 5 to the record, record is now [5].\n&quot;2&quot; - Add 2 to the record, record is now [5, 2].\n&quot;C&quot; - Invalidate and remove the previous score, record is now [5].\n&quot;D&quot; - Add 2 * 5 = 10 to the record, record is now [5, 10].\n&quot;+&quot; - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> ops = [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]\n<strong>Output:</strong> 27\n<strong>Explanation:</strong>\n&quot;5&quot; - Add 5 to the record, record is now [5].\n&quot;-2&quot; - Add -2 to the record, record is now [5, -2].\n&quot;4&quot; - Add 4 to the record, record is now [5, -2, 4].\n&quot;C&quot; - Invalidate and remove the previous score, record is now [5, -2].\n&quot;D&quot; - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n&quot;9&quot; - Add 9 to the record, record is now [5, -2, -4, 9].\n&quot;+&quot; - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n&quot;+&quot; - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> ops = [&quot;1&quot;,&quot;C&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>\n&quot;1&quot; - Add 1 to the record, record is now [1].\n&quot;C&quot; - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= operations.length &lt;= 1000</code></li>\n\t<li><code>operations[i]</code> is <code>&quot;C&quot;</code>, <code>&quot;D&quot;</code>, <code>&quot;+&quot;</code>, or a string representing an integer in the range <code>[-3 * 10<sup>4</sup>, 3 * 10<sup>4</sup>]</code>.</li>\n\t<li>For operation <code>&quot;+&quot;</code>, there will always be at least two previous scores on the record.</li>\n\t<li>For operations <code>&quot;C&quot;</code> and <code>&quot;D&quot;</code>, there will always be at least one previous score on the record.</li>\n</ul>\n"}}, "683": {"__typename": "QuestionLightNode", "acRate": 0.4674003322259136, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "683", "isFavor": false, "solutionNum": 77, "title": "K Empty Slots", "titleCn": "K 个关闭的灯泡", "titleSlug": "k-empty-slots", "topicTags": [{"id": "n16hs", "name": "Binary Indexed Tree", "slug": "binary-indexed-tree", "nameTranslated": "树状数组", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "qwy9jd", "name": "Ordered Set", "slug": "ordered-set", "nameTranslated": "有序集合", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 9, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "684": {"__typename": "QuestionLightNode", "acRate": 0.677902129641795, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "684", "isFavor": false, "solutionNum": 1008, "title": "Redundant Connection", "titleCn": "冗余连接", "titleSlug": "redundant-connection", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "n6a2i", "name": "Union Find", "slug": "union-find", "nameTranslated": "并查集", "__typename": "CommonTagNode"}, {"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 19, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>树可以看成是一个连通且 <strong>无环&nbsp;</strong>的&nbsp;<strong>无向&nbsp;</strong>图。</p>\n\n<p>给定往一棵&nbsp;<code>n</code> 个节点 (节点值&nbsp;<code>1～n</code>) 的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到 <code>n</code>&nbsp;中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 <code>n</code> 的二维数组 <code>edges</code>&nbsp;，<code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;表示图中在 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p>\n\n<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code> 个节点的树。如果有多个答案，则返回数组&nbsp;<code>edges</code>&nbsp;中最后出现的那个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626676174-hOEVUL-image.png\" style=\"width: 152px; \" /></p>\n\n<pre>\n<strong>输入:</strong> edges = [[1,2], [1,3], [2,3]]\n<strong>输出:</strong> [2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<p><img alt=\"\" src=\"https://pic.leetcode-cn.com/1626676179-kGxcmu-image.png\" style=\"width: 250px; \" /></p>\n\n<pre>\n<strong>输入:</strong> edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]\n<strong>输出:</strong> [1,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= ai&nbsp;&lt; bi&nbsp;&lt;= edges.length</code></li>\n\t<li><code>ai != bi</code></li>\n\t<li><code>edges</code> 中无重复元素</li>\n\t<li>给定的图是连通的&nbsp;</li>\n</ul>\n", "en": "<p>In this problem, a tree is an <strong>undirected graph</strong> that is connected and has no cycles.</p>\n\n<p>You are given a graph that started as a tree with <code>n</code> nodes labeled from <code>1</code> to <code>n</code>, with one additional edge added. The added edge has two <strong>different</strong> vertices chosen from <code>1</code> to <code>n</code>, and was not an edge that already existed. The graph is represented as an array <code>edges</code> of length <code>n</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the graph.</p>\n\n<p>Return <em>an edge that can be removed so that the resulting graph is a tree of </em><code>n</code><em> nodes</em>. If there are multiple answers, return the answer that occurs last in the input.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> edges = [[1,2],[1,3],[2,3]]\n<strong>Output:</strong> [2,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg\" style=\"width: 382px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\n<strong>Output:</strong> [1,4]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub> &lt; b<sub>i</sub> &lt;= edges.length</code></li>\n\t<li><code>a<sub>i</sub> != b<sub>i</sub></code></li>\n\t<li>There are no repeated edges.</li>\n\t<li>The given graph is connected.</li>\n</ul>\n"}}, "685": {"__typename": "QuestionLightNode", "acRate": 0.42141399591885725, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "685", "isFavor": false, "solutionNum": 406, "title": "Redundant Connection II", "titleCn": "冗余连接 II", "titleSlug": "redundant-connection-ii", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "n6a2i", "name": "Union Find", "slug": "union-find", "nameTranslated": "并查集", "__typename": "CommonTagNode"}, {"id": "nkrae", "name": "Graph", "slug": "graph", "nameTranslated": "图", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 12, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>在本问题中，有根树指满足以下条件的 <strong>有向</strong> 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。</p>\n\n<p>输入一个有向图，该图由一个有着 <code>n</code> 个节点（节点值不重复，从 <code>1</code> 到 <code>n</code>）的树及一条附加的有向边构成。附加的边包含在 <code>1</code> 到 <code>n</code> 中的两个不同顶点间，这条附加的边不属于树中已存在的边。</p>\n\n<p>结果图是一个以边组成的二维数组 <code>edges</code> 。 每个元素是一对 <code>[u<sub>i</sub>, v<sub>i</sub>]</code>，用以表示 <strong>有向 </strong>图中连接顶点 <code>u<sub>i</sub></code> 和顶点 <code>v<sub>i</sub></code> 的边，其中 <code>u<sub>i</sub></code> 是 <code>v<sub>i</sub></code> 的一个父节点。</p>\n\n<p>返回一条能删除的边，使得剩下的图是有 <code>n</code> 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>输入：</strong>edges = [[1,2],[1,3],[2,3]]\n<strong>输出：</strong>[2,3]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/graph2.jpg\" style=\"width: 222px; height: 382px;\" />\n<pre>\n<strong>输入：</strong>edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\n<strong>输出：</strong>[4,1]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>3 <= n <= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code></li>\n</ul>\n", "en": "<p>In this problem, a rooted tree is a <b>directed</b> graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.</p>\n\n<p>The given input is a directed graph that started as a rooted tree with <code>n</code> nodes (with distinct values from <code>1</code> to <code>n</code>), with one additional directed edge added. The added edge has two different vertices chosen from <code>1</code> to <code>n</code>, and was not an edge that already existed.</p>\n\n<p>The resulting graph is given as a 2D-array of <code>edges</code>. Each element of <code>edges</code> is a pair <code>[u<sub>i</sub>, v<sub>i</sub>]</code> that represents a <b>directed</b> edge connecting nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code>, where <code>u<sub>i</sub></code> is a parent of child <code>v<sub>i</sub></code>.</p>\n\n<p>Return <em>an edge that can be removed so that the resulting graph is a rooted tree of</em> <code>n</code> <em>nodes</em>. If there are multiple answers, return the answer that occurs last in the given 2D-array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> edges = [[1,2],[1,3],[2,3]]\n<strong>Output:</strong> [2,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/20/graph2.jpg\" style=\"width: 222px; height: 382px;\" />\n<pre>\n<strong>Input:</strong> edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\n<strong>Output:</strong> [4,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == edges.length</code></li>\n\t<li><code>3 &lt;= n &lt;= 1000</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n</ul>\n"}}, "686": {"__typename": "QuestionLightNode", "acRate": 0.39716505887045545, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "686", "isFavor": false, "solutionNum": 666, "title": "Repeated String Match", "titleCn": "重复叠加字符串匹配", "titleSlug": "repeated-string-match", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "ydzvgh", "name": "String Matching", "slug": "string-matching", "nameTranslated": "字符串匹配", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 18, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个字符串&nbsp;<code>a</code> 和 <code>b</code>，寻找重复叠加字符串 <code>a</code> 的最小次数，使得字符串 <code>b</code> 成为叠加后的字符串 <code>a</code> 的子串，如果不存在则返回 <code>-1</code>。</p>\n\n<p><strong>注意：</strong>字符串 <code>&quot;abc&quot;</code>&nbsp;重复叠加 0 次是 <code>&quot;&quot;</code>，重复叠加 1 次是&nbsp;<code>&quot;abc&quot;</code>，重复叠加 2 次是&nbsp;<code>&quot;abcabc&quot;</code>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre><strong>输入：</strong>a = &quot;abcd&quot;, b = &quot;cdabcdab&quot;\n<strong>输出：</strong>3\n<strong>解释：</strong>a 重复叠加三遍后为 &quot;ab<strong>cdabcdab</strong>cd&quot;, 此时 b 是其子串。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre><strong>输入：</strong>a = &quot;a&quot;, b = &quot;aa&quot;\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre><strong>输入：</strong>a = &quot;a&quot;, b = &quot;a&quot;\n<strong>输出：</strong>1\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre><strong>输入：</strong>a = &quot;abc&quot;, b = &quot;wxyz&quot;\n<strong>输出：</strong>-1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= b.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>a</code> 和 <code>b</code> 由小写英文字母组成</li>\n</ul>\n", "en": "<p>Given two strings <code>a</code> and <code>b</code>, return <em>the minimum number of times you should repeat string </em><code>a</code><em> so that string</em> <code>b</code> <em>is a substring of it</em>. If it is impossible for <code>b</code>​​​​​​ to be a substring of <code>a</code> after repeating it, return <code>-1</code>.</p>\n\n<p><strong>Notice:</strong> string <code>&quot;abc&quot;</code> repeated 0 times is <code>&quot;&quot;</code>, repeated 1 time is <code>&quot;abc&quot;</code> and repeated 2 times is <code>&quot;abcabc&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = &quot;abcd&quot;, b = &quot;cdabcdab&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> We return 3 because by repeating a three times &quot;ab<strong>cdabcdab</strong>cd&quot;, b is a substring of it.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> a = &quot;a&quot;, b = &quot;aa&quot;\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= a.length, b.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>a</code> and <code>b</code> consist of lowercase English letters.</li>\n</ul>\n"}}, "687": {"__typename": "QuestionLightNode", "acRate": 0.48002855417055623, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "687", "isFavor": false, "solutionNum": 693, "title": "Longest Univalue Path", "titleCn": "最长同值路径", "titleSlug": "longest-univalue-path", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 28, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个二叉树的<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;，返回&nbsp;<em>最长的路径的长度</em> ，这个路径中的&nbsp;<em>每个节点具有相同值</em>&nbsp;。 这条路径可以经过也可以不经过根节点。</p>\n\n<p><strong>两个节点之间的路径长度</strong>&nbsp;由它们之间的边数表示。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [5,4,5,1,1,5]\n<strong>输出：</strong>2\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/ex2.jpg\" /></p>\n\n<pre>\n<strong>输入：</strong>root = [1,4,5,4,4,5]\n<strong>输出：</strong>2\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li>树的节点数的范围是<meta charset=\"UTF-8\" />&nbsp;<code>[0, 10<sup>4</sup>]</code>&nbsp;</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>树的深度将不超过 <code>1000</code>&nbsp;</li>\n</ul>\n", "en": "<p>Given the <code>root</code> of a binary tree, return <em>the length of the longest path, where each node in the path has the same value</em>. This path may or may not pass through the root.</p>\n\n<p><strong>The length of the path</strong> between two nodes is represented by the number of edges between them.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg\" style=\"width: 450px; height: 238px;\" />\n<pre>\n<strong>Input:</strong> root = [5,4,5,1,1,null,5]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The shown image shows that the longest path of the same value (i.e. 5).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/13/ex2.jpg\" style=\"width: 450px; height: 238px;\" />\n<pre>\n<strong>Input:</strong> root = [1,4,5,4,4,null,5]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The shown image shows that the longest path of the same value (i.e. 4).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n\t<li>The depth of the tree will not exceed <code>1000</code>.</li>\n</ul>\n"}}, "688": {"__typename": "QuestionLightNode", "acRate": 0.5799743495786002, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "688", "isFavor": false, "solutionNum": 401, "title": "Knight Probability in Chessboard", "titleCn": "骑士在棋盘上的概率", "titleSlug": "knight-probability-in-chessboard", "topicTags": [{"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 22, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>在一个&nbsp;<code>n x n</code>&nbsp;的国际象棋棋盘上，一个骑士从单元格 <code>(row, column)</code>&nbsp;开始，并尝试进行 <code>k</code> 次移动。行和列是 <strong>从 0 开始</strong> 的，所以左上单元格是 <code>(0,0)</code> ，右下单元格是 <code>(n - 1, n - 1)</code> 。</p>\n\n<p>象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。</p>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/knight.png\" style=\"height: 300px; width: 300px;\" /></p>\n\n<p>每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。</p>\n\n<p>骑士继续移动，直到它走了 <code>k</code> 步或离开了棋盘。</p>\n\n<p>返回 <em>骑士在棋盘停止移动后仍留在棋盘上的概率</em> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 3, k = 2, row = 0, column = 0\n<strong>输出:</strong> 0.0625\n<strong>解释:</strong> 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。\n在每一个位置上，也有两种移动可以让骑士留在棋盘上。\n骑士留在棋盘上的总概率是0.0625。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> n = 1, k = 0, row = 0, column = 0\n<strong>输出:</strong> 1.00000\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 25</code></li>\n\t<li><code>0 &lt;= k &lt;= 100</code></li>\n\t<li><code>0 &lt;= row, column &lt;= n - 1</code></li>\n</ul>\n", "en": "<p>On an <code>n x n</code> chessboard, a knight starts at the cell <code>(row, column)</code> and attempts to make exactly <code>k</code> moves. The rows and columns are <strong>0-indexed</strong>, so the top-left cell is <code>(0, 0)</code>, and the bottom-right cell is <code>(n - 1, n - 1)</code>.</p>\n\n<p>A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.</p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/knight.png\" style=\"width: 300px; height: 300px;\" />\n<p>Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.</p>\n\n<p>The knight continues moving until it has made exactly <code>k</code> moves or has moved off the chessboard.</p>\n\n<p>Return <em>the probability that the knight remains on the board after it has stopped moving</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, k = 2, row = 0, column = 0\n<strong>Output:</strong> 0.06250\n<strong>Explanation:</strong> There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\nFrom each of those positions, there are also two moves that will keep the knight on the board.\nThe total probability the knight stays on the board is 0.0625.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, k = 0, row = 0, column = 0\n<strong>Output:</strong> 1.00000\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 25</code></li>\n\t<li><code>0 &lt;= k &lt;= 100</code></li>\n\t<li><code>0 &lt;= row, column &lt;= n - 1</code></li>\n</ul>\n"}}, "689": {"__typename": "QuestionLightNode", "acRate": 0.5862068965517241, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "689", "isFavor": false, "solutionNum": 355, "title": "Maximum Sum of 3 Non-Overlapping Subarrays", "titleCn": "三个无重叠子数组的最大和", "titleSlug": "maximum-sum-of-3-non-overlapping-subarrays", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 16, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，找出三个长度为 <code>k</code> 、互不重叠、且全部数字和（<code>3 * k</code> 项）最大的子数组，并返回这三个子数组。</p>\n\n<p>以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 <strong>0</strong> 开始）。如果有多个结果，返回字典序最小的一个。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,6,7,5,1], k = 2\n<strong>输出：</strong>[0,3,5]\n<strong>解释：</strong>子数组 [1, 2], [2, 6], [7, 5] 对应的起始下标为 [0, 3, 5]。\n也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,1,2,1,2,1,2,1], k = 2\n<strong>输出：</strong>[0,2,4]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;&nbsp;2<sup>16</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= floor(nums.length / 3)</code></li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, find three non-overlapping subarrays of length <code>k</code> with maximum sum and return them.</p>\n\n<p>Return the result as a list of indices representing the starting position of each interval (<strong>0-indexed</strong>). If there are multiple answers, return the lexicographically smallest one.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,2,6,7,5,1], k = 2\n<strong>Output:</strong> [0,3,5]\n<strong>Explanation:</strong> Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].\nWe could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,2,1,2,1,2,1], k = 2\n<strong>Output:</strong> [0,2,4]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;&nbsp;2<sup>16</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= floor(nums.length / 3)</code></li>\n</ul>\n"}}, "690": {"__typename": "QuestionLightNode", "acRate": 0.6603555092351341, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "690", "isFavor": false, "solutionNum": 681, "title": "Employee Importance", "titleCn": "员工的重要性", "titleSlug": "employee-importance", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 29, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个保存员工信息的数据结构，它包含了员工 <strong>唯一的 id </strong>，<strong>重要度 </strong>和 <strong>直系下属的 id </strong>。</p>\n\n<p>比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 <strong>并不是直系</strong> 下属，因此没有体现在员工 1 的数据结构中。</p>\n\n<p>现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。</p>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1\n<strong>输出：</strong>11\n<strong>解释：</strong>\n员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>一个员工最多有一个<strong> 直系 </strong>领导，但是可以有多个 <strong>直系 </strong>下属</li>\n\t<li>员工数量不超过 2000 。</li>\n</ul>\n", "en": "<p>You have a data structure of employee information, including the employee&#39;s unique ID, importance value, and direct subordinates&#39; IDs.</p>\n\n<p>You are given an array of employees <code>employees</code> where:</p>\n\n<ul>\n\t<li><code>employees[i].id</code> is the ID of the <code>i<sup>th</sup></code> employee.</li>\n\t<li><code>employees[i].importance</code> is the importance value of the <code>i<sup>th</sup></code> employee.</li>\n\t<li><code>employees[i].subordinates</code> is a list of the IDs of the direct subordinates of the <code>i<sup>th</sup></code> employee.</li>\n</ul>\n\n<p>Given an integer <code>id</code> that represents an employee&#39;s ID, return <em>the <strong>total</strong> importance value of this employee and all their direct and indirect subordinates</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/31/emp1-tree.jpg\" style=\"width: 400px; height: 258px;\" />\n<pre>\n<strong>Input:</strong> employees = [[1,5,[2,3]],[2,3,[]],[3,3,[]]], id = 1\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> Employee 1 has an importance value of 5 and has two direct subordinates: employee 2 and employee 3.\nThey both have an importance value of 3.\nThus, the total importance value of employee 1 is 5 + 3 + 3 = 11.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/31/emp2-tree.jpg\" style=\"width: 362px; height: 361px;\" />\n<pre>\n<strong>Input:</strong> employees = [[1,2,[5]],[5,-3,[]]], id = 5\n<strong>Output:</strong> -3\n<strong>Explanation:</strong> Employee 5 has an importance value of -3 and has no direct subordinates.\nThus, the total importance value of employee 5 is -3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= employees.length &lt;= 2000</code></li>\n\t<li><code>1 &lt;= employees[i].id &lt;= 2000</code></li>\n\t<li>All <code>employees[i].id</code> are <strong>unique</strong>.</li>\n\t<li><code>-100 &lt;= employees[i].importance &lt;= 100</code></li>\n\t<li>One employee has at most one direct leader and may have several subordinates.</li>\n\t<li>The IDs in <code>employees[i].subordinates</code> are valid IDs.</li>\n</ul>\n"}}, "691": {"__typename": "QuestionLightNode", "acRate": 0.5801947136754917, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "691", "isFavor": false, "solutionNum": 216, "title": "Stickers to Spell Word", "titleCn": "贴纸拼词", "titleSlug": "stickers-to-spell-word", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "eeprrj", "name": "Bitmask", "slug": "bitmask", "nameTranslated": "状态压缩", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 14, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/78703b3d3d17ff1b249303bec7cd53d61ba4d1ff309f4293600ea7efe8b692ae-salesforce.png", "slug": "salesforce", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>我们有 <code>n</code> 种不同的贴纸。每个贴纸上都有一个小写的英文单词。</p>\n\n<p>您想要拼写出给定的字符串 <code>target</code>&nbsp;，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。</p>\n\n<p>返回你需要拼出 <code>target</code>&nbsp;的最小贴纸数量。如果任务不可能，则返回 <code>-1</code> 。</p>\n\n<p><strong>注意：</strong>在所有的测试用例中，所有的单词都是从 <code>1000</code> 个最常见的美国英语单词中随机选择的，并且 <code>target</code>&nbsp;被选择为两个随机单词的连接。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong> stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"\n<b>输出：</b>3\n<strong>解释：\n</strong>我们可以使用 2 个 \"with\" 贴纸，和 1 个 \"example\" 贴纸。\n把贴纸上的字母剪下来并重新排列后，就可以形成目标 “thehat“ 了。\n此外，这是形成目标字符串所需的最小贴纸数量。\n</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<b>输入：</b>stickers = [\"notice\",\"possible\"], target = \"basicbasic\"\n<b>输出：</b>-1\n<strong>解释：</strong>我们不能通过剪切给定贴纸的字母来形成目标“basicbasic”。</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>n == stickers.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>1 &lt;= stickers[i].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= target.length &lt;= 15</code></li>\n\t<li><code>stickers[i]</code>&nbsp;和&nbsp;<code>target</code>&nbsp;由小写英文单词组成</li>\n</ul>\n", "en": "<p>We are given <code>n</code> different types of <code>stickers</code>. Each sticker has a lowercase English word on it.</p>\n\n<p>You would like to spell out the given string <code>target</code> by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker.</p>\n\n<p>Return <em>the minimum number of stickers that you need to spell out </em><code>target</code>. If the task is impossible, return <code>-1</code>.</p>\n\n<p><strong>Note:</strong> In all test cases, all words were chosen randomly from the <code>1000</code> most common US English words, and <code>target</code> was chosen as a concatenation of two random words.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> stickers = [&quot;with&quot;,&quot;example&quot;,&quot;science&quot;], target = &quot;thehat&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\nWe can use 2 &quot;with&quot; stickers, and 1 &quot;example&quot; sticker.\nAfter cutting and rearrange the letters of those stickers, we can form the target &quot;thehat&quot;.\nAlso, this is the minimum number of stickers necessary to form the target string.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> stickers = [&quot;notice&quot;,&quot;possible&quot;], target = &quot;basicbasic&quot;\n<strong>Output:</strong> -1\nExplanation:\nWe cannot form the target &quot;basicbasic&quot; from cutting letters from the given stickers.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == stickers.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>1 &lt;= stickers[i].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= target.length &lt;= 15</code></li>\n\t<li><code>stickers[i]</code> and <code>target</code> consist of lowercase English letters.</li>\n</ul>\n"}}, "692": {"__typename": "QuestionLightNode", "acRate": 0.561065919729875, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "692", "isFavor": false, "solutionNum": 1124, "title": "Top K Frequent Words", "titleCn": "前K个高频单词", "titleSlug": "top-k-frequent-words", "topicTags": [{"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "eqnkri", "name": "Bucket Sort", "slug": "bucket-sort", "nameTranslated": "桶排序", "__typename": "CommonTagNode"}, {"id": "pxpqcm", "name": "Counting", "slug": "counting", "nameTranslated": "计数", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 76, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个单词列表&nbsp;<code>words</code>&nbsp;和一个整数 <code>k</code> ，返回前&nbsp;<code>k</code><em>&nbsp;</em>个出现次数最多的单词。</p>\n\n<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， <strong>按字典顺序</strong> 排序。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入:</strong> words = [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\n<strong>输出:</strong> [\"i\", \"love\"]\n<strong>解析:</strong> \"i\" 和 \"love\" 为出现次数最多的两个单词，均为2次。\n    注意，按字母顺序 \"i\" 在 \"love\" 之前。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入:</strong> [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\n<strong>输出:</strong> [\"the\", \"is\", \"sunny\", \"day\"]\n<strong>解析:</strong> \"the\", \"is\", \"sunny\" 和 \"day\" 是出现次数最多的四个单词，\n    出现次数依次为 4, 3, 2 和 1 次。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>注意：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= words[i] &lt;= 10</code></li>\n\t<li><code>words[i]</code>&nbsp;由小写英文字母组成。</li>\n\t<li><code>k</code> 的取值范围是&nbsp;<code>[1, <strong>不同</strong> words[i] 的数量]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>进阶：</strong>尝试以&nbsp;<code>O(n log k)</code> 时间复杂度和&nbsp;<code>O(n)</code> 空间复杂度解决。</p>\n", "en": "<p>Given an array of strings <code>words</code> and an integer <code>k</code>, return <em>the </em><code>k</code><em> most frequent strings</em>.</p>\n\n<p>Return the answer <strong>sorted</strong> by <strong>the frequency</strong> from highest to lowest. Sort the words with the same frequency by their <strong>lexicographical order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;,&quot;i&quot;,&quot;love&quot;,&quot;coding&quot;], k = 2\n<strong>Output:</strong> [&quot;i&quot;,&quot;love&quot;]\n<strong>Explanation:</strong> &quot;i&quot; and &quot;love&quot; are the two most frequent words.\nNote that &quot;i&quot; comes before &quot;love&quot; due to a lower alphabetical order.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;the&quot;,&quot;day&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;the&quot;,&quot;the&quot;,&quot;the&quot;,&quot;sunny&quot;,&quot;is&quot;,&quot;is&quot;], k = 4\n<strong>Output:</strong> [&quot;the&quot;,&quot;is&quot;,&quot;sunny&quot;,&quot;day&quot;]\n<strong>Explanation:</strong> &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; and &quot;day&quot; are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n\t<li><code>k</code> is in the range <code>[1, The number of <strong>unique</strong> words[i]]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Could you solve it in <code>O(n log(k))</code> time and <code>O(n)</code> extra space?</p>\n"}}, "693": {"__typename": "QuestionLightNode", "acRate": 0.6525782573238819, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "693", "isFavor": false, "solutionNum": 871, "title": "Binary Number with Alternating Bits", "titleCn": "交替位二进制数", "titleSlug": "binary-number-with-alternating-bits", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 11, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/tag/%E4%BC%98%E6%AD%A5%20%28Uber%29/company_logo", "slug": "uber", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 5\n<strong>输出：</strong>true\n<strong>解释：</strong>5 的二进制表示是：101\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 7\n<strong>输出：</strong>false\n<strong>解释：</strong>7 的二进制表示是：111.</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>n = 11\n<strong>输出：</strong>false\n<strong>解释：</strong>11 的二进制表示是：1011.</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n", "en": "<p>Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The binary representation of 5 is: 101\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 7\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The binary representation of 7 is: 111.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 11\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The binary representation of 11 is: 1011.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n"}}, "694": {"__typename": "QuestionLightNode", "acRate": 0.5856912070159243, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "694", "isFavor": false, "solutionNum": 202, "title": "Number of Distinct Islands", "titleCn": "不同岛屿的数量", "titleSlug": "number-of-distinct-islands", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "n6a2i", "name": "Union Find", "slug": "union-find", "nameTranslated": "并查集", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "xp2e97i", "name": "Hash Function", "slug": "hash-function", "nameTranslated": "哈希函数", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 29, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "695": {"__typename": "QuestionLightNode", "acRate": 0.6806623842496038, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "695", "isFavor": false, "solutionNum": 2708, "title": "Max Area of Island", "titleCn": "岛屿的最大面积", "titleSlug": "max-area-of-island", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "n6a2i", "name": "Union Find", "slug": "union-find", "nameTranslated": "并查集", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "uw538v", "name": "Matrix", "slug": "matrix", "nameTranslated": "矩阵", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 78, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p>\n\n<p><strong>岛屿</strong>&nbsp;是由一些相邻的&nbsp;<code>1</code>&nbsp;(代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上 </strong>相邻。你可以假设&nbsp;<code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>\n\n<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p>\n\n<p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg\" style=\"width: 500px; height: 310px;\" />\n<pre>\n<strong>输入：</strong>grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n<strong>输出：</strong>6\n<strong>解释：</strong>答案不应该是 <code>11</code> ，因为岛屿只能包含水平或垂直这四个方向上的 <code>1</code> 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>grid = [[0,0,0,0,0,0,0,0]]\n<strong>输出：</strong>0\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n", "en": "<p>You are given an <code>m x n</code> binary matrix <code>grid</code>. An island is a group of <code>1</code>&#39;s (representing land) connected <strong>4-directionally</strong> (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>\n\n<p>The <strong>area</strong> of an island is the number of cells with a value <code>1</code> in the island.</p>\n\n<p>Return <em>the maximum <strong>area</strong> of an island in </em><code>grid</code>. If there is no island, return <code>0</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg\" style=\"width: 500px; height: 310px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The answer is not 11, because the island must be connected 4-directionally.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[0,0,0,0,0,0,0,0]]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.</li>\n</ul>\n"}}, "696": {"__typename": "QuestionLightNode", "acRate": 0.6356009863707555, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "696", "isFavor": false, "solutionNum": 661, "title": "Count Binary Substrings", "titleCn": "计数二进制子串", "titleSlug": "count-binary-substrings", "topicTags": [{"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 34, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1604559404-lBlorc-https---i.forbesimg.com-media-lists-companies-jpmorgan-chase_416x416.jpg", "slug": "jpmorgan", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个字符串&nbsp;<code>s</code>，统计并返回具有相同数量 <code>0</code> 和 <code>1</code> 的非空（连续）子字符串的数量，并且这些子字符串中的所有 <code>0</code> 和所有 <code>1</code> 都是成组连续的。</p>\n\n<p>重复出现（不同位置）的子串也要统计它们出现的次数。</p>\n&nbsp;\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"00110011\"\n<strong>输出：</strong>6\n<strong>解释：</strong>6 个子串满足具有相同数量的连续 1 和 0 ：\"0011\"、\"01\"、\"1100\"、\"10\"、\"0011\" 和 \"01\" 。\n注意，一些重复出现的子串（不同位置）要统计它们出现的次数。\n另外，\"00110011\" 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"10101\"\n<strong>输出：</strong>4\n<strong>解释：</strong>有 4 个子串：\"10\"、\"01\"、\"10\"、\"01\" ，具有相同数量的连续 1 和 0 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>\n</ul>\n", "en": "<p>Given a binary string <code>s</code>, return the number of non-empty substrings that have the same number of <code>0</code>&#39;s and <code>1</code>&#39;s, and all the <code>0</code>&#39;s and all the <code>1</code>&#39;s in these substrings are grouped consecutively.</p>\n\n<p>Substrings that occur multiple times are counted the number of times they occur.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;00110011&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> There are 6 substrings that have equal number of consecutive 1&#39;s and 0&#39;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso, &quot;00110011&quot; is not a valid substring because all the 0&#39;s (and 1&#39;s) are not grouped together.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;10101&quot;\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> There are 4 substrings: &quot;10&quot;, &quot;01&quot;, &quot;10&quot;, &quot;01&quot; that have equal number of consecutive 1&#39;s and 0&#39;s.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n</ul>\n"}}, "697": {"__typename": "QuestionLightNode", "acRate": 0.5904856699552095, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "697", "isFavor": false, "solutionNum": 1222, "title": "Degree of an Array", "titleCn": "数组的度", "titleSlug": "degree-of-an-array", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 43, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/e180e3e5553f722e5895940d0617f54e988e54e1e530b27e88e76576aedc553d-qw90wxxo_400x400.jpg", "slug": "mathworks", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/5e0fc9725d52a27ef558e19ee60f09d6b3c8e110a8e73428e32d4f85d5c3bc21-0-1.png", "slug": "walmart-labs", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个非空且只包含非负数的整数数组&nbsp;<code>nums</code>，数组的 <strong>度</strong> 的定义是指数组里任一元素出现频数的最大值。</p>\n\n<p>你的任务是在 <code>nums</code> 中找到与&nbsp;<code>nums</code>&nbsp;拥有相同大小的度的最短连续子数组，返回其长度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,3,1]\n<strong>输出：</strong>2\n<strong>解释：</strong>\n输入数组的度是 2 ，因为元素 1 和 2 的出现频数最大，均为 2 。\n连续子数组里面拥有相同度的有如下所示：\n[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]\n最短连续子数组 [2, 2] 的长度为 2 ，所以返回 2 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,2,3,1,4,2]\n<strong>输出：</strong>6\n<strong>解释：</strong>\n数组的度是 3 ，因为元素 2 重复出现 3 次。\n所以 [2,2,3,1,4,2] 是最短子数组，因此返回 6 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>nums.length</code>&nbsp;在 <code>1</code> 到 <code>50,000</code> 范围内。</li>\n\t<li><code>nums[i]</code>&nbsp;是一个在 <code>0</code> 到 <code>49,999</code> 范围内的整数。</li>\n</ul>\n", "en": "<p>Given a non-empty array of non-negative integers <code>nums</code>, the <b>degree</b> of this array is defined as the maximum frequency of any one of its elements.</p>\n\n<p>Your task is to find the smallest possible length of a (contiguous) subarray of <code>nums</code>, that has the same degree as <code>nums</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,2,3,1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> \nThe input array has a degree of 2 because both elements 1 and 2 appear twice.\nOf the subarrays that have the same degree:\n[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]\nThe shortest length is 2. So return 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,2,3,1,4,2]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> \nThe degree is 3 because the element 2 is repeated 3 times.\nSo [2,2,3,1,4,2] is the shortest subarray, therefore returning 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums.length</code> will be between 1 and 50,000.</li>\n\t<li><code>nums[i]</code> will be an integer between 0 and 49,999.</li>\n</ul>\n"}}, "698": {"__typename": "QuestionLightNode", "acRate": 0.4176981740852094, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "698", "isFavor": false, "solutionNum": 1455, "title": "Partition to K Equal Sum Subsets", "titleCn": "划分为k个相等的子集", "titleSlug": "partition-to-k-equal-sum-subsets", "topicTags": [{"id": "nizi1", "name": "Bit Manipulation", "slug": "bit-manipulation", "nameTranslated": "位运算", "__typename": "CommonTagNode"}, {"id": "vhos7", "name": "Memoization", "slug": "memoization", "nameTranslated": "记忆化搜索", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "dnl25", "name": "Backtracking", "slug": "backtracking", "nameTranslated": "回溯", "__typename": "CommonTagNode"}, {"id": "eeprrj", "name": "Bitmask", "slug": "bitmask", "nameTranslated": "状态压缩", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 44, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个整数数组&nbsp;&nbsp;<code>nums</code> 和一个正整数 <code>k</code>，找出是否有可能把这个数组分成 <code>k</code> 个非空子集，其总和都相等。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong> nums = [4, 3, 2, 3, 5, 2, 1], k = 4\n<strong>输出：</strong> True\n<strong>说明：</strong> 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> nums = [1,2,3,4], k = 3\n<strong>输出:</strong> false</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= len(nums) &lt;= 16</code></li>\n\t<li><code>0 &lt; nums[i] &lt; 10000</code></li>\n\t<li>每个元素的频率在 <code>[1,4]</code> 范围内</li>\n</ul>\n", "en": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> if it is possible to divide this array into <code>k</code> non-empty subsets whose sums are all equal.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,3,2,3,5,2,1], k = 4\n<strong>Output:</strong> true\n<strong>Explanation:</strong> It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4], k = 3\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 16</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li>The frequency of each element is in the range <code>[1, 4]</code>.</li>\n</ul>\n"}}, "699": {"__typename": "QuestionLightNode", "acRate": 0.5469381270143902, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "699", "isFavor": false, "solutionNum": 248, "title": "Falling Squares", "titleCn": "掉落的方块", "titleSlug": "falling-squares", "topicTags": [{"id": "nytfd", "name": "Segment Tree", "slug": "segment-tree", "nameTranslated": "线段树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "qwy9jd", "name": "Ordered Set", "slug": "ordered-set", "nameTranslated": "有序集合", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 10, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>在二维平面上的 x 轴上，放置着一些方块。</p>\n\n<p>给你一个二维整数数组 <code>positions</code> ，其中 <code>positions[i] = [left<sub>i</sub>, sideLength<sub>i</sub>]</code> 表示：第 <code>i</code> 个方块边长为 <code>sideLength<sub>i</sub></code> ，其左侧边与 x 轴上坐标点&nbsp;<code>left<sub>i</sub></code> 对齐。</p>\n\n<p>每个方块都从一个比目前所有的落地方块更高的高度掉落而下。方块沿 y 轴负方向下落，直到着陆到 <strong>另一个正方形的顶边</strong> 或者是 <strong>x 轴上</strong> 。一个方块仅仅是擦过另一个方块的左侧边或右侧边不算着陆。一旦着陆，它就会固定在原地，无法移动。</p>\n\n<p>在每个方块掉落后，你必须记录目前所有已经落稳的 <strong>方块堆叠的最高高度</strong> 。</p>\n\n<p>返回一个整数数组 <code>ans</code> ，其中 <code>ans[i]</code> 表示在第 <code>i</code> 块方块掉落后堆叠的最高高度。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/fallingsq1-plane.jpg\" style=\"width: 500px; height: 505px;\" />\n<pre>\n<strong>输入：</strong>positions = [[1,2],[2,3],[6,1]]\n<strong>输出：</strong>[2,5,5]\n<strong>解释：</strong>\n第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 2 。\n第 2 个方块掉落后，最高的堆叠由方块 1 和 2 组成，堆叠的最高高度为 5 。\n第 3 个方块掉落后，最高的堆叠仍然由方块 1 和 2 组成，堆叠的最高高度为 5 。\n因此，返回 [2, 5, 5] 作为答案。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>positions = [[100,100],[200,100]]\n<strong>输出：</strong>[100,100]\n<strong>解释：</strong>\n第 1 个方块掉落后，最高的堆叠由方块 1 组成，堆叠的最高高度为 100 。\n第 2 个方块掉落后，最高的堆叠可以由方块 1 组成也可以由方块 2 组成，堆叠的最高高度为 100 。\n因此，返回 [100, 100] 作为答案。\n注意，方块 2 擦过方块 1 的右侧边，但不会算作在方块 1 上着陆。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= positions.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= left<sub>i</sub> &lt;= 10<sup>8</sup></code></li>\n\t<li><code>1 &lt;= sideLength<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n</ul>\n", "en": "<p>There are several squares being dropped onto the X-axis of a 2D plane.</p>\n\n<p>You are given a 2D integer array <code>positions</code> where <code>positions[i] = [left<sub>i</sub>, sideLength<sub>i</sub>]</code> represents the <code>i<sup>th</sup></code> square with a side length of <code>sideLength<sub>i</sub></code> that is dropped with its left edge aligned with X-coordinate <code>left<sub>i</sub></code>.</p>\n\n<p>Each square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands <strong>on the top side of another square</strong> or <strong>on the X-axis</strong>. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.</p>\n\n<p>After each square is dropped, you must record the <strong>height of the current tallest stack of squares</strong>.</p>\n\n<p>Return <em>an integer array </em><code>ans</code><em> where </em><code>ans[i]</code><em> represents the height described above after dropping the </em><code>i<sup>th</sup></code><em> square</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/28/fallingsq1-plane.jpg\" style=\"width: 500px; height: 505px;\" />\n<pre>\n<strong>Input:</strong> positions = [[1,2],[2,3],[6,1]]\n<strong>Output:</strong> [2,5,5]\n<strong>Explanation:</strong>\nAfter the first drop, the tallest stack is square 1 with a height of 2.\nAfter the second drop, the tallest stack is squares 1 and 2 with a height of 5.\nAfter the third drop, the tallest stack is still squares 1 and 2 with a height of 5.\nThus, we return an answer of [2, 5, 5].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> positions = [[100,100],[200,100]]\n<strong>Output:</strong> [100,100]\n<strong>Explanation:</strong>\nAfter the first drop, the tallest stack is square 1 with a height of 100.\nAfter the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.\nThus, we return an answer of [100, 100].\nNote that square 2 only brushes the right side of square 1, which does not count as landing on it.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= positions.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= left<sub>i</sub> &lt;= 10<sup>8</sup></code></li>\n\t<li><code>1 &lt;= sideLength<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n</ul>\n"}}, "700": {"__typename": "QuestionLightNode", "acRate": 0.7815815122790737, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "700", "isFavor": false, "solutionNum": 2056, "title": "Search in a Binary Search Tree", "titleCn": "二叉搜索树中的搜索", "titleSlug": "search-in-a-binary-search-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 25, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定二叉搜索树（BST）的根节点<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;和一个整数值<meta charset=\"UTF-8\" />&nbsp;<code>val</code>。</p>\n\n<p>你需要在 BST 中找到节点值等于&nbsp;<code>val</code>&nbsp;的节点。 返回以该节点为根的子树。 如果节点不存在，则返回<meta charset=\"UTF-8\" />&nbsp;<code>null</code>&nbsp;。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg\" style=\"height: 179px; width: 250px;\" /><meta charset=\"UTF-8\" /></p>\n\n<pre>\n<b>输入：</b>root = [4,2,7,1,3], val = 2\n<b>输出：</b>[2,1,3]\n</pre>\n\n<p><strong>示例 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg\" style=\"height: 179px; width: 250px;\" />\n<pre>\n<b>输入：</b>root = [4,2,7,1,3], val = 5\n<b>输出：</b>[]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中节点数在&nbsp;<code>[1, 5000]</code>&nbsp;范围内</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>7</sup></code></li>\n\t<li><code>root</code>&nbsp;是二叉搜索树</li>\n\t<li><code>1 &lt;= val &lt;= 10<sup>7</sup></code></li>\n</ul>\n", "en": "<p>You are given the <code>root</code> of a binary search tree (BST) and an integer <code>val</code>.</p>\n\n<p>Find the node in the BST that the node&#39;s value equals <code>val</code> and return the subtree rooted with that node. If such a node does not exist, return <code>null</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg\" style=\"width: 422px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3], val = 2\n<strong>Output:</strong> [2,1,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg\" style=\"width: 422px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3], val = 5\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 5000]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>7</sup></code></li>\n\t<li><code>root</code> is a binary search tree.</li>\n\t<li><code>1 &lt;= val &lt;= 10<sup>7</sup></code></li>\n</ul>\n"}}, "701": {"__typename": "QuestionLightNode", "acRate": 0.7016055415346615, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "701", "isFavor": false, "solutionNum": 1503, "title": "Insert into a Binary Search Tree", "titleCn": "二叉搜索树中的插入操作", "titleSlug": "insert-into-a-binary-search-tree", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 30, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定二叉搜索树（BST）的根节点<meta charset=\"UTF-8\" />&nbsp;<code>root</code>&nbsp;和要插入树中的值<meta charset=\"UTF-8\" />&nbsp;<code>value</code>&nbsp;，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>\n\n<p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg\" />\n<pre>\n<strong>输入：</strong>root = [4,2,7,1,3], val = 5\n<strong>输出：</strong>[4,2,7,1,3,5]\n<strong>解释：</strong>另一个满足题目要求可以通过的树是：\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/bst.jpg\" />\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [40,20,60,10,30,50,70], val = 25\n<strong>输出：</strong>[40,20,60,10,30,50,70,null,null,25]\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n<strong>输出：</strong>[4,2,7,1,3,5]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li>树中的节点数将在<meta charset=\"UTF-8\" />&nbsp;<code>[0,&nbsp;10<sup>4</sup>]</code>的范围内。<meta charset=\"UTF-8\" /></li>\n\t<li><code>-10<sup>8</sup>&nbsp;&lt;= Node.val &lt;= 10<sup>8</sup></code></li>\n\t<li>所有值&nbsp;<meta charset=\"UTF-8\" /><code>Node.val</code>&nbsp;是&nbsp;<strong>独一无二</strong>&nbsp;的。</li>\n\t<li><code>-10<sup>8</sup>&nbsp;&lt;= val &lt;= 10<sup>8</sup></code></li>\n\t<li><strong>保证</strong>&nbsp;<code>val</code>&nbsp;在原始BST中不存在。</li>\n</ul>\n", "en": "<p>You are given the <code>root</code> node of a binary search tree (BST) and a <code>value</code> to insert into the tree. Return <em>the root node of the BST after the insertion</em>. It is <strong>guaranteed</strong> that the new value does not exist in the original BST.</p>\n\n<p><strong>Notice</strong>&nbsp;that there may exist&nbsp;multiple valid ways for the&nbsp;insertion, as long as the tree remains a BST after insertion. You can return <strong>any of them</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg\" style=\"width: 752px; height: 221px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3], val = 5\n<strong>Output:</strong> [4,2,7,1,3,5]\n<strong>Explanation:</strong> Another accepted tree is:\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/bst.jpg\" style=\"width: 352px; height: 301px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [40,20,60,10,30,50,70], val = 25\n<strong>Output:</strong> [40,20,60,10,30,50,70,null,null,25]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n<strong>Output:</strong> [4,2,7,1,3,5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in&nbsp;the tree will be in the range <code>[0,&nbsp;10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>8</sup> &lt;= Node.val &lt;= 10<sup>8</sup></code></li>\n\t<li>All the values <code>Node.val</code> are <strong>unique</strong>.</li>\n\t<li><code>-10<sup>8</sup> &lt;= val &lt;= 10<sup>8</sup></code></li>\n\t<li>It&#39;s <strong>guaranteed</strong> that <code>val</code> does not exist in the original BST.</li>\n</ul>\n"}}, "702": {"__typename": "QuestionLightNode", "acRate": 0.7480405907103375, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "702", "isFavor": false, "solutionNum": 126, "title": "Search in a Sorted Array of Unknown Size", "titleCn": "搜索长度未知的有序数组", "titleSlug": "search-in-a-sorted-array-of-unknown-size", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "0qo9zm", "name": "Interactive", "slug": "interactive", "nameTranslated": "交互", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 18, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "703": {"__typename": "QuestionLightNode", "acRate": 0.5261415573875529, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "703", "isFavor": false, "solutionNum": 856, "title": "Kth Largest Element in a Stream", "titleCn": "数据流中的第 K 大元素", "titleSlug": "kth-largest-element-in-a-stream", "topicTags": [{"id": "nt875", "name": "Tree", "slug": "tree", "nameTranslated": "树", "__typename": "CommonTagNode"}, {"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "ncljh", "name": "Binary Search Tree", "slug": "binary-search-tree", "nameTranslated": "二叉搜索树", "__typename": "CommonTagNode"}, {"id": "ehgq01", "name": "Binary Tree", "slug": "binary-tree", "nameTranslated": "二叉树", "__typename": "CommonTagNode"}, {"id": "pgti0i", "name": "Data Stream", "slug": "data-stream", "nameTranslated": "数据流", "__typename": "CommonTagNode"}, {"id": "xp2oh0e", "name": "Heap (Priority Queue)", "slug": "heap-priority-queue", "nameTranslated": "堆（优先队列）", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 46, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>设计一个找到数据流中第 <code>k</code> 大元素的类（class）。注意是排序后的第 <code>k</code> 大元素，不是第 <code>k</code> 个不同的元素。</p>\n\n<p>请实现 <code>KthLargest</code> 类：</p>\n\n<ul>\n\t<li><code>KthLargest(int k, int[] nums)</code> 使用整数 <code>k</code> 和整数流 <code>nums</code> 初始化对象。</li>\n\t<li><code>int add(int val)</code> 将 <code>val</code> 插入数据流 <code>nums</code> 后，返回当前数据流中第 <code>k</code> 大的元素。</li>\n</ul>\n\n<p> </p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n<strong>输出：</strong>\n[null, 4, 5, 5, 8, 8]\n\n<strong>解释：</strong>\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n</pre>\n\n<p> </p>\n<strong>提示：</strong>\n\n<ul>\n\t<li><code>1 <= k <= 10<sup>4</sup></code></li>\n\t<li><code>0 <= nums.length <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> <= val <= 10<sup>4</sup></code></li>\n\t<li>最多调用 <code>add</code> 方法 <code>10<sup>4</sup></code> 次</li>\n\t<li>题目数据保证，在查找第 <code>k</code> 大元素时，数组中至少有 <code>k</code> 个元素</li>\n</ul>\n", "en": "<p>Design a class to find the <code>k<sup>th</sup></code> largest element in a stream. Note that it is the <code>k<sup>th</sup></code> largest element in the sorted order, not the <code>k<sup>th</sup></code> distinct element.</p>\n\n<p>Implement <code>KthLargest</code> class:</p>\n\n<ul>\n\t<li><code>KthLargest(int k, int[] nums)</code> Initializes the object with the integer <code>k</code> and the stream of integers <code>nums</code>.</li>\n\t<li><code>int add(int val)</code> Appends the integer <code>val</code> to the stream and returns the element representing the <code>k<sup>th</sup></code> largest element in the stream.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n<strong>Output</strong>\n[null, 4, 5, 5, 8, 8]\n\n<strong>Explanation</strong>\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= val &lt;= 10<sup>4</sup></code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>add</code>.</li>\n\t<li>It is guaranteed that there will be at least <code>k</code> elements in the array when you search for the <code>k<sup>th</sup></code> element.</li>\n</ul>\n"}}, "704": {"__typename": "QuestionLightNode", "acRate": 0.5527826008575016, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "704", "isFavor": false, "solutionNum": 5629, "title": "Binary Search", "titleCn": "二分查找", "titleSlug": "binary-search", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 94, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个&nbsp;<code>n</code>&nbsp;个元素有序的（升序）整型数组&nbsp;<code>nums</code> 和一个目标值&nbsp;<code>target</code> &nbsp;，写一个函数搜索&nbsp;<code>nums</code>&nbsp;中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>\n\n<p><br>\n<strong>示例 1:</strong></p>\n\n<pre><strong>输入:</strong> <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 9\n<strong>输出:</strong> 4\n<strong>解释:</strong> 9 出现在 <code>nums</code> 中并且下标为 4\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre><strong>输入:</strong> <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 2\n<strong>输出:</strong> -1\n<strong>解释:</strong> 2 不存在 <code>nums</code> 中因此返回 -1\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ol>\n\t<li>你可以假设 <code>nums</code>&nbsp;中的所有元素是不重复的。</li>\n\t<li><code>n</code>&nbsp;将在&nbsp;<code>[1, 10000]</code>之间。</li>\n\t<li><code>nums</code>&nbsp;的每个元素都将在&nbsp;<code>[-9999, 9999]</code>之间。</li>\n</ol>\n", "en": "<p>Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p>\n\n<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0,3,5,9,12], target = 9\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> 9 exists in nums and its index is 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0,3,5,9,12], target = 2\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> 2 does not exist in nums so return -1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt; nums[i], target &lt; 10<sup>4</sup></code></li>\n\t<li>All the integers in <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted in ascending order.</li>\n</ul>\n"}}, "705": {"__typename": "QuestionLightNode", "acRate": 0.6355025591990551, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "705", "isFavor": false, "solutionNum": 652, "title": "Design HashSet", "titleCn": "设计哈希集合", "titleSlug": "design-hashset", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "xp2e97i", "name": "Hash Function", "slug": "hash-function", "nameTranslated": "哈希函数", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 33, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p>\n\n<p>实现 <code>MyHashSet</code> 类：</p>\n\n<ul>\n\t<li><code>void add(key)</code> 向哈希集合中插入值 <code>key</code> 。</li>\n\t<li><code>bool contains(key)</code> 返回哈希集合中是否存在这个值 <code>key</code> 。</li>\n\t<li><code>void remove(key)</code> 将给定值 <code>key</code> 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li>\n</ul>\n&nbsp;\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入：</strong>\n[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]\n<strong>输出：</strong>\n[null, null, null, true, false, null, true, null, false]\n\n<strong>解释：</strong>\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1);      // set = [1]\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(1); // 返回 True\nmyHashSet.contains(3); // 返回 False ，（未找到）\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(2); // 返回 True\nmyHashSet.remove(2);   // set = [1]\nmyHashSet.contains(2); // 返回 False ，（已移除）</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key &lt;= 10<sup>6</sup></code></li>\n\t<li>最多调用 <code>10<sup>4</sup></code> 次 <code>add</code>、<code>remove</code> 和 <code>contains</code></li>\n</ul>\n", "en": "<p>Design a HashSet without using any built-in hash table libraries.</p>\n\n<p>Implement <code>MyHashSet</code> class:</p>\n\n<ul>\n\t<li><code>void add(key)</code> Inserts the value <code>key</code> into the HashSet.</li>\n\t<li><code>bool contains(key)</code> Returns whether the value <code>key</code> exists in the HashSet or not.</li>\n\t<li><code>void remove(key)</code> Removes the value <code>key</code> in the HashSet. If <code>key</code> does not exist in the HashSet, do nothing.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]\n<strong>Output</strong>\n[null, null, null, true, false, null, true, null, false]\n\n<strong>Explanation</strong>\nMyHashSet myHashSet = new MyHashSet();\nmyHashSet.add(1);      // set = [1]\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(1); // return True\nmyHashSet.contains(3); // return False, (not found)\nmyHashSet.add(2);      // set = [1, 2]\nmyHashSet.contains(2); // return True\nmyHashSet.remove(2);   // set = [1]\nmyHashSet.contains(2); // return False, (already removed)</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key &lt;= 10<sup>6</sup></code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>add</code>, <code>remove</code>, and <code>contains</code>.</li>\n</ul>\n"}}, "706": {"__typename": "QuestionLightNode", "acRate": 0.637309190699042, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "706", "isFavor": false, "solutionNum": 625, "title": "Design HashMap", "titleCn": "设计哈希映射", "titleSlug": "design-hashmap", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "xp2e97i", "name": "Hash Function", "slug": "hash-function", "nameTranslated": "哈希函数", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 63, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p>\n\n<p>实现 <code>MyHashMap</code> 类：</p>\n\n<ul>\n\t<li><code>MyHashMap()</code> 用空映射初始化对象</li>\n\t<li><code>void put(int key, int value)</code> 向 HashMap 插入一个键值对 <code>(key, value)</code> 。如果 <code>key</code> 已经存在于映射中，则更新其对应的值 <code>value</code> 。</li>\n\t<li><code>int get(int key)</code> 返回特定的 <code>key</code> 所映射的 <code>value</code> ；如果映射中不包含 <code>key</code> 的映射，返回 <code>-1</code> 。</li>\n\t<li><code>void remove(key)</code> 如果映射中存在 <code>key</code> 的映射，则移除 <code>key</code> 和它所对应的 <code>value</code> 。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例：</strong></p>\n\n<pre>\n<strong>输入</strong>：\n[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\n<strong>输出</strong>：\n[null, null, null, 1, -1, null, 1, null, -1]\n\n<strong>解释</strong>：\nMyHashMap myHashMap = new MyHashMap();\nmyHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]\nmyHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]\nmyHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]\nmyHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]\nmyHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）\nmyHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]\nmyHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]\nmyHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key, value &lt;= 10<sup>6</sup></code></li>\n\t<li>最多调用 <code>10<sup>4</sup></code> 次 <code>put</code>、<code>get</code> 和 <code>remove</code> 方法</li>\n</ul>\n", "en": "<p>Design a HashMap without using any built-in hash table libraries.</p>\n\n<p>Implement the <code>MyHashMap</code> class:</p>\n\n<ul>\n\t<li><code>MyHashMap()</code> initializes the object with an empty map.</li>\n\t<li><code>void put(int key, int value)</code> inserts a <code>(key, value)</code> pair into the HashMap. If the <code>key</code> already exists in the map, update the corresponding <code>value</code>.</li>\n\t<li><code>int get(int key)</code> returns the <code>value</code> to which the specified <code>key</code> is mapped, or <code>-1</code> if this map contains no mapping for the <code>key</code>.</li>\n\t<li><code>void remove(key)</code> removes the <code>key</code> and its corresponding <code>value</code> if the map contains the mapping for the <code>key</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyHashMap&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;remove&quot;, &quot;get&quot;]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\n<strong>Output</strong>\n[null, null, null, 1, -1, null, 1, null, -1]\n\n<strong>Explanation</strong>\nMyHashMap myHashMap = new MyHashMap();\nmyHashMap.put(1, 1); // The map is now [[1,1]]\nmyHashMap.put(2, 2); // The map is now [[1,1], [2,2]]\nmyHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]\nmyHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]\nmyHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)\nmyHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]\nmyHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]\nmyHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= key, value &lt;= 10<sup>6</sup></code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>put</code>, <code>get</code>, and <code>remove</code>.</li>\n</ul>\n"}}, "707": {"__typename": "QuestionLightNode", "acRate": 0.34416352853478077, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "707", "isFavor": false, "solutionNum": 1656, "title": "Design Linked List", "titleCn": "设计链表", "titleSlug": "design-linked-list", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 45, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>\n\n<p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。</p>\n\n<p>如果是双向链表，则还需要属性&nbsp;<code>prev</code>&nbsp;以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p>\n\n<p>实现 <code>MyLinkedList</code> 类：</p>\n\n<ul>\n\t<li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li>\n\t<li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li>\n\t<li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>\n\t<li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li>\n\t<li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li>\n\t<li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong class=\"example\">示例：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n[[], [1], [3], [1, 2], [1], [1], [1]]\n<strong>输出</strong>\n[null, null, null, null, 2, null, 3]\n\n<strong>解释</strong>\nMyLinkedList myLinkedList = new MyLinkedList();\nmyLinkedList.addAtHead(1);\nmyLinkedList.addAtTail(3);\nmyLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3\nmyLinkedList.get(1);              // 返回 2\nmyLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3\nmyLinkedList.get(1);              // 返回 3\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= index, val &lt;= 1000</code></li>\n\t<li>请不要使用内置的 LinkedList 库。</li>\n\t<li>调用 <code>get</code>、<code>addAtHead</code>、<code>addAtTail</code>、<code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的次数不超过 <code>2000</code> 。</li>\n</ul>\n", "en": "<p>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.<br />\nA node in a singly linked list should have two attributes: <code>val</code> and <code>next</code>. <code>val</code> is the value of the current node, and <code>next</code> is a pointer/reference to the next node.<br />\nIf you want to use the doubly linked list, you will need one more attribute <code>prev</code> to indicate the previous node in the linked list. Assume all nodes in the linked list are <strong>0-indexed</strong>.</p>\n\n<p>Implement the <code>MyLinkedList</code> class:</p>\n\n<ul>\n\t<li><code>MyLinkedList()</code> Initializes the <code>MyLinkedList</code> object.</li>\n\t<li><code>int get(int index)</code> Get the value of the <code>index<sup>th</sup></code> node in the linked list. If the index is invalid, return <code>-1</code>.</li>\n\t<li><code>void addAtHead(int val)</code> Add a node of value <code>val</code> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li>\n\t<li><code>void addAtTail(int val)</code> Append a node of value <code>val</code> as the last element of the linked list.</li>\n\t<li><code>void addAtIndex(int index, int val)</code> Add a node of value <code>val</code> before the <code>index<sup>th</sup></code> node in the linked list. If <code>index</code> equals the length of the linked list, the node will be appended to the end of the linked list. If <code>index</code> is greater than the length, the node <strong>will not be inserted</strong>.</li>\n\t<li><code>void deleteAtIndex(int index)</code> Delete the <code>index<sup>th</sup></code> node in the linked list, if the index is valid.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]\n[[], [1], [3], [1, 2], [1], [1], [1]]\n<strong>Output</strong>\n[null, null, null, null, 2, null, 3]\n\n<strong>Explanation</strong>\nMyLinkedList myLinkedList = new MyLinkedList();\nmyLinkedList.addAtHead(1);\nmyLinkedList.addAtTail(3);\nmyLinkedList.addAtIndex(1, 2);    // linked list becomes 1-&gt;2-&gt;3\nmyLinkedList.get(1);              // return 2\nmyLinkedList.deleteAtIndex(1);    // now the linked list is 1-&gt;3\nmyLinkedList.get(1);              // return 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= index, val &lt;= 1000</code></li>\n\t<li>Please do not use the built-in LinkedList library.</li>\n\t<li>At most <code>2000</code> calls will be made to <code>get</code>, <code>addAtHead</code>, <code>addAtTail</code>, <code>addAtIndex</code> and <code>deleteAtIndex</code>.</li>\n</ul>\n"}}, "708": {"__typename": "QuestionLightNode", "acRate": 0.3847865010037437, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "708", "isFavor": false, "solutionNum": 118, "title": "Insert into a Sorted Circular Linked List", "titleCn": "循环有序列表的插入", "titleSlug": "insert-into-a-sorted-circular-linked-list", "topicTags": [{"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "709": {"__typename": "QuestionLightNode", "acRate": 0.7645472786556308, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "709", "isFavor": false, "solutionNum": 1010, "title": "To Lower Case", "titleCn": "转换成小写字母", "titleSlug": "to-lower-case", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 22, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1676257866-SQyOce-Adobe.png", "slug": "adobe", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708939016-IbMkXZ-Unknown-1.jpg", "slug": "apple", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给你一个字符串 <code>s</code> ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"Hello\"\n<strong>输出：</strong>\"hello\"\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"here\"\n<strong>输出：</strong>\"here\"\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>s = \"LOVELY\"\n<strong>输出：</strong>\"lovely\"\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 <= s.length <= 100</code></li>\n\t<li><code>s</code> 由 ASCII 字符集中的可打印字符组成</li>\n</ul>\n", "en": "<p>Given a string <code>s</code>, return <em>the string after replacing every uppercase letter with the same lowercase letter</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;Hello&quot;\n<strong>Output:</strong> &quot;hello&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;here&quot;\n<strong>Output:</strong> &quot;here&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;LOVELY&quot;\n<strong>Output:</strong> &quot;lovely&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code> consists of printable ASCII characters.</li>\n</ul>\n"}}, "710": {"__typename": "QuestionLightNode", "acRate": 0.4330804893925103, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "710", "isFavor": false, "solutionNum": 461, "title": "Random Pick with Blacklist", "titleCn": "黑名单中的随机数", "titleSlug": "random-pick-with-blacklist", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "deo8r", "name": "Math", "slug": "math", "nameTranslated": "数学", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}, {"id": "xp2m6at", "name": "Randomized", "slug": "randomized", "nameTranslated": "随机化", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 18, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/db2c726d9e93256c701c8530c852abbe0b9fa11057ee0a83a775a99b556c872c-two-sigma-logo.png", "slug": "two-sigma", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/cd6a63fa3f2839fe00cb7b0e8b9017e4d8a552e1c9bd2bfeda3a1611bfcb1266-pinterest-1-logo-png-transparent.png", "slug": "pinterest", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个整数 <code>n</code> 和一个 <strong>无重复</strong> 黑名单整数数组&nbsp;<code>blacklist</code>&nbsp;。设计一种算法，从 <code>[0, n - 1]</code> 范围内的任意整数中选取一个&nbsp;<strong>未加入&nbsp;</strong>黑名单&nbsp;<code>blacklist</code>&nbsp;的整数。任何在上述范围内且不在黑名单&nbsp;<code>blacklist</code>&nbsp;中的整数都应该有 <strong>同等的可能性</strong> 被返回。</p>\n\n<p>优化你的算法，使它最小化调用语言 <strong>内置</strong> 随机函数的次数。</p>\n\n<p>实现&nbsp;<code>Solution</code>&nbsp;类:</p>\n\n<ul>\n\t<li><code>Solution(int n, int[] blacklist)</code>&nbsp;初始化整数 <code>n</code> 和被加入黑名单&nbsp;<code>blacklist</code>&nbsp;的整数</li>\n\t<li><code>int pick()</code>&nbsp;返回一个范围为 <code>[0, n - 1]</code> 且不在黑名单&nbsp;<code>blacklist</code> 中的随机整数</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]\n<strong>输出</strong>\n[null, 0, 4, 1, 6, 1, 0, 4]\n\n<b>解释\n</b>Solution solution = new Solution(7, [2, 3, 5]);\nsolution.pick(); // 返回0，任何[0,1,4,6]的整数都可以。注意，对于每一个pick的调用，\n                 // 0、1、4和6的返回概率必须相等(即概率为1/4)。\nsolution.pick(); // 返回 4\nsolution.pick(); // 返回 1\nsolution.pick(); // 返回 6\nsolution.pick(); // 返回 1\nsolution.pick(); // 返回 0\nsolution.pick(); // 返回 4\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= blacklist.length &lt;= min(10<sup>5</sup>, n - 1)</code></li>\n\t<li><code>0 &lt;= blacklist[i] &lt; n</code></li>\n\t<li><code>blacklist</code>&nbsp;中所有值都 <strong>不同</strong></li>\n\t<li>&nbsp;<code>pick</code>&nbsp;最多被调用&nbsp;<code>2 * 10<sup>4</sup></code>&nbsp;次</li>\n</ul>\n", "en": "<p>You are given an integer <code>n</code> and an array of <strong>unique</strong> integers <code>blacklist</code>. Design an algorithm to pick a random integer in the range <code>[0, n - 1]</code> that is <strong>not</strong> in <code>blacklist</code>. Any integer that is in the mentioned range and not in <code>blacklist</code> should be <strong>equally likely</strong> to be returned.</p>\n\n<p>Optimize your algorithm such that it minimizes the number of calls to the <strong>built-in</strong> random function of your language.</p>\n\n<p>Implement the <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution(int n, int[] blacklist)</code> Initializes the object with the integer <code>n</code> and the blacklisted integers <code>blacklist</code>.</li>\n\t<li><code>int pick()</code> Returns a random integer in the range <code>[0, n - 1]</code> and not in <code>blacklist</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Solution&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]\n<strong>Output</strong>\n[null, 0, 4, 1, 6, 1, 0, 4]\n\n<strong>Explanation</strong>\nSolution solution = new Solution(7, [2, 3, 5]);\nsolution.pick(); // return 0, any integer from [0,1,4,6] should be ok. Note that for every call of pick,\n                 // 0, 1, 4, and 6 must be equally likely to be returned (i.e., with probability 1/4).\nsolution.pick(); // return 4\nsolution.pick(); // return 1\nsolution.pick(); // return 6\nsolution.pick(); // return 1\nsolution.pick(); // return 0\nsolution.pick(); // return 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= blacklist.length &lt;= min(10<sup>5</sup>, n - 1)</code></li>\n\t<li><code>0 &lt;= blacklist[i] &lt; n</code></li>\n\t<li>All the values of <code>blacklist</code> are <strong>unique</strong>.</li>\n\t<li>At most <code>2 * 10<sup>4</sup></code> calls will be made to <code>pick</code>.</li>\n</ul>\n"}}, "711": {"__typename": "QuestionLightNode", "acRate": 0.5762070053644683, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "711", "isFavor": false, "solutionNum": 49, "title": "Number of Distinct Islands II", "titleCn": "不同岛屿的数量 II", "titleSlug": "number-of-distinct-islands-ii", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "n6a2i", "name": "Union Find", "slug": "union-find", "nameTranslated": "并查集", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "xp2e97i", "name": "Hash Function", "slug": "hash-function", "nameTranslated": "哈希函数", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 8, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/be5ec360e803521d4f6bd7233729004b801bd6a67932d2c6a10db0343efbc5b2-unnamed-2.jpg", "slug": "bloomberg", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "712": {"__typename": "QuestionLightNode", "acRate": 0.7032322374011374, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "712", "isFavor": false, "solutionNum": 390, "title": "Minimum ASCII Delete Sum for Two Strings", "titleCn": "两个字符串的最小ASCII删除和", "titleSlug": "minimum-ascii-delete-sum-for-two-strings", "topicTags": [{"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 15, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/f6d76e7de8c3eb4752a6116f7a79dec8322be3a60c58fd82e06e06f4088bdfdd-triplebyte_icon_logo_blue_360-1186203c5d2e617dadc22681ee8f112717e95afdc57f0677817ed91f015f479b.png", "slug": "triplebyte", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2021/08/2eec0841-c33d-4e91-b08a-74759855328a/logo.jpg", "slug": "bilibili", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定两个字符串<code>s1</code>&nbsp;和&nbsp;<code>s2</code>，返回 <em>使两个字符串相等所需删除字符的&nbsp;<strong>ASCII&nbsp;</strong>值的最小和&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1:</strong></p>\n\n<pre>\n<strong>输入:</strong> s1 = \"sea\", s2 = \"eat\"\n<strong>输出:</strong> 231\n<strong>解释:</strong> 在 \"sea\" 中删除 \"s\" 并将 \"s\" 的值(115)加入总和。\n在 \"eat\" 中删除 \"t\" 并将 116 加入总和。\n结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入:</strong> s1 = \"delete\", s2 = \"leet\"\n<strong>输出:</strong> 403\n<strong>解释:</strong> 在 \"delete\" 中删除 \"dee\" 字符串变成 \"let\"，\n将 100[d]+101[e]+101[e] 加入总和。在 \"leet\" 中删除 \"e\" 将 101[e] 加入总和。\n结束时，两个字符串都等于 \"let\"，结果即为 100+101+101+101 = 403 。\n如果改为将两个字符串转换为 \"lee\" 或 \"eet\"，我们会得到 433 或 417 的结果，比答案更大。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= s1.length, s2.length &lt;= 1000</code></li>\n\t<li><code>s1</code>&nbsp;和&nbsp;<code>s2</code>&nbsp;由小写英文字母组成</li>\n</ul>\n", "en": "<p>Given two strings <code>s1</code> and&nbsp;<code>s2</code>, return <em>the lowest <strong>ASCII</strong> sum of deleted characters to make two strings equal</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;sea&quot;, s2 = &quot;eat&quot;\n<strong>Output:</strong> 231\n<strong>Explanation:</strong> Deleting &quot;s&quot; from &quot;sea&quot; adds the ASCII value of &quot;s&quot; (115) to the sum.\nDeleting &quot;t&quot; from &quot;eat&quot; adds 116 to the sum.\nAt the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s1 = &quot;delete&quot;, s2 = &quot;leet&quot;\n<strong>Output:</strong> 403\n<strong>Explanation:</strong> Deleting &quot;dee&quot; from &quot;delete&quot; to turn the string into &quot;let&quot;,\nadds 100[d] + 101[e] + 101[e] to the sum.\nDeleting &quot;e&quot; from &quot;leet&quot; adds 101[e] to the sum.\nAt the end, both strings are equal to &quot;let&quot;, and the answer is 100+101+101+101 = 403.\nIf instead we turned both strings into &quot;lee&quot; or &quot;eet&quot;, we would get answers of 433 or 417, which are higher.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s1.length, s2.length &lt;= 1000</code></li>\n\t<li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li>\n</ul>\n"}}, "713": {"__typename": "QuestionLightNode", "acRate": 0.5053292962528659, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "713", "isFavor": false, "solutionNum": 955, "title": "Subarray Product Less Than K", "titleCn": "乘积小于 K 的子数组", "titleSlug": "subarray-product-less-than-k", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 45, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2020/08/be59a295-cbab-45c1-94a3-7e6a3bd5684f/akunacapital-logo.png", "slug": "akuna-capital", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回子数组内所有元素的乘积严格小于<em> </em><code>k</code> 的连续子数组的数目。\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [10,5,2,6], k = 100\n<strong>输出：</strong>8\n<strong>解释：</strong>8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。\n需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,2,3], k = 0\n<strong>输出：</strong>0</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:&nbsp;</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>6</sup></code></li>\n</ul>\n", "en": "<p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than </em><code>k</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,5,2,6], k = 100\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> The 8 subarrays that have product less than 100 are:\n[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\nNote that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3], k = 0\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>6</sup></code></li>\n</ul>\n"}}, "714": {"__typename": "QuestionLightNode", "acRate": 0.7637010736373661, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "714", "isFavor": false, "solutionNum": 1463, "title": "Best Time to Buy and Sell Stock with Transaction Fee", "titleCn": "买卖股票的最佳时机含手续费", "titleSlug": "best-time-to-buy-and-sell-stock-with-transaction-fee", "topicTags": [{"id": "n7hqh", "name": "Greedy", "slug": "greedy", "nameTranslated": "贪心", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 46, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个整数数组&nbsp;<code>prices</code>，其中 <code>prices[i]</code>表示第&nbsp;<code>i</code>&nbsp;天的股票价格 ；整数&nbsp;<code>fee</code> 代表了交易股票的手续费用。</p>\n\n<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>\n\n<p>返回获得利润的最大值。</p>\n\n<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [1, 3, 2, 8, 4, 9], fee = 2\n<strong>输出：</strong>8\n<strong>解释：</strong>能够达到的最大利润:  \n在此处买入&nbsp;prices[0] = 1\n在此处卖出 prices[3] = 8\n在此处买入 prices[4] = 4\n在此处卖出 prices[5] = 9\n总利润:&nbsp;((8 - 1) - 2) + ((9 - 4) - 2) = 8</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>prices = [1,3,7,5,10,3], fee = 3\n<strong>输出：</strong>6\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= prices[i] &lt; 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= fee &lt; 5 * 10<sup>4</sup></code></li>\n</ul>\n", "en": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day, and an integer <code>fee</code> representing a transaction fee.</p>\n\n<p>Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</li>\n\t<li>The transaction fee is only charged once for each stock purchase and sale.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,3,2,8,4,9], fee = 2\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> The maximum profit can be achieved by:\n- Buying at prices[0] = 1\n- Selling at prices[3] = 8\n- Buying at prices[4] = 4\n- Selling at prices[5] = 9\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,3,7,5,10,3], fee = 3\n<strong>Output:</strong> 6\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= prices[i] &lt; 5 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= fee &lt; 5 * 10<sup>4</sup></code></li>\n</ul>\n"}}, "715": {"__typename": "QuestionLightNode", "acRate": 0.5548555536636586, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "715", "isFavor": false, "solutionNum": 254, "title": "Range Module", "titleCn": "Range 模块", "titleSlug": "range-module", "topicTags": [{"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "nytfd", "name": "Segment Tree", "slug": "segment-tree", "nameTranslated": "线段树", "__typename": "CommonTagNode"}, {"id": "qwy9jd", "name": "Ordered Set", "slug": "ordered-set", "nameTranslated": "有序集合", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 23, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>Range模块是跟踪数字范围的模块。设计一个数据结构来跟踪表示为 <strong>半开区间</strong> 的范围并查询它们。</p>\n\n<p><strong>半开区间</strong>&nbsp;<code>[left, right)</code>&nbsp;表示所有&nbsp;<code>left &lt;= x &lt; right</code>&nbsp;的实数 <code>x</code> 。</p>\n\n<p>实现 <code>RangeModule</code> 类:</p>\n\n<ul>\n\t<li><code>RangeModule()</code>&nbsp;初始化数据结构的对象。</li>\n\t<li><code>void addRange(int left, int right)</code> 添加 <strong>半开区间</strong>&nbsp;<code>[left, right)</code>，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间&nbsp;<code>[left, right)</code>&nbsp;中尚未跟踪的任何数字到该区间中。</li>\n\t<li><code>boolean queryRange(int left, int right)</code>&nbsp;只有在当前正在跟踪区间&nbsp;<code>[left, right)</code>&nbsp;中的每一个实数时，才返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。</li>\n\t<li><code>void removeRange(int left, int right)</code>&nbsp;停止跟踪 <strong>半开区间</strong>&nbsp;<code>[left, right)</code>&nbsp;中当前正在跟踪的每个实数。</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入</strong>\n[\"RangeModule\", \"addRange\", \"removeRange\", \"queryRange\", \"queryRange\", \"queryRange\"]\n[[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]\n<strong>输出</strong>\n[null, null, null, true, false, true]\n\n<strong>解释</strong>\nRangeModule rangeModule = new RangeModule();\nrangeModule.addRange(10, 20);\nrangeModule.removeRange(14, 16);\nrangeModule.queryRange(10, 14); 返回 true （区间 [10, 14) 中的每个数都正在被跟踪）\nrangeModule.queryRange(13, 15); 返回 false（未跟踪区间 [13, 15) 中像 14, 14.03, 14.17 这样的数字）\nrangeModule.queryRange(16, 17); 返回 true （尽管执行了删除操作，区间 [16, 17) 中的数字 16 仍然会被跟踪）\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt; right &lt;= 10<sup>9</sup></code></li>\n\t<li>在单个测试用例中，对&nbsp;<code>addRange</code>&nbsp;、&nbsp; <code>queryRange</code>&nbsp;和 <code>removeRange</code> 的调用总数不超过&nbsp;<code>10<sup>4</sup></code>&nbsp;次</li>\n</ul>\n", "en": "<p>A Range Module is a module that tracks ranges of numbers. Design a data structure to track the ranges represented as <strong>half-open intervals</strong> and query about them.</p>\n\n<p>A <strong>half-open interval</strong> <code>[left, right)</code> denotes all the real numbers <code>x</code> where <code>left &lt;= x &lt; right</code>.</p>\n\n<p>Implement the <code>RangeModule</code> class:</p>\n\n<ul>\n\t<li><code>RangeModule()</code> Initializes the object of the data structure.</li>\n\t<li><code>void addRange(int left, int right)</code> Adds the <strong>half-open interval</strong> <code>[left, right)</code>, tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval <code>[left, right)</code> that are not already tracked.</li>\n\t<li><code>boolean queryRange(int left, int right)</code> Returns <code>true</code> if every real number in the interval <code>[left, right)</code> is currently being tracked, and <code>false</code> otherwise.</li>\n\t<li><code>void removeRange(int left, int right)</code> Stops tracking every real number currently being tracked in the <strong>half-open interval</strong> <code>[left, right)</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;RangeModule&quot;, &quot;addRange&quot;, &quot;removeRange&quot;, &quot;queryRange&quot;, &quot;queryRange&quot;, &quot;queryRange&quot;]\n[[], [10, 20], [14, 16], [10, 14], [13, 15], [16, 17]]\n<strong>Output</strong>\n[null, null, null, true, false, true]\n\n<strong>Explanation</strong>\nRangeModule rangeModule = new RangeModule();\nrangeModule.addRange(10, 20);\nrangeModule.removeRange(14, 16);\nrangeModule.queryRange(10, 14); // return True,(Every number in [10, 14) is being tracked)\nrangeModule.queryRange(13, 15); // return False,(Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)\nrangeModule.queryRange(16, 17); // return True, (The number 16 in [16, 17) is still being tracked, despite the remove operation)\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= left &lt; right &lt;= 10<sup>9</sup></code></li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>addRange</code>, <code>queryRange</code>, and <code>removeRange</code>.</li>\n</ul>\n"}}, "716": {"__typename": "QuestionLightNode", "acRate": 0.43296977959554644, "difficulty": "HARD", "freqBar": 0, "paidOnly": true, "status": "NOT_STARTED", "frontendQuestionId": "716", "isFavor": false, "solutionNum": 113, "title": "Max Stack", "titleCn": "最大栈", "titleSlug": "max-stack", "topicTags": [{"id": "nn04j", "name": "Stack", "slug": "stack", "nameTranslated": "栈", "__typename": "CommonTagNode"}, {"id": "nzbej", "name": "Design", "slug": "design", "nameTranslated": "设计", "__typename": "CommonTagNode"}, {"id": "d9m3t", "name": "Linked List", "slug": "linked-list", "nameTranslated": "链表", "__typename": "CommonTagNode"}, {"id": "arqq05", "name": "Doubly-Linked List", "slug": "doubly-linked-list", "nameTranslated": "双向链表", "__typename": "CommonTagNode"}, {"id": "qwy9jd", "name": "Ordered Set", "slug": "ordered-set", "nameTranslated": "有序集合", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 40, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937102-GxHGgg-Unknown-3.jpeg", "slug": "linkedin", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/5bd12e3e40eff4a21834cb14e5ad7979abde52ba3a998e7f1e00e3cbb81a4fca-lyft.jpg", "slug": "lyft", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": null, "en": null}}, "717": {"__typename": "QuestionLightNode", "acRate": 0.5538652758079029, "difficulty": "EASY", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "717", "isFavor": false, "solutionNum": 855, "title": "1-bit and 2-bit Characters", "titleCn": "1 比特与 2 比特字符", "titleSlug": "1-bit-and-2-bit-characters", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 17, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/1bb96b21aee51658cac9909be80203243b75485220d391f31b842da60df0bc83-512x512bb.jpg", "slug": "ixl", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>有两种特殊字符：</p>\n\n<ul>\n\t<li>第一种字符可以用一比特&nbsp;<code>0</code> 表示</li>\n\t<li>第二种字符可以用两比特（<code>10</code>&nbsp;或&nbsp;<code>11</code>）表示</li>\n</ul>\n\n<p>给你一个以 <code>0</code> 结尾的二进制数组&nbsp;<code>bits</code>&nbsp;，如果最后一个字符必须是一个一比特字符，则返回 <code>true</code> 。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> bits = [1, 0, 0]\n<strong>输出:</strong> true\n<strong>解释:</strong> 唯一的解码方式是将其解析为一个两比特字符和一个一比特字符。\n所以最后一个字符是一比特字符。\n</pre>\n\n<p><strong>示例&nbsp;2:</strong></p>\n\n<pre>\n<strong>输入：</strong>bits = [1,1,1,0]\n<strong>输出：</strong>false\n<strong>解释：</strong>唯一的解码方式是将其解析为两比特字符和两比特字符。\n所以最后一个字符不是一比特字符。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bits.length &lt;= 1000</code></li>\n\t<li><code>bits[i]</code> 为 <code>0</code> 或 <code>1</code></li>\n</ul>\n", "en": "<p>We have two special characters:</p>\n\n<ul>\n\t<li>The first character can be represented by one bit <code>0</code>.</li>\n\t<li>The second character can be represented by two bits (<code>10</code> or <code>11</code>).</li>\n</ul>\n\n<p>Given a binary array <code>bits</code> that ends with <code>0</code>, return <code>true</code> if the last character must be a one-bit character.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> bits = [1,0,0]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The only way to decode it is two-bit character and one-bit character.\nSo the last character is one-bit character.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> bits = [1,1,1,0]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The only way to decode it is two-bit character and two-bit character.\nSo the last character is not one-bit character.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bits.length &lt;= 1000</code></li>\n\t<li><code>bits[i]</code> is either <code>0</code> or <code>1</code>.</li>\n</ul>\n"}}, "718": {"__typename": "QuestionLightNode", "acRate": 0.5670969907468023, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "718", "isFavor": false, "solutionNum": 1184, "title": "Maximum Length of Repeated Subarray", "titleCn": "最长重复子数组", "titleSlug": "maximum-length-of-repeated-subarray", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "d2tn7", "name": "Dynamic Programming", "slug": "dynamic-programming", "nameTranslated": "动态规划", "__typename": "CommonTagNode"}, {"id": "x571onh", "name": "Sliding Window", "slug": "sliding-window", "nameTranslated": "滑动窗口", "__typename": "CommonTagNode"}, {"id": "xp2e97i", "name": "Hash Function", "slug": "hash-function", "nameTranslated": "哈希函数", "__typename": "CommonTagNode"}, {"id": "xp2a8mr", "name": "Rolling Hash", "slug": "rolling-hash", "nameTranslated": "滚动哈希", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 47, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/1608896124-NAAKhT-images.png", "slug": "bytedance", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/ca95f7ed3dcc3dba71c4669cf586cfd074ae086c1a1f138ccd1bef80e92edbd3-0.png", "slug": "indeed", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给两个整数数组&nbsp;<code>nums1</code>&nbsp;和&nbsp;<code>nums2</code>&nbsp;，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度&nbsp;</em>。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n<strong>输出：</strong>3\n<strong>解释：</strong>长度最长的公共子数组是 [3,2,1] 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>\n</ul>\n", "en": "<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return <em>the maximum length of a subarray that appears in <strong>both</strong> arrays</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The repeated subarray with maximum length is [3,2,1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The repeated subarray with maximum length is [0,0,0,0,0].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>\n</ul>\n"}}, "719": {"__typename": "QuestionLightNode", "acRate": 0.4729448226806219, "difficulty": "HARD", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "719", "isFavor": false, "solutionNum": 294, "title": "Find K-th Smallest Pair Distance", "titleCn": "找出第 K 小的数对距离", "titleSlug": "find-k-th-smallest-pair-distance", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "do5us", "name": "Two Pointers", "slug": "two-pointers", "nameTranslated": "双指针", "__typename": "CommonTagNode"}, {"id": "drclh", "name": "Binary Search", "slug": "binary-search", "nameTranslated": "二分查找", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 16, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/cd6a63fa3f2839fe00cb7b0e8b9017e4d8a552e1c9bd2bfeda3a1611bfcb1266-pinterest-1-logo-png-transparent.png", "slug": "pinterest", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>数对 <code>(a,b)</code> 由整数 <code>a</code> 和 <code>b</code> 组成，其数对距离定义为 <code>a</code> 和 <code>b</code> 的绝对差值。</p>\n\n<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，数对由 <code>nums[i]</code> 和 <code>nums[j]</code> 组成且满足 <code>0 &lt;= i &lt; j &lt; nums.length</code> 。返回 <strong>所有数对距离中</strong> 第 <code>k</code> 小的数对距离。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,3,1], k = 1\n<strong>输出：</strong>0\n<strong>解释：</strong>数对和对应的距离如下：\n(1,3) -&gt; 2\n(1,1) -&gt; 0\n(3,1) -&gt; 2\n距离第 1 小的数对是 (1,1) ，距离为 0 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,1,1], k = 2\n<strong>输出：</strong>0\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>nums = [1,6,1], k = 3\n<strong>输出：</strong>5\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n * (n - 1) / 2</code></li>\n</ul>\n", "en": "<p>The <strong>distance of a pair</strong> of integers <code>a</code> and <code>b</code> is defined as the absolute difference between <code>a</code> and <code>b</code>.</p>\n\n<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest <strong>distance among all the pairs</strong></em> <code>nums[i]</code> <em>and</em> <code>nums[j]</code> <em>where</em> <code>0 &lt;= i &lt; j &lt; nums.length</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,1], k = 1\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Here are all the pairs:\n(1,3) -&gt; 2\n(1,1) -&gt; 0\n(3,1) -&gt; 2\nThen the 1<sup>st</sup> smallest distance pair is (1,1), and its distance is 0.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1], k = 2\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,6,1], k = 3\n<strong>Output:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n * (n - 1) / 2</code></li>\n</ul>\n"}}, "720": {"__typename": "QuestionLightNode", "acRate": 0.5206635206635206, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "720", "isFavor": false, "solutionNum": 726, "title": "Longest Word in Dictionary", "titleCn": "词典中最长的单词", "titleSlug": "longest-word-in-dictionary", "topicTags": [{"id": "n4z5r", "name": "Trie", "slug": "trie", "nameTranslated": "字典树", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 22, "hasVideoSolution": true, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给出一个字符串数组&nbsp;<code>words</code> 组成的一本英语词典。返回&nbsp;<code>words</code> 中最长的一个单词，该单词是由&nbsp;<code>words</code>&nbsp;词典中其他单词逐步添加一个字母组成。</p>\n\n<p>若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"w\",\"wo\",\"wor\",\"worl\", \"world\"]\n<strong>输出：</strong>\"world\"\n<strong>解释：</strong> 单词\"world\"可由\"w\", \"wo\", \"wor\", 和 \"worl\"逐步添加一个字母组成。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>words = [\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"]\n<strong>输出：</strong>\"apple\"\n<strong>解释：</strong>\"apply\" 和 \"apple\" 都能由词典中的单词组成。但是 \"apple\" 的字典序小于 \"apply\" \n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li>所有输入的字符串&nbsp;<code>words[i]</code>&nbsp;都只包含小写字母。</li>\n</ul>\n", "en": "<p>Given an array of strings <code>words</code> representing an English Dictionary, return <em>the longest word in</em> <code>words</code> <em>that can be built one character at a time by other words in</em> <code>words</code>.</p>\n\n<p>If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.</p>\n\n<p>Note that the word should be built from left to right with each additional character being added to the end of a previous word.&nbsp;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;,&quot;world&quot;]\n<strong>Output:</strong> &quot;world&quot;\n<strong>Explanation:</strong> The word &quot;world&quot; can be built one character at a time by &quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, and &quot;worl&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;banana&quot;,&quot;app&quot;,&quot;appl&quot;,&quot;ap&quot;,&quot;apply&quot;,&quot;apple&quot;]\n<strong>Output:</strong> &quot;apple&quot;\n<strong>Explanation:</strong> Both &quot;apply&quot; and &quot;apple&quot; can be built from other words in the dictionary. However, &quot;apple&quot; is lexicographically smaller than &quot;apply&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 30</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n</ul>\n"}}, "721": {"__typename": "QuestionLightNode", "acRate": 0.4874840753365699, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "721", "isFavor": false, "solutionNum": 464, "title": "Accounts Merge", "titleCn": "账户合并", "titleSlug": "accounts-merge", "topicTags": [{"id": "n8id6", "name": "Depth-First Search", "slug": "depth-first-search", "nameTranslated": "深度优先搜索", "__typename": "CommonTagNode"}, {"id": "n30w2", "name": "Breadth-First Search", "slug": "breadth-first-search", "nameTranslated": "广度优先搜索", "__typename": "CommonTagNode"}, {"id": "n6a2i", "name": "Union Find", "slug": "union-find", "nameTranslated": "并查集", "__typename": "CommonTagNode"}, {"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "wzve3", "name": "Hash Table", "slug": "hash-table", "nameTranslated": "哈希表", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}, {"id": "1v8x3g", "name": "Sorting", "slug": "sorting", "nameTranslated": "排序", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 40, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode.cn/1708937184-xVvbWK-u=2159681834,500194647&fm=253&fmt=auto&app=138&f=JPEG.webp", "slug": "facebook", "__typename": "CommonTagNode"}, {"imgUrl": "https://assets.leetcode-cn.com/aliyun-lc-upload/uploaded_files/2022/09/e9108030-576a-4a77-8539-75de09ce5a5a/%E5%85%AC%E5%8F%B8%20Logo%E7%9A%84%E5%89%AF%E6%9C%AC.png", "slug": "amazon", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给定一个列表 <code>accounts</code>，每个元素 <code>accounts[i]</code>&nbsp;是一个字符串列表，其中第一个元素 <code>accounts[i][0]</code>&nbsp;是&nbsp;<em>名称 (name)</em>，其余元素是 <em><strong>emails</strong> </em>表示该账户的邮箱地址。</p>\n\n<p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p>\n\n<p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是 <strong>按字符 ASCII 顺序排列</strong> 的邮箱地址。账户本身可以以 <strong>任意顺序</strong> 返回。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<b>输入：</b>accounts = [[\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], [\"John\", \"johnnybravo@mail.com\"], [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\n<b>输出：</b>[[\"John\", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  [\"John\", \"johnnybravo@mail.com\"], [\"Mary\", \"mary@mail.com\"]]\n<b>解释：</b>\n第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 \"johnsmith@mail.com\"。 \n第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。\n可以以任何顺序返回这些列表，例如答案 [['Mary'，'mary@mail.com']，['John'，'johnnybravo@mail.com']，\n['John'，'john00@mail.com'，'john_newyork@mail.com'，'johnsmith@mail.com']] 也是正确的。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]\n<strong>输出：</strong>[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= accounts.length &lt;= 1000</code></li>\n\t<li><code>2 &lt;= accounts[i].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= accounts[i][j].length &lt;= 30</code></li>\n\t<li><code>accounts[i][0]</code> 由英文字母组成</li>\n\t<li><code>accounts[i][j] (for j &gt; 0)</code> 是有效的邮箱地址</li>\n</ul>\n", "en": "<p>Given a list of <code>accounts</code> where each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code> is a name, and the rest of the elements are <strong>emails</strong> representing emails of the account.</p>\n\n<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>\n\n<p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <strong>in sorted order</strong>. The accounts themselves can be returned in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> accounts = [[&quot;John&quot;,&quot;johnsmith@mail.com&quot;,&quot;john_newyork@mail.com&quot;],[&quot;John&quot;,&quot;johnsmith@mail.com&quot;,&quot;john00@mail.com&quot;],[&quot;Mary&quot;,&quot;mary@mail.com&quot;],[&quot;John&quot;,&quot;johnnybravo@mail.com&quot;]]\n<strong>Output:</strong> [[&quot;John&quot;,&quot;john00@mail.com&quot;,&quot;john_newyork@mail.com&quot;,&quot;johnsmith@mail.com&quot;],[&quot;Mary&quot;,&quot;mary@mail.com&quot;],[&quot;John&quot;,&quot;johnnybravo@mail.com&quot;]]\n<strong>Explanation:</strong>\nThe first and second John&#39;s are the same person as they have the common email &quot;johnsmith@mail.com&quot;.\nThe third John and Mary are different people as none of their email addresses are used by other accounts.\nWe could return these lists in any order, for example the answer [[&#39;Mary&#39;, &#39;mary@mail.com&#39;], [&#39;John&#39;, &#39;johnnybravo@mail.com&#39;], \n[&#39;John&#39;, &#39;john00@mail.com&#39;, &#39;john_newyork@mail.com&#39;, &#39;johnsmith@mail.com&#39;]] would still be accepted.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> accounts = [[&quot;Gabe&quot;,&quot;Gabe0@m.co&quot;,&quot;Gabe3@m.co&quot;,&quot;Gabe1@m.co&quot;],[&quot;Kevin&quot;,&quot;Kevin3@m.co&quot;,&quot;Kevin5@m.co&quot;,&quot;Kevin0@m.co&quot;],[&quot;Ethan&quot;,&quot;Ethan5@m.co&quot;,&quot;Ethan4@m.co&quot;,&quot;Ethan0@m.co&quot;],[&quot;Hanzo&quot;,&quot;Hanzo3@m.co&quot;,&quot;Hanzo1@m.co&quot;,&quot;Hanzo0@m.co&quot;],[&quot;Fern&quot;,&quot;Fern5@m.co&quot;,&quot;Fern1@m.co&quot;,&quot;Fern0@m.co&quot;]]\n<strong>Output:</strong> [[&quot;Ethan&quot;,&quot;Ethan0@m.co&quot;,&quot;Ethan4@m.co&quot;,&quot;Ethan5@m.co&quot;],[&quot;Gabe&quot;,&quot;Gabe0@m.co&quot;,&quot;Gabe1@m.co&quot;,&quot;Gabe3@m.co&quot;],[&quot;Hanzo&quot;,&quot;Hanzo0@m.co&quot;,&quot;Hanzo1@m.co&quot;,&quot;Hanzo3@m.co&quot;],[&quot;Kevin&quot;,&quot;Kevin0@m.co&quot;,&quot;Kevin3@m.co&quot;,&quot;Kevin5@m.co&quot;],[&quot;Fern&quot;,&quot;Fern0@m.co&quot;,&quot;Fern1@m.co&quot;,&quot;Fern5@m.co&quot;]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= accounts.length &lt;= 1000</code></li>\n\t<li><code>2 &lt;= accounts[i].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= accounts[i][j].length &lt;= 30</code></li>\n\t<li><code>accounts[i][0]</code> consists of English letters.</li>\n\t<li><code>accounts[i][j] (for j &gt; 0)</code> is a valid email.</li>\n</ul>\n"}}, "722": {"__typename": "QuestionLightNode", "acRate": 0.42475297916776356, "difficulty": "MEDIUM", "freqBar": 0, "paidOnly": false, "status": "NOT_STARTED", "frontendQuestionId": "722", "isFavor": false, "solutionNum": 243, "title": "Remove Comments", "titleCn": "删除注释", "titleSlug": "remove-comments", "topicTags": [{"id": "wg0rh", "name": "Array", "slug": "array", "nameTranslated": "数组", "__typename": "CommonTagNode"}, {"id": "dofid", "name": "String", "slug": "string", "nameTranslated": "字符串", "__typename": "CommonTagNode"}], "extra": {"companyTagNum": 25, "hasVideoSolution": false, "topCompanyTags": [{"imgUrl": "https://pic.leetcode-cn.com/dc8ca8220e0392cd08f0832bf03d6df599fa081505f307f09fdc91139aa4b54b-c0c9bfecd0329eeeaee48437456956fea5fcb84185f37de7656eabfe54c595e1-unnamed-1.png", "slug": "microsoft", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/45a64add888e66ff6d3c551bed948528715996937b877aaf6fdc08eae74789f5-google-logo-png-open-2000.png", "slug": "google", "__typename": "CommonTagNode"}, {"imgUrl": "https://pic.leetcode-cn.com/fa52c37e2967ccdfa8747e2699ce4edc6bec733637118f45d2665138acdf8ef4-2000px-Goldman_Sachs.svg_.png", "slug": "goldman-sachs", "__typename": "CommonTagNode"}], "__typename": "QuestionExtraInfoNode"}, "content": {"cn": "<p>给一个 C++ 程序，删除程序中的注释。这个程序<code>source</code>是一个数组，其中<code>source[i]</code>表示第&nbsp;<code>i</code>&nbsp;行源码。&nbsp;这表示每行源码由 <code>'\\n'</code>&nbsp;分隔。</p>\n\n<p>在 C++ 中有两种注释风格，行内注释和块注释。</p>\n\n<ul>\n\t<li>字符串<code>//</code> 表示行注释，表示<code>//</code>和其右侧的其余字符应该被忽略。</li>\n\t<li>字符串<code>/*</code> 表示一个块注释，它表示直到下一个（非重叠）出现的<code>*/</code>之间的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串<code>/*/</code>并没有结束块注释，因为注释的结尾与开头相重叠。</li>\n</ul>\n\n<p>第一个有效注释优先于其他注释。</p>\n\n<ul>\n\t<li>如果字符串<code>//</code>出现在块注释中会被忽略。</li>\n\t<li>同样，如果字符串<code>/*</code>出现在行或块注释中也会被忽略。</li>\n</ul>\n\n<p>如果一行在删除注释之后变为空字符串，那么<strong>不要</strong>输出该行。即，答案列表中的每个字符串都是非空的。</p>\n\n<p>样例中<strong>没有</strong>控制字符，单引号或双引号字符。</p>\n\n<ul>\n\t<li>比如，<code>source = \"string s = \"/* Not a comment. */\";\"</code> 不会出现在测试样例里。</li>\n</ul>\n\n<p>此外，没有其他内容（如定义或宏）会干扰注释。</p>\n\n<p>我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的<code>/*</code>总是开始新的注释。</p>\n\n<p>最后，隐式换行符<strong>可以</strong>通过块注释删除。 有关详细信息，请参阅下面的示例。</p>\n\n<p>从源代码中删除注释后，需要以相同的格式返回源代码。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例&nbsp;1:</strong></p>\n\n<pre>\n<strong>输入:</strong> source = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]\n<strong>输出:</strong> [\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]\n<strong>解释:</strong> 示例代码可以编排成这样:\n/*Test program */\nint main()\n{ \n  // variable declaration \nint a, b, c;\n/* This is a test\n   multiline  \n   comment for \n   testing */\na = b + c;\n}\n第 1 行和第 6-9 行的字符串 /* 表示块注释。第 4 行的字符串 // 表示行注释。\n编排后: \nint main()\n{ \n  \nint a, b, c;\na = b + c;\n}</pre>\n\n<p><strong>示例 2:</strong></p>\n\n<pre>\n<strong>输入:</strong> source = [\"a/*comment\", \"line\", \"more_comment*/b\"]\n<strong>输出:</strong> [\"ab\"]\n<strong>解释:</strong> 原始的 source 字符串是 \"a/*comment<strong>\\n</strong>line<strong>\\n</strong>more_comment*/b\", 其中我们用粗体显示了换行符。删除注释后，隐含的换行符被删除，留下字符串 \"ab\" 用换行符分隔成数组时就是 [\"ab\"].\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= source.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= source[i].length &lt;= 80</code></li>\n\t<li><code>source[i]</code>&nbsp;由可打印的 <strong>ASCII</strong> 字符组成。</li>\n\t<li>每个块注释都会被闭合。</li>\n\t<li>给定的源码中不会有单引号、双引号或其他控制字符。</li>\n</ul>\n<span style=\"display:block\"><span style=\"height:0px\"><span style=\"position:absolute\"><span style=\"top:0px\"><span style=\"left:-9999px\"><span style=\"opacity:0\"><span style=\"overflow:hidden\">&nbsp;</span></span></span></span></span></span>​​​​​​</span>", "en": "<p>Given a C++ program, remove comments from it. The program source is an array of strings <code>source</code> where <code>source[i]</code> is the <code>i<sup>th</sup></code> line of the source code. This represents the resu